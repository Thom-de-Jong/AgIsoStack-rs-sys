/* automatically generated by rust-bindgen 0.63.0 */

pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 10;
pub const __GLIBCXX__: u32 = 20210408;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 0;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const __GTHREAD_HIDE_WIN32API: u32 = 1;
pub const NOMINMAX: u32 = 1;
pub const __USE_MINGW_ANSI_STDIO: u32 = 1;
pub const _GLIBCXX_HAVE_DOS_BASED_FILESYSTEM: u32 = 1;
pub const _GLIBCXX_NO_IOCTL: u32 = 1;
pub const _GLIBCXX_LLP64: u32 = 1;
pub const _GLIBCXX_USE_WEAK_REF: u32 = 0;
pub const _GLIBCXX_THREAD_ATEXIT_WIN32: u32 = 1;
pub const _GTHREAD_USE_MUTEX_INIT_FUNC: u32 = 1;
pub const _GLIBCXX_USE_CRT_RAND_S: u32 = 1;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FPCLASS: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_IEEEFP_H: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISNAN: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE__ALIGNED_MALLOC: u32 = 1;
pub const _GLIBCXX_HAVE__FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE__ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE__WFOPEN: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT: u32 = 1;
pub const LT_OBJDIR: &[u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &[u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15usize] = b"version-unused\0";
pub const STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX_FILE_OFFSET_BITS: u32 = 64;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 1;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_INT128: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GLIBCXX_X86_RDSEED: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const __MINGW64_VERSION_MAJOR: u32 = 10;
pub const __MINGW64_VERSION_MINOR: u32 = 0;
pub const __MINGW64_VERSION_BUGFIX: u32 = 0;
pub const __MINGW64_VERSION_RC: u32 = 0;
pub const __MINGW64_VERSION_STATE: &[u8; 6usize] = b"alpha\0";
pub const __MINGW32_MAJOR_VERSION: u32 = 3;
pub const __MINGW32_MINOR_VERSION: u32 = 11;
pub const _M_AMD64: u32 = 100;
pub const _M_X64: u32 = 100;
pub const __: u32 = 1;
pub const __MINGW_USE_UNDERSCORE_PREFIX: u32 = 0;
pub const __MINGW_HAVE_ANSI_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_ANSI_C99_SCANF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_SCANF: u32 = 1;
pub const __MINGW_SEC_WARN_STR : & [u8 ; 92usize] = b"This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation\0" ;
pub const __MINGW_MSVC2005_DEPREC_STR : & [u8 ; 117usize] = b"This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation\0" ;
pub const __MINGW_FORTIFY_LEVEL: u32 = 0;
pub const __MINGW_FORTIFY_VA_ARG: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const __USE_CRTIMP: u32 = 1;
pub const USE___UUIDOF: u32 = 0;
pub const __CRT__NO_INLINE: u32 = 1;
pub const __MSVCRT_VERSION__: u32 = 1792;
pub const _WIN32_WINNT: u32 = 1537;
pub const MINGW_HAS_SECURE_API: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const MINGW_HAS_DDK_H: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 253;
pub const _ARGMAX: u32 = 100;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _GLIBCXX_TUPLE: u32 = 1;
pub const _GLIBCXX_UTILITY: u32 = 1;
pub const _STL_RELOPS_H: u32 = 1;
pub const _STL_PAIR_H: u32 = 1;
pub const _MOVE_H: u32 = 1;
pub const _GLIBCXX_TYPE_TRAITS: u32 = 1;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const _GLIBCXX_USE_MAKE_INTEGER_SEQ: u32 = 1;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const _GLIBCXX_ARRAY: u32 = 1;
pub const _FUNCTEXCEPT_H: u32 = 1;
pub const _EXCEPTION_DEFINES_H: u32 = 1;
pub const _STL_ALGOBASE_H: u32 = 1;
pub const _CPP_TYPE_TRAITS_H: u32 = 1;
pub const _EXT_TYPE_TRAITS: u32 = 1;
pub const _EXT_NUMERIC_TRAITS: u32 = 1;
pub const _STL_ITERATOR_BASE_TYPES_H: u32 = 1;
pub const _STL_ITERATOR_BASE_FUNCS_H: u32 = 1;
pub const _CONCEPT_CHECK_H: u32 = 1;
pub const _GLIBCXX_DEBUG_ASSERTIONS_H: u32 = 1;
pub const _STL_ITERATOR_H: u32 = 1;
pub const _PTR_TRAITS_H: u32 = 1;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const _GLIBCXX_DEBUG_MACRO_SWITCH_H: u32 = 1;
pub const _GLIBCXX_PREDEFINED_OPS_H: u32 = 1;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const _GLIBCXX_RANGE_ACCESS_H: u32 = 1;
pub const _ITERATOR_CONCEPTS_H: u32 = 1;
pub const _GLIBCXX_CONCEPTS: u32 = 1;
pub const _RANGE_CMP_H: u32 = 1;
pub const _USES_ALLOCATOR_H: u32 = 1;
pub const _GLIBCXX_INVOKE_H: u32 = 1;
pub const _GLIBCXX_MUTEX: u32 = 1;
pub const _GLIBCXX_CHRONO: u32 = 1;
pub const _GLIBCXX_RATIO: u32 = 1;
pub const _GLIBCXX_NUMERIC_LIMITS: u32 = 1;
pub const NULL: u32 = 0;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 200809;
pub const _POSIX_THREAD_CPUTIME: u32 = 200809;
pub const __clockid_t_defined: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_REALTIME_COARSE: u32 = 4;
pub const _GLIBCXX_CTIME: u32 = 1;
pub const _GLIBCXX_PARSE_NUMBERS_H: u32 = 1;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __EXCEPTION_H: u32 = 1;
pub const _CXXABI_INIT_EXCEPTION_H: u32 = 1;
pub const _GLIBCXX_HAVE_CDTOR_CALLABI: u32 = 0;
pub const _HASH_BYTES_H: u32 = 1;
pub const __GXX_MERGED_TYPEINFO_NAMES: u32 = 0;
pub const __GXX_TYPEINFO_EQUALITY_INLINE: u32 = 1;
pub const _GLIBCXX_NESTED_EXCEPTION_H: u32 = 1;
pub const _GLIBCXX_SYSTEM_ERROR: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ENOFILE: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const ENOTSUP: u32 = 129;
pub const EAFNOSUPPORT: u32 = 102;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EISCONN: u32 = 113;
pub const ENOBUFS: u32 = 119;
pub const ECONNABORTED: u32 = 106;
pub const EALREADY: u32 = 103;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOTSOCK: u32 = 128;
pub const ENOTCONN: u32 = 126;
pub const ECANCELED: u32 = 105;
pub const EINPROGRESS: u32 = 112;
pub const EOPNOTSUPP: u32 = 130;
pub const EWOULDBLOCK: u32 = 140;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EBADMSG: u32 = 104;
pub const EIDRM: u32 = 111;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ETIME: u32 = 137;
pub const ETXTBSY: u32 = 139;
pub const ETIMEDOUT: u32 = 138;
pub const ELOOP: u32 = 114;
pub const EPROTOTYPE: u32 = 136;
pub const EOVERFLOW: u32 = 132;
pub const _GLIBCXX_CERRNO: u32 = 1;
pub const _GLIBCXX_IOSFWD: u32 = 1;
pub const _STRINGFWD_H: u32 = 1;
pub const _MEMORYFWD_H: u32 = 1;
pub const _GLIBCXX_POSTYPES_H: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS: u32 = 4;
pub const _CRT_INTERNAL_LOCAL_SCANF_OPTIONS: u32 = 2;
pub const __USE_MINGW_STRTOX: u32 = 1;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const _GLIBCXX_CWCHAR: u32 = 1;
pub const _GLIBCXX_STDEXCEPT: u32 = 1;
pub const _GLIBCXX_STRING: u32 = 1;
pub const _CHAR_TRAITS_H: u32 = 1;
pub const _ALLOCATOR_H: u32 = 1;
pub const _GLIBCXX_CXX_ALLOCATOR_H: u32 = 1;
pub const _NEW_ALLOCATOR_H: u32 = 1;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const _LOCALE_FWD_H: u32 = 1;
pub const _GLIBCXX_CXX_LOCALE_H: u32 = 1;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 20;
pub const EOF: i32 = -1;
pub const _P_tmpdir: &[u8; 2usize] = b"\\\0";
pub const _wP_tmpdir: &[u8; 2usize] = b"\\\0";
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 32767;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const _IOREAD: u32 = 1;
pub const _IOWRT: u32 = 2;
pub const _IOMYBUF: u32 = 8;
pub const _IOEOF: u32 = 16;
pub const _IOERR: u32 = 32;
pub const _IOSTRG: u32 = 64;
pub const _IORW: u32 = 128;
pub const _TWO_DIGIT_EXPONENT: u32 = 1;
pub const P_tmpdir: &[u8; 2usize] = b"\\\0";
pub const SYS_OPEN: u32 = 20;
pub const _P_WAIT: u32 = 0;
pub const _P_NOWAIT: u32 = 1;
pub const _OLD_P_OVERLAY: u32 = 2;
pub const _P_NOWAITO: u32 = 3;
pub const _P_DETACH: u32 = 4;
pub const _P_OVERLAY: u32 = 2;
pub const _WAIT_CHILD: u32 = 0;
pub const _WAIT_GRANDCHILD: u32 = 1;
pub const TMP_MAX_S: u32 = 32767;
pub const LC_ALL: u32 = 0;
pub const LC_COLLATE: u32 = 1;
pub const LC_CTYPE: u32 = 2;
pub const LC_MONETARY: u32 = 3;
pub const LC_NUMERIC: u32 = 4;
pub const LC_TIME: u32 = 5;
pub const LC_MIN: u32 = 0;
pub const LC_MAX: u32 = 5;
pub const _ENABLE_PER_THREAD_LOCALE: u32 = 1;
pub const _DISABLE_PER_THREAD_LOCALE: u32 = 2;
pub const _ENABLE_PER_THREAD_LOCALE_GLOBAL: u32 = 16;
pub const _DISABLE_PER_THREAD_LOCALE_GLOBAL: u32 = 32;
pub const _ENABLE_PER_THREAD_LOCALE_NEW: u32 = 256;
pub const _DISABLE_PER_THREAD_LOCALE_NEW: u32 = 512;
pub const _GLIBCXX_CLOCALE: u32 = 1;
pub const _GLIBCXX_NUM_CATEGORIES: u32 = 0;
pub const _GLIBCXX_CCTYPE: u32 = 1;
pub const _OSTREAM_INSERT_H: u32 = 1;
pub const _CXXABI_FORCED_H: u32 = 1;
pub const _STL_FUNCTION_H: u32 = 1;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const _BACKWARD_BINDERS_H: u32 = 1;
pub const _BASIC_STRING_H: u32 = 1;
pub const _GLIBCXX_ATOMICITY_H: u32 = 1;
pub const _GLIBCXX_GTHREAD_USE_WEAK: u32 = 0;
pub const __GTHREADS: u32 = 1;
pub const __GTHREADS_CXX0X: u32 = 1;
pub const P_WAIT: u32 = 0;
pub const P_NOWAIT: u32 = 1;
pub const P_OVERLAY: u32 = 2;
pub const OLD_P_OVERLAY: u32 = 2;
pub const P_NOWAITO: u32 = 3;
pub const P_DETACH: u32 = 4;
pub const WAIT_CHILD: u32 = 0;
pub const WAIT_GRANDCHILD: u32 = 1;
pub const PATH_MAX: u32 = 260;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const _I8_MIN: i32 = -128;
pub const _I8_MAX: u32 = 127;
pub const _UI8_MAX: u32 = 255;
pub const _I16_MIN: i32 = -32768;
pub const _I16_MAX: u32 = 32767;
pub const _UI16_MAX: u32 = 65535;
pub const _I32_MIN: i32 = -2147483648;
pub const _I32_MAX: u32 = 2147483647;
pub const _UI32_MAX: u32 = 4294967295;
pub const LONG_LONG_MAX: u64 = 9223372036854775807;
pub const LONG_LONG_MIN: i64 = -9223372036854775808;
pub const ULONG_LONG_MAX: i32 = -1;
pub const _I64_MIN: i64 = -9223372036854775808;
pub const _I64_MAX: u64 = 9223372036854775807;
pub const _UI64_MAX: i32 = -1;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const NSIG: u32 = 23;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT_COMPAT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGBREAK: u32 = 21;
pub const SIGABRT: u32 = 22;
pub const SIGABRT2: u32 = 22;
pub const __WINPTHREADS_VERSION_MAJOR: u32 = 0;
pub const __WINPTHREADS_VERSION_MINOR: u32 = 5;
pub const __WINPTHREADS_VERSION_PATCHLEVEL: u32 = 0;
pub const __WINPTHREADS_VERSION: u32 = 327680;
pub const RWLS_PER_THREAD: u32 = 8;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 2;
pub const PTHREAD_CREATE_JOINABLE: u32 = 0;
pub const PTHREAD_CREATE_DETACHED: u32 = 4;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 0;
pub const PTHREAD_INHERIT_SCHED: u32 = 8;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 16;
pub const PTHREAD_DEFAULT_ATTR: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 256;
pub const PTHREAD_KEYS_MAX: u32 = 1048576;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_SHARED: u32 = 1;
pub const PTHREAD_MUTEX_PRIVATE: u32 = 0;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 8;
pub const PTHREAD_PRIO_PROTECT: u32 = 16;
pub const PTHREAD_PRIO_MULT: u32 = 32;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 0;
pub const PTHREAD_MUTEX_FAST_NP: u32 = 0;
pub const PTHREAD_MUTEX_TIMED_NP: u32 = 0;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE_NP: u32 = 2;
pub const PTHREAD_BARRIER_SERIAL_THREAD: u32 = 1;
pub const MAX_READ_LOCKS: u32 = 2147483646;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_MIN: u32 = 0;
pub const SCHED_MAX: u32 = 2;
pub const GENERIC_INITIALIZER: i32 = -1;
pub const GENERIC_ERRORCHECK_INITIALIZER: i32 = -2;
pub const GENERIC_RECURSIVE_INITIALIZER: i32 = -3;
pub const GENERIC_NORMAL_INITIALIZER: i32 = -1;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_SPIN_LOCKS: u32 = 200112;
pub const _POSIX_BARRIERS: u32 = 200112;
pub const _POSIX_TIMEOUTS: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _POSIX_SEMAPHORES: u32 = 200112;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 256;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 1048576;
pub const PTHREAD_THREADS_MAX: u32 = 2019;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const SEM_NSEMS_MAX: u32 = 1024;
pub const __GTHREAD_HAS_COND: u32 = 1;
pub const __GTHREAD_ONCE_INIT: u32 = 0;
pub const _GLIBCXX_ATOMIC_WORD_H: u32 = 1;
pub const _EXT_ALLOC_TRAITS_H: u32 = 1;
pub const _ALLOC_TRAITS_H: u32 = 1;
pub const _STL_CONSTRUCT_H: u32 = 1;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const _STRING_CONVERSIONS_H: u32 = 1;
pub const _GLIBCXX_CSTDLIB: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const RAND_MAX: u32 = 32767;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _MAX_ENV: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _MAX_WAIT_MALLOC_CRT: u32 = 60000;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const _GLIBCXX_CSTDIO: u32 = 1;
pub const _GLIBCXX_CHARCONV_H: u32 = 1;
pub const _FUNCTIONAL_HASH_H: u32 = 1;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const _BASIC_STRING_TCC: u32 = 1;
pub const _GLIBCXX_MUTEX_H: u32 = 1;
pub const _GLIBCXX_UNIQUE_LOCK_H: u32 = 1;
pub const _GLIBCXX_VECTOR: u32 = 1;
pub const _STL_UNINITIALIZED_H: u32 = 1;
pub const _STL_VECTOR_H: u32 = 1;
pub const _STL_BVECTOR_H: u32 = 1;
pub const _VECTOR_TCC: u32 = 1;
pub const _GLIBCXX_LIST: u32 = 1;
pub const _STL_LIST_H: u32 = 1;
pub const _ALLOCATED_PTR_H: u32 = 1;
pub const _ALIGNED_BUFFER_H: u32 = 1;
pub const _LIST_TCC: u32 = 1;
pub const _GLIBCXX_MEMORY: u32 = 1;
pub const _STL_TEMPBUF_H: u32 = 1;
pub const _STL_RAW_STORAGE_ITERATOR_H: u32 = 1;
pub const _RANGES_UNINITIALIZED_H: u32 = 1;
pub const _CONCURRENCE_H: u32 = 1;
pub const _UNIQUE_PTR_H: u32 = 1;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const _SHARED_PTR_H: u32 = 1;
pub const _SHARED_PTR_BASE_H: u32 = 1;
pub const _GLIBCXX_REFWRAP_H: u32 = 1;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const _SHARED_PTR_ATOMIC_H: u32 = 1;
pub const _GLIBCXX_ATOMIC_BASE_H: u32 = 1;
pub const _GLIBCXX_ATOMIC_LOCK_FREE_H: u32 = 1;
pub const _BACKWARD_AUTO_PTR_H: u32 = 1;
pub const _GLIBCXX_THREAD: u32 = 1;
pub type std_nullptr_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numpunct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numpunct_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_collate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_collate_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_get_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Char_alloc_type = u8;
pub type std_basic_string__Alloc_traits = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string___const_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _address: u8,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std_basic_string__bindgen_ty_2 {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_base {
    pub _address: u8,
}
pub type std__List_base__Tp_alloc_type = u8;
pub type std__List_base__Tp_alloc_traits = u8;
pub type std__List_base__Node_alloc_type = u8;
pub type std__List_base__Node_alloc_traits = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_base__List_impl {
    pub _address: u8,
}
pub type std__List_base_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_list {
    pub _address: u8,
}
pub type std_list__Base = u8;
pub type std_list__Tp_alloc_type = u8;
pub type std_list__Tp_alloc_traits = u8;
pub type std_list__Node_alloc_type = u8;
pub type std_list__Node_alloc_traits = u8;
pub type std_list_value_type = u8;
pub type std_list_pointer = u8;
pub type std_list_const_pointer = u8;
pub type std_list_reference = u8;
pub type std_list_const_reference = u8;
pub type std_list_iterator = u8;
pub type std_list_const_iterator = u8;
pub type std_list_const_reverse_iterator = u8;
pub type std_list_reverse_iterator = u8;
pub type std_list_size_type = u64;
pub type std_list_difference_type = u64;
pub type std_list_allocator_type = u8;
pub type std_list__Node = u8;
pub type std_list___remove_return_type = u8;
pub type std_integral_constant_value_type = u8;
pub type std_integral_constant_type = u8;
// extern "C" {
//     #[link_name = "\u{1}value"]
//     pub static std_value: _Tp;
// }
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___bool_constant = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type = u8;
pub type std___type_identity_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___success_type {
    pub _address: u8,
}
pub type std___success_type_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___failure_type {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___failure_type() {
    assert_eq!(
        ::std::mem::size_of::<std___failure_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___failure_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___failure_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___failure_type))
    );
}
pub type std___remove_cv_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integral_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating_point_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_object_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_function_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_null_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
pub type std___is_one_of = u8;
pub type std___is_signed_integer = u8;
pub type std___is_unsigned_integer = u8;
pub type std___is_standard_integer = u8;
pub type std___void_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_known_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_unknown_bounds {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_destructible_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_destructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_destructible_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_is_destructible_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_destructible_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_is_destructible_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_impl {
    pub _address: u8,
}
pub type std___is_destructible_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_nt_destructible_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_nt_destructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_nt_destructible_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_is_nt_destructible_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_nt_destructible_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___do_is_nt_destructible_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_destructible_impl {
    pub _address: u8,
}
pub type std___is_nt_destructible_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_constructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
pub type std___is_nothrow_constructible_impl = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_assignable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_assignable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_implicitly_default_constructible_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_implicitly_default_constructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_implicitly_default_constructible_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___do_is_implicitly_default_constructible_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_implicitly_default_constructible_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___do_is_implicitly_default_constructible_impl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
    pub fn std___do_is_implicitly_default_constructible_impl___test() -> std_false_type;
}
impl std___do_is_implicitly_default_constructible_impl {
    #[inline]
    pub unsafe fn __test() -> std_false_type {
        std___do_is_implicitly_default_constructible_impl___test()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_impl {
    pub _address: u8,
}
pub type std___is_implicitly_default_constructible_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_safe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
pub type std___is_convertible_helper_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
pub type std___is_array_convertible = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type = u8;
pub type std_remove_const_t = u8;
pub type std_remove_volatile_t = u8;
pub type std_remove_cv_t = u8;
pub type std_add_const_t = u8;
pub type std_add_volatile_t = u8;
pub type std_add_cv_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type = u8;
pub type std___add_lvalue_reference_helper_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std___add_rvalue_reference_helper_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_remove_reference_t = u8;
pub type std_add_lvalue_reference_t = u8;
pub type std_add_rvalue_reference_t = u8;
pub type std___match_cv_qualifiers___match = u8;
pub type std___match_cv_qualifiers___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned {
    pub _address: u8,
}
pub type std___make_unsigned___type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base {
    pub _bindgen_opaque_blob: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base__List {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___make_unsigned_selector_base() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned_selector_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___make_unsigned_selector_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned_selector_base>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___make_unsigned_selector_base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_signed {
    pub _address: u8,
}
pub type std___make_signed___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
pub type std_make_signed_t = u8;
pub type std_make_unsigned_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type = u8;
pub type std_remove_extent_t = u8;
pub type std_remove_all_extents_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___remove_pointer_helper {
    pub _address: u8,
}
pub type std___remove_pointer_helper_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
pub type std___add_pointer_helper_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_t = u8;
pub type std_add_pointer_t = u8;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std___aligned_storage_msa___type {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___aligned_storage_msa___type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___aligned_storage_msa___type() {
    assert_eq!(
        ::std::mem::size_of::<std___aligned_storage_msa___type>(),
        8usize,
        concat!("Size of: ", stringify!(std___aligned_storage_msa___type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___aligned_storage_msa___type>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___aligned_storage_msa___type)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strictest_alignment {
    pub _address: u8,
}
pub type std_aligned_union___strictest = u8;
pub type std_aligned_union_type = u8;
extern "C" {
    #[link_name = "\u{1}alignment_value"]
    pub static std_alignment_value: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay___remove_type = u8;
pub type std_decay_type = u8;
pub type std___decay_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strip_reference_wrapper {
    pub _address: u8,
}
pub type std___strip_reference_wrapper___type = u8;
pub type std___decay_and_strip = u8;
pub type std___enable_if_t = u8;
pub type std__Require = u8;
pub type std_conditional_type = u8;
pub type std___remove_cvref_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___do_common_type_impl {
    pub _bindgen_opaque_blob: u8,
}
pub type std___do_common_type_impl___cond_t = u8;
#[test]
fn bindgen_test_layout_std___do_common_type_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_common_type_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_common_type_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_common_type_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_common_type_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
pub type std___common_type_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_pack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_fold {
    pub _address: u8,
}
pub type std___underlying_type_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___declval_protector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_ref {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memfun_ref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memfun_ref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memfun_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memfun_ref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memfun_ref))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_deref {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memfun_deref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memfun_deref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memfun_deref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memfun_deref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memfun_deref))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_ref {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memobj_ref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memobj_ref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memobj_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memobj_ref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memobj_ref))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_deref {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memobj_deref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memobj_deref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memobj_deref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memobj_deref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memobj_deref))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_other {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_other() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_other>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_other))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_other>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_other))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_success {
    pub _address: u8,
}
pub type std___result_of_success___invoke_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_ref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memfun_ref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memfun_ref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memfun_ref_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_memfun_ref_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref {
    pub _address: u8,
}
pub type std___result_of_memfun_ref_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_deref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memfun_deref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memfun_deref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memfun_deref_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___result_of_memfun_deref_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref {
    pub _address: u8,
}
pub type std___result_of_memfun_deref_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_ref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memobj_ref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memobj_ref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memobj_ref_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_memobj_ref_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref {
    pub _address: u8,
}
pub type std___result_of_memobj_ref_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_deref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memobj_deref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memobj_deref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memobj_deref_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___result_of_memobj_deref_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref {
    pub _address: u8,
}
pub type std___result_of_memobj_deref_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___inv_unwrap {
    pub _address: u8,
}
pub type std___inv_unwrap_type = u8;
pub type std___result_of_impl_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_other_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_other_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_other_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_other_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_other_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_other_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_result {
    pub _address: u8,
}
pub type std_aligned_storage_t = u8;
pub type std_aligned_union_t = u8;
pub type std_decay_t = u8;
pub type std_enable_if_t = u8;
pub type std_conditional_t = u8;
pub type std_common_type_t = u8;
pub type std_underlying_type_t = u8;
pub type std_result_of_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = u8;
pub type std___detector_type = u8;
pub type std___detected_or = u8;
pub type std___detected_or_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_swappable_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_details___do_is_swappable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_details___do_is_swappable_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_details___do_is_swappable_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_details___do_is_swappable_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_details___do_is_swappable_impl)
        )
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_nothrow_swappable_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_details___do_is_nothrow_swappable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_details___do_is_nothrow_swappable_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_details___do_is_nothrow_swappable_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_details___do_is_nothrow_swappable_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_details___do_is_nothrow_swappable_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_impl {
    pub _address: u8,
}
pub type std___is_swappable_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___call_is_nothrow {
    pub _address: u8,
}
pub type std___call_is_nothrow_ = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_invocable {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___nonesuchbase {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___nonesuchbase() {
    assert_eq!(
        ::std::mem::size_of::<std___nonesuchbase>(),
        1usize,
        concat!("Size of: ", stringify!(std___nonesuchbase))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nonesuchbase>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nonesuchbase))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___nonesuch {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___nonesuch() {
    assert_eq!(
        ::std::mem::size_of::<std___nonesuch>(),
        1usize,
        concat!("Size of: ", stringify!(std___nonesuch))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nonesuch>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nonesuch))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___move_if_noexcept_cond {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_piecewise_construct_t() {
    assert_eq!(
        ::std::mem::size_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_piecewise_construct_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_piecewise_construct_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZStL19piecewise_construct"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list {
    pub _address: u8,
}
pub type std_initializer_list_value_type = u8;
pub type std_initializer_list_reference = u8;
pub type std_initializer_list_const_reference = u8;
pub type std_initializer_list_size_type = u64;
pub type std_initializer_list_iterator = u8;
pub type std_initializer_list_const_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
pub type std___enable_if_has_tuple_size = u8;
pub type std___tuple_element_t = u8;
pub type std_tuple_element_t = u8;
pub type std__Build_index_tuple__IdxTuple = u8;
pub type std__Build_index_tuple___type = u8;
pub type std_integer_sequence_value_type = u8;
pub type std_make_integer_sequence = u8;
pub type std_index_sequence = u8;
pub type std_make_index_sequence = u8;
pub type std_index_sequence_for = u8;
extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_bad_exceptionv"]
    pub fn std___throw_bad_exception() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt16__throw_bad_castv"]
    pub fn std___throw_bad_cast() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18__throw_bad_typeidv"]
    pub fn std___throw_bad_typeid() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_logic_errorPKc"]
    pub fn std___throw_logic_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_domain_errorPKc"]
    pub fn std___throw_domain_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_invalid_argumentPKc"]
    pub fn std___throw_invalid_argument(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_length_errorPKc"]
    pub fn std___throw_length_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_out_of_rangePKc"]
    pub fn std___throw_out_of_range(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_out_of_range_fmtPKcz"]
    pub fn std___throw_out_of_range_fmt(arg1: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_runtime_errorPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_range_errorPKc"]
    pub fn std___throw_range_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt22__throw_overflow_errorPKc"]
    pub fn std___throw_overflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt23__throw_underflow_errorPKc"]
    pub fn std___throw_underflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKc"]
    pub fn std___throw_ios_failure(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKci"]
    pub fn std___throw_ios_failure1(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_system_errori"]
    pub fn std___throw_system_error(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_future_errori"]
    pub fn std___throw_future_error(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt25__throw_bad_function_callv"]
    pub fn std___throw_bad_function_call() -> !;
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___true_type {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___true_type() {
    assert_eq!(
        ::std::mem::size_of::<std___true_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___true_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___true_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___true_type))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___false_type {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___false_type() {
    assert_eq!(
        ::std::mem::size_of::<std___false_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___false_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___false_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___false_type))
    );
}
pub type std___truth_type___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traitor {
    pub _address: u8,
}
pub const std___traitor___value: std___traitor__bindgen_ty_1 = 0;
pub type std___traitor__bindgen_ty_1 = i32;
pub type std___traitor___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___are_same {
    pub _address: u8,
}
pub const std___are_same___value: std___are_same__bindgen_ty_1 = 0;
pub type std___are_same__bindgen_ty_1 = i32;
pub type std___are_same___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void {
    pub _address: u8,
}
pub const std___is_void___value: std___is_void__bindgen_ty_1 = 0;
pub type std___is_void__bindgen_ty_1 = i32;
pub type std___is_void___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integer {
    pub _address: u8,
}
pub const std___is_integer___value: std___is_integer__bindgen_ty_1 = 0;
pub type std___is_integer__bindgen_ty_1 = i32;
pub type std___is_integer___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating {
    pub _address: u8,
}
pub const std___is_floating___value: std___is_floating__bindgen_ty_1 = 0;
pub type std___is_floating__bindgen_ty_1 = i32;
pub type std___is_floating___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer {
    pub _address: u8,
}
pub const std___is_pointer___value: std___is_pointer__bindgen_ty_1 = 0;
pub type std___is_pointer__bindgen_ty_1 = i32;
pub type std___is_pointer___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_char {
    pub _address: u8,
}
pub const std___is_char___value: std___is_char__bindgen_ty_1 = 0;
pub type std___is_char__bindgen_ty_1 = i32;
pub type std___is_char___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte {
    pub _address: u8,
}
pub const std___is_byte___value: std___is_byte__bindgen_ty_1 = 0;
pub type std___is_byte__bindgen_ty_1 = i32;
pub type std___is_byte___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nonvolatile_trivially_copyable {
    pub _address: u8,
}
pub const std___is_nonvolatile_trivially_copyable___value:
    std___is_nonvolatile_trivially_copyable__bindgen_ty_1 = 0;
pub type std___is_nonvolatile_trivially_copyable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___memcpyable {
    pub _address: u8,
}
pub const std___memcpyable___value: std___memcpyable__bindgen_ty_1 = 0;
pub type std___memcpyable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___memcmpable {
    pub _address: u8,
}
pub const std___memcmpable___value: std___memcmpable__bindgen_ty_1 = 0;
pub type std___memcmpable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_iterator {
    pub _address: u8,
}
pub const std___is_move_iterator___value: std___is_move_iterator__bindgen_ty_1 = 0;
pub type std___is_move_iterator__bindgen_ty_1 = i32;
pub type std___is_move_iterator___type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_output_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_output_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_output_iterator_tag))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_random_access_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_random_access_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category = u8;
pub type std_iterator_value_type = u8;
pub type std_iterator_difference_type = u8;
pub type std_iterator_pointer = u8;
pub type std_iterator_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std___iterator_category_t = u8;
pub type std__RequireInputIter = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_random_access_iter {
    pub _address: u8,
}
pub type std___is_random_access_iter__Base = u8;
pub const std___is_random_access_iter___value: std___is_random_access_iter__bindgen_ty_1 = 0;
pub type std___is_random_access_iter__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = u8;
pub type std___get_first_arg_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
pub type std___replace_first_arg_t = u8;
pub type std___make_not_void = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = u8;
pub type std_pointer_traits___difference_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer = u8;
pub type std_pointer_traits_element_type = u8;
pub type std_pointer_traits_difference_type = u8;
pub type std_pointer_traits_rebind = u8;
pub type std___ptr_rebind = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator {
    pub _address: u8,
}
pub type std_reverse_iterator___traits_type = u8;
pub type std_reverse_iterator_iterator_type = u8;
pub type std_reverse_iterator_difference_type = u8;
pub type std_reverse_iterator_pointer = u8;
pub type std_reverse_iterator_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator {
    pub _address: u8,
}
pub type std_back_insert_iterator_container_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator {
    pub _address: u8,
}
pub type std_front_insert_iterator_container_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_insert_iterator {
    pub _address: u8,
}
pub type std_insert_iterator__Iter = u8;
pub type std_insert_iterator_container_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator {
    pub _address: u8,
}
pub type std_move_iterator___traits_type = u8;
pub type std_move_iterator___base_ref = u8;
pub type std_move_iterator_iterator_type = u8;
pub type std_move_iterator_iterator_category = u8;
pub type std_move_iterator_value_type = u8;
pub type std_move_iterator_difference_type = u8;
pub type std_move_iterator_pointer = u8;
pub type std_move_iterator_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istreambuf_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Deque_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___lc_rai {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_valarray {
    pub _address: u8,
}
pub type std___array_traits__Type = u8;
pub type std___array_traits__Is_swappable = u8;
pub type std___array_traits__Is_nothrow_swappable = u8;
pub type std_array_value_type = u8;
pub type std_array_pointer = u8;
pub type std_array_const_pointer = u8;
pub type std_array_reference = u8;
pub type std_array_const_reference = u8;
pub type std_array_iterator = u8;
pub type std_array_const_iterator = u8;
pub type std_array_size_type = u64;
pub type std_array_difference_type = u64;
pub type std_array_reverse_iterator = u8;
pub type std_array_const_reverse_iterator = u8;
pub type std_array__AT_Type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___erased_type {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___erased_type() {
    assert_eq!(
        ::std::mem::size_of::<std___erased_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___erased_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___erased_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___erased_type))
    );
}
pub type std___is_erased_or_convertible = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_arg_t {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_allocator_arg_t() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_allocator_arg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_allocator_arg_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZStL13allocator_arg"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_allocator_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc_base {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___uses_alloc_base() {
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc_base))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0 {
    pub _bindgen_opaque_blob: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0__Sink {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___uses_alloc0__Sink() {
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc0__Sink>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc0__Sink))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc0__Sink>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc0__Sink))
    );
}
#[test]
fn bindgen_test_layout_std___uses_alloc0() {
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc0>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc0))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc0>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc0))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc2 {
    pub _address: u8,
}
pub type std___uses_alloc_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_predicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_uses_allocator_constructible {
    pub _address: u8,
}
pub type std___can_invoke_as_void = u8;
pub type std___can_invoke_as_nonvoid = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_empty_non_tuple {
    pub _address: u8,
}
pub type std___empty_not_final = u8;
pub type std__TupleConstraints_is_constructible = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
pub type std_tuple__TCC = u8;
pub type std_tuple__ImplicitDefaultCtor = u8;
pub type std_tuple__ExplicitDefaultCtor = u8;
pub type std_tuple__ImplicitCtor = u8;
pub type std_tuple__ExplicitCtor = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__UseOtherCtor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___combine_tuples {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_cat_result {
    pub _address: u8,
}
pub type std___tuple_cat_result___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_1st_indices {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_concater {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std__Swallow_assign {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std__Swallow_assign() {
    assert_eq!(
        ::std::mem::size_of::<std__Swallow_assign>(),
        1usize,
        concat!("Size of: ", stringify!(std__Swallow_assign))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Swallow_assign>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Swallow_assign))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZStL6ignore"]
    pub static std_ignore: std__Swallow_assign;
}
pub const std___safe_multiply___c: uintmax_t = 4294967296;
extern "C" {
    #[link_name = "\u{1}__a0"]
    pub static std___safe_multiply___a0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__a1"]
    pub static std___safe_multiply___a1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__b0"]
    pub static std___safe_multiply___b0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__b1"]
    pub static std___safe_multiply___b1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___safe_multiply_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_add___lo: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_add___hi: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_sub___lo: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_sub___hi: uintmax_t;
}
pub const std___big_mul___c: uintmax_t = 4294967296;
extern "C" {
    #[link_name = "\u{1}__x0"]
    pub static std___big_mul___x0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__x1"]
    pub static std___big_mul___x1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__y0"]
    pub static std___big_mul___y0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__y1"]
    pub static std___big_mul___y1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__x0y0"]
    pub static std___big_mul___x0y0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__x0y1"]
    pub static std___big_mul___x0y1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__x1y0"]
    pub static std___big_mul___x1y0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__x1y1"]
    pub static std___big_mul___x1y1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__mix"]
    pub static std___big_mul___mix: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__mix_lo"]
    pub static std___big_mul___mix_lo: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__mix_hi"]
    pub static std___big_mul___mix_hi: uintmax_t;
}
pub type std___big_mul__Res = u8;
extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_mul___hi: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_mul___lo: uintmax_t;
}
pub const std___big_div_impl___c: uintmax_t = 4294967296;
extern "C" {
    #[link_name = "\u{1}__d1"]
    pub static std___big_div_impl___d1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__d0"]
    pub static std___big_div_impl___d0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__q1x"]
    pub static std___big_div_impl___q1x: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__r1x"]
    pub static std___big_div_impl___r1x: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__m"]
    pub static std___big_div_impl___m: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__r1y"]
    pub static std___big_div_impl___r1y: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__r1z"]
    pub static std___big_div_impl___r1z: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__r1"]
    pub static std___big_div_impl___r1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__q1"]
    pub static std___big_div_impl___q1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__q0x"]
    pub static std___big_div_impl___q0x: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__r0x"]
    pub static std___big_div_impl___r0x: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__n"]
    pub static std___big_div_impl___n: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__r0y"]
    pub static std___big_div_impl___r0y: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__r0z"]
    pub static std___big_div_impl___r0z: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__r0"]
    pub static std___big_div_impl___r0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__q0"]
    pub static std___big_div_impl___q0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__quot"]
    pub static std___big_div_impl___quot: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__rem"]
    pub static std___big_div_impl___rem: uintmax_t;
}
pub type std___big_div_impl__Prod = u8;
pub type std___big_div_impl__Sum = u8;
extern "C" {
    #[link_name = "\u{1}__shift"]
    pub static std___big_div___shift: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__coshift_"]
    pub static std___big_div___coshift_: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__coshift"]
    pub static std___big_div___coshift: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__c1"]
    pub static std___big_div___c1: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__c2"]
    pub static std___big_div___c2: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__new_d"]
    pub static std___big_div___new_d: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__new_n0"]
    pub static std___big_div___new_n0: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__n1_shifted"]
    pub static std___big_div___n1_shifted: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__n0_top"]
    pub static std___big_div___n0_top: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__new_n1"]
    pub static std___big_div___new_n1: uintmax_t;
}
pub type std___big_div__Res = u8;
extern "C" {
    #[link_name = "\u{1}__quot_hi"]
    pub static std___big_div___quot_hi: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__quot_lo"]
    pub static std___big_div___quot_lo: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}__rem"]
    pub static std___big_div___rem: uintmax_t;
}
pub type std___big_div__P0 = u8;
pub type std___big_div__P1 = u8;
pub type std___big_div__Sum = u8;
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_num: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_den: intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_multiply {
    pub _address: u8,
}
pub type std___ratio_multiply_type = u8;
pub type std_ratio_multiply = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_divide {
    pub _address: u8,
}
pub type std___ratio_divide_type = u8;
pub type std_ratio_divide = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_not_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_less_impl_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater_equal {
    pub _address: u8,
}
pub type std___ratio_add_impl___t = u8;
pub type std___ratio_add_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_add {
    pub _address: u8,
}
pub type std___ratio_add_type = u8;
pub type std_ratio_add = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_subtract {
    pub _address: u8,
}
pub type std___ratio_subtract_type = u8;
pub type std_ratio_subtract = u8;
pub type std_atto = u8;
pub type std_femto = u8;
pub type std_pico = u8;
pub type std_nano = u8;
pub type std_micro = u8;
pub type std_milli = u8;
pub type std_centi = u8;
pub type std_deci = u8;
pub type std_deca = u8;
pub type std_hecto = u8;
pub type std_kilo = u8;
pub type std_mega = u8;
pub type std_giga = u8;
pub type std_tera = u8;
pub type std_peta = u8;
pub type std_exa = u8;
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___numeric_limits_base {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___numeric_limits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___numeric_limits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___numeric_limits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___numeric_limits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___numeric_limits_base))
    );
}
pub const std___numeric_limits_base_is_specialized: bool = false;
pub const std___numeric_limits_base_digits: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_is_signed: bool = false;
pub const std___numeric_limits_base_is_integer: bool = false;
pub const std___numeric_limits_base_is_exact: bool = false;
pub const std___numeric_limits_base_radix: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_has_infinity: bool = false;
pub const std___numeric_limits_base_has_quiet_NaN: bool = false;
pub const std___numeric_limits_base_has_signaling_NaN: bool = false;
extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base10has_denormE"]
    pub static std___numeric_limits_base_has_denorm: std_float_denorm_style;
}
pub const std___numeric_limits_base_has_denorm_loss: bool = false;
pub const std___numeric_limits_base_is_iec559: bool = false;
pub const std___numeric_limits_base_is_bounded: bool = false;
pub const std___numeric_limits_base_is_modulo: bool = false;
pub const std___numeric_limits_base_traps: bool = false;
pub const std___numeric_limits_base_tinyness_before: bool = false;
extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base11round_styleE"]
    pub static std___numeric_limits_base_round_style: std_float_round_style;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
pub type std___parse_int__Digit_impl___valid = u8;
pub type std___parse_int___ull_constant = u8;
pub type std___parse_int__Power_help___next = u8;
pub type std___parse_int__Power_help___valid_digit = u8;
pub type std___parse_int__Power_help_type = u8;
pub type std___parse_int__Number_help___digit = u8;
pub type std___parse_int__Number_help___valid_digit = u8;
pub type std___parse_int__Number_help_type = u8;
pub type std___select_int__Select_int = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___is_duration {
    pub _address: u8,
}
pub type std_chrono___enable_if_is_duration = u8;
pub type std_chrono___disable_if_is_duration = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_treat_as_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration_values {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___is_ratio {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration {
    pub _address: u8,
}
pub type std_chrono_duration___is_float = u8;
pub type std_chrono_duration___divide = u8;
pub type std_chrono_duration___is_harmonic = u8;
pub type std_chrono_duration_rep = u8;
pub type std_chrono_duration_period = u8;
pub type std_chrono___common_rep_t = u8;
pub type std_chrono_nanoseconds = u64;
pub type std_chrono_microseconds = u64;
pub type std_chrono_milliseconds = u64;
pub type std_chrono_seconds = u64;
pub type std_chrono_minutes = u64;
pub type std_chrono_hours = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_time_point {
    pub _address: u8,
}
pub type std_chrono_time_point_clock = u8;
pub type std_chrono_time_point_duration = u8;
pub type std_chrono_time_point_rep = u8;
pub type std_chrono_time_point_period = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_system_clock {
    pub _bindgen_opaque_blob: u8,
}
pub type std_chrono_system_clock_duration = u64;
pub type std_chrono_system_clock_rep = u64;
pub type std_chrono_system_clock_period = u8;
pub type std_chrono_system_clock_time_point = u64;
#[test]
fn bindgen_test_layout_std_chrono_system_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_system_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_chrono_system_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_system_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_chrono_system_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212system_clock3nowEv"]
    pub fn std_chrono_system_clock_now() -> std_chrono_system_clock_time_point;
}
impl std_chrono_system_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_system_clock_time_point {
        std_chrono_system_clock_now()
    }
}
pub const std_chrono_system_clock_is_steady: bool = false;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_steady_clock {
    pub _bindgen_opaque_blob: u8,
}
pub type std_chrono_steady_clock_duration = u64;
pub type std_chrono_steady_clock_rep = u64;
pub type std_chrono_steady_clock_period = u8;
pub type std_chrono_steady_clock_time_point = u8;
#[test]
fn bindgen_test_layout_std_chrono_steady_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_steady_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_chrono_steady_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_steady_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_chrono_steady_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212steady_clock3nowEv"]
    pub fn std_chrono_steady_clock_now() -> std_chrono_steady_clock_time_point;
}
impl std_chrono_steady_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_steady_clock_time_point {
        std_chrono_steady_clock_now()
    }
}
pub const std_chrono_steady_clock_is_steady: bool = true;
pub type std_chrono_high_resolution_clock = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___duration_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___timepoint_common_type {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_exception {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_exception {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_bad_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13bad_exceptionD1Ev"]
    pub fn std_bad_exception_bad_exception_destructor(this: *mut std_bad_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt13bad_exception4whatEv"]
    pub fn std_bad_exception_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_terminate_handler = u64;
pub type std_unexpected_handler = u64;
extern "C" {
    #[link_name = "\u{1}_ZSt13set_terminatePFvvE"]
    pub fn std_set_terminate(arg1: std_terminate_handler) -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt13get_terminatev"]
    pub fn std_get_terminate() -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt9terminatev"]
    pub fn std_terminate() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt14set_unexpectedPFvvE"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler) -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt14get_unexpectedv"]
    pub fn std_get_unexpected() -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt10unexpectedv"]
    pub fn std_unexpected() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18uncaught_exceptionv"]
    pub fn std_uncaught_exception() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZSt11_Hash_bytesPKvyy"]
    pub fn std__Hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZSt15_Fnv_hash_bytesPKvyy"]
    pub fn std__Fnv_hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_type_info {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_type_info() {
    assert_eq!(
        ::std::mem::size_of::<std_type_info>(),
        16usize,
        concat!("Size of: ", stringify!(std_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<std_type_info>(),
        8usize,
        concat!("Alignment of ", stringify!(std_type_info))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9type_infoD1Ev"]
    pub fn std_type_info_type_info_destructor(this: *mut std_type_info);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info14__is_pointer_pEv"]
    pub fn std_type_info___is_pointer_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info15__is_function_pEv"]
    pub fn std_type_info___is_function_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info10__do_catchEPKS_PPvj"]
    pub fn std_type_info___do_catch(
        this: *mut ::std::os::raw::c_void,
        __thr_type: *const std_type_info,
        __thr_obj: *mut *mut ::std::os::raw::c_void,
        __outer: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info11__do_upcastEPKN10__cxxabiv117__class_type_infoEPPv"]
    pub fn std_type_info___do_upcast(
        this: *mut ::std::os::raw::c_void,
        __target: *const __cxxabiv1___class_type_info,
        __obj_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_cast {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_bad_cast() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_cast>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_cast))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_cast>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_cast))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8bad_castD1Ev"]
    pub fn std_bad_cast_bad_cast_destructor(this: *mut std_bad_cast);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8bad_cast4whatEv"]
    pub fn std_bad_cast_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_typeid {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_bad_typeid() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_typeid>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_typeid))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_typeid>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_typeid))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10bad_typeidD1Ev"]
    pub fn std_bad_typeid_bad_typeid_destructor(this: *mut std_bad_typeid);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt10bad_typeid4whatEv"]
    pub fn std_bad_typeid_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_alloc {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_bad_alloc() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_alloc>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_alloc))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_alloc>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_alloc))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9bad_allocD1Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_array_new_length {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_bad_array_new_length() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_array_new_length>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_array_new_length))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_array_new_length>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_array_new_length))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt20bad_array_new_lengthD1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length_destructor(
        this: *mut std_bad_array_new_length,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt20bad_array_new_length4whatEv"]
    pub fn std_bad_array_new_length_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_nothrow_t {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_nothrow_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nothrow_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_nothrow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nothrow_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_nothrow_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt7nothrow"]
    pub static std_nothrow: std_nothrow_t;
}
pub type std_new_handler = u64;
extern "C" {
    #[link_name = "\u{1}_ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt15get_new_handlerv"]
    pub fn std_get_new_handler() -> std_new_handler;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std___exception_ptr_exception_ptr {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std___exception_ptr_exception_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std___exception_ptr_exception_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std___exception_ptr_exception_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std___exception_ptr_exception_ptr>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___exception_ptr_exception_ptr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptr4swapERS0_"]
    pub fn std___exception_ptr_exception_ptr_swap(
        this: *mut std___exception_ptr_exception_ptr,
        arg1: *mut std___exception_ptr_exception_ptr,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt15__exception_ptr13exception_ptr20__cxa_exception_typeEv"]
    pub fn std___exception_ptr_exception_ptr___cxa_exception_type(
        this: *const std___exception_ptr_exception_ptr,
    ) -> *const std_type_info;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrC1Ev"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr(
        this: *mut std___exception_ptr_exception_ptr,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrC1ERKS0_"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr1(
        this: *mut std___exception_ptr_exception_ptr,
        arg1: *const std___exception_ptr_exception_ptr,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrD1Ev"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr_destructor(
        this: *mut std___exception_ptr_exception_ptr,
    );
}
impl std___exception_ptr_exception_ptr {
    #[inline]
    pub unsafe fn swap(&mut self, arg1: *mut std___exception_ptr_exception_ptr) {
        std___exception_ptr_exception_ptr_swap(self, arg1)
    }
    #[inline]
    pub unsafe fn __cxa_exception_type(&self) -> *const std_type_info {
        std___exception_ptr_exception_ptr___cxa_exception_type(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___exception_ptr_exception_ptr_exception_ptr(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std___exception_ptr_exception_ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___exception_ptr_exception_ptr_exception_ptr1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___exception_ptr_exception_ptr_exception_ptr_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZSt17current_exceptionv"]
    pub fn std_current_exception() -> std___exception_ptr_exception_ptr;
}
extern "C" {
    #[link_name = "\u{1}_ZSt17rethrow_exceptionNSt15__exception_ptr13exception_ptrE"]
    pub fn std_rethrow_exception(arg1: std___exception_ptr_exception_ptr) -> !;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_nested_exception {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_nested_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_nested_exception>(),
        16usize,
        concat!("Size of: ", stringify!(std_nested_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nested_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_nested_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16nested_exceptionD1Ev"]
    pub fn std_nested_exception_nested_exception_destructor(this: *mut std_nested_exception);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Nested_exception {
    pub _address: u8,
}
pub type std___rethrow_if_nested_cond = u8;
pub const std_errc_address_family_not_supported: std_errc = 102;
pub const std_errc_address_in_use: std_errc = 100;
pub const std_errc_address_not_available: std_errc = 101;
pub const std_errc_already_connected: std_errc = 113;
pub const std_errc_argument_list_too_long: std_errc = 7;
pub const std_errc_argument_out_of_domain: std_errc = 33;
pub const std_errc_bad_address: std_errc = 14;
pub const std_errc_bad_file_descriptor: std_errc = 9;
pub const std_errc_bad_message: std_errc = 104;
pub const std_errc_broken_pipe: std_errc = 32;
pub const std_errc_connection_aborted: std_errc = 106;
pub const std_errc_connection_already_in_progress: std_errc = 103;
pub const std_errc_connection_refused: std_errc = 107;
pub const std_errc_connection_reset: std_errc = 108;
pub const std_errc_cross_device_link: std_errc = 18;
pub const std_errc_destination_address_required: std_errc = 109;
pub const std_errc_device_or_resource_busy: std_errc = 16;
pub const std_errc_directory_not_empty: std_errc = 41;
pub const std_errc_executable_format_error: std_errc = 8;
pub const std_errc_file_exists: std_errc = 17;
pub const std_errc_file_too_large: std_errc = 27;
pub const std_errc_filename_too_long: std_errc = 38;
pub const std_errc_function_not_supported: std_errc = 40;
pub const std_errc_host_unreachable: std_errc = 110;
pub const std_errc_identifier_removed: std_errc = 111;
pub const std_errc_illegal_byte_sequence: std_errc = 42;
pub const std_errc_inappropriate_io_control_operation: std_errc = 25;
pub const std_errc_interrupted: std_errc = 4;
pub const std_errc_invalid_argument: std_errc = 22;
pub const std_errc_invalid_seek: std_errc = 29;
pub const std_errc_io_error: std_errc = 5;
pub const std_errc_is_a_directory: std_errc = 21;
pub const std_errc_message_size: std_errc = 115;
pub const std_errc_network_down: std_errc = 116;
pub const std_errc_network_reset: std_errc = 117;
pub const std_errc_network_unreachable: std_errc = 118;
pub const std_errc_no_buffer_space: std_errc = 119;
pub const std_errc_no_child_process: std_errc = 10;
pub const std_errc_no_link: std_errc = 121;
pub const std_errc_no_lock_available: std_errc = 39;
pub const std_errc_no_message_available: std_errc = 120;
pub const std_errc_no_message: std_errc = 122;
pub const std_errc_no_protocol_option: std_errc = 123;
pub const std_errc_no_space_on_device: std_errc = 28;
pub const std_errc_no_stream_resources: std_errc = 124;
pub const std_errc_no_such_device_or_address: std_errc = 6;
pub const std_errc_no_such_device: std_errc = 19;
pub const std_errc_no_such_file_or_directory: std_errc = 2;
pub const std_errc_no_such_process: std_errc = 3;
pub const std_errc_not_a_directory: std_errc = 20;
pub const std_errc_not_a_socket: std_errc = 128;
pub const std_errc_not_a_stream: std_errc = 125;
pub const std_errc_not_connected: std_errc = 126;
pub const std_errc_not_enough_memory: std_errc = 12;
pub const std_errc_not_supported: std_errc = 129;
pub const std_errc_operation_canceled: std_errc = 105;
pub const std_errc_operation_in_progress: std_errc = 112;
pub const std_errc_operation_not_permitted: std_errc = 1;
pub const std_errc_operation_not_supported: std_errc = 130;
pub const std_errc_operation_would_block: std_errc = 140;
pub const std_errc_owner_dead: std_errc = 133;
pub const std_errc_permission_denied: std_errc = 13;
pub const std_errc_protocol_error: std_errc = 134;
pub const std_errc_protocol_not_supported: std_errc = 135;
pub const std_errc_read_only_file_system: std_errc = 30;
pub const std_errc_resource_deadlock_would_occur: std_errc = 36;
pub const std_errc_resource_unavailable_try_again: std_errc = 11;
pub const std_errc_result_out_of_range: std_errc = 34;
pub const std_errc_state_not_recoverable: std_errc = 127;
pub const std_errc_stream_timeout: std_errc = 137;
pub const std_errc_text_file_busy: std_errc = 139;
pub const std_errc_timed_out: std_errc = 138;
pub const std_errc_too_many_files_open_in_system: std_errc = 23;
pub const std_errc_too_many_files_open: std_errc = 24;
pub const std_errc_too_many_links: std_errc = 31;
pub const std_errc_too_many_symbolic_link_levels: std_errc = 114;
pub const std_errc_value_too_large: std_errc = 132;
pub const std_errc_wrong_protocol_type: std_errc = 136;
pub type std_errc = ::std::os::raw::c_int;
pub type std_string = [u64; 4usize];
pub type std_wstring = [u64; 4usize];
pub type std_u16string = [u64; 4usize];
pub type std_u32string = [u64; 4usize];
pub type std_streamoff = u64;
pub type std_streamsize = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos {
    pub _address: u8,
}
pub type std_streampos = u8;
pub type std_wstreampos = u8;
pub type std_u16streampos = u8;
pub type std_u32streampos = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ios {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_streambuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_iostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_filebuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ifstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ofstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_fstream {
    pub _address: u8,
}
pub type std_ios = u8;
pub type std_streambuf = u8;
pub type std_istream = u8;
pub type std_ostream = u8;
pub type std_iostream = u8;
pub type std_stringbuf = u8;
pub type std_istringstream = u8;
pub type std_ostringstream = u8;
pub type std_stringstream = u8;
pub type std_filebuf = u8;
pub type std_ifstream = u8;
pub type std_ofstream = u8;
pub type std_fstream = u8;
pub type std_wios = u8;
pub type std_wstreambuf = u8;
pub type std_wistream = u8;
pub type std_wostream = u8;
pub type std_wiostream = u8;
pub type std_wstringbuf = u8;
pub type std_wistringstream = u8;
pub type std_wostringstream = u8;
pub type std_wstringstream = u8;
pub type std_wfilebuf = u8;
pub type std_wifstream = u8;
pub type std_wofstream = u8;
pub type std_wfstream = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std___allocator_base = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type = u8;
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
pub type std___c_locale = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_num_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_num_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_put_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type = u8;
pub type std_unary_function_result_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type = u8;
pub type std_binary_function_second_argument_type = u8;
pub type std_binary_function_result_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_transparent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_divides {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_modulus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_xor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_negate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_negate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_unary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Identity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select2nd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_ref_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_ref_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_ref_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_ref_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binder1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binder2nd {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _bindgen_opaque_blob: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = u8;
pub type std___allocator_traits_base___c_pointer = u8;
pub type std___allocator_traits_base___v_pointer = u8;
pub type std___allocator_traits_base___cv_pointer = u8;
pub type std___allocator_traits_base___pocca = u8;
pub type std___allocator_traits_base___pocma = u8;
pub type std___allocator_traits_base___pocs = u8;
pub type std___allocator_traits_base___equal = u8;
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type = u8;
pub type std_allocator_traits_value_type = u8;
pub type std_allocator_traits_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = u8;
pub type std_allocator_traits_void_pointer = u8;
pub type std_allocator_traits_const_void_pointer = u8;
pub type std_allocator_traits_difference_type = u8;
pub type std_allocator_traits_size_type = u8;
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
pub type std_allocator_traits_rebind_alloc = u8;
pub type std_allocator_traits_rebind_traits = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type = u8;
pub type std_allocator_traits___has_construct = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_alloc_insertable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_copy_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_allocator {
    pub _address: u8,
}
pub type std__RequireAllocator = u8;
pub type std__RequireNotAllocator = u8;
extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline(
        ___in: *mut u8,
        __str: *mut [u64; 4usize],
        __delim: ::std::os::raw::c_char,
    ) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIwSt11char_traitsIwESaIwEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline1(___in: *mut u8, __str: *mut [u64; 4usize], __delim: u16) -> *mut u8;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__List_node_base {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std___detail__List_node_base() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__List_node_base>(),
        16usize,
        concat!("Size of: ", stringify!(std___detail__List_node_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__List_node_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std___detail__List_node_base))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base4swapERS0_S1_"]
    pub fn std___detail__List_node_base_swap(
        __x: *mut std___detail__List_node_base,
        __y: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base11_M_transferEPS0_S1_"]
    pub fn std___detail__List_node_base__M_transfer(
        this: *mut std___detail__List_node_base,
        __first: *mut std___detail__List_node_base,
        __last: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base10_M_reverseEv"]
    pub fn std___detail__List_node_base__M_reverse(this: *mut std___detail__List_node_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base7_M_hookEPS0_"]
    pub fn std___detail__List_node_base__M_hook(
        this: *mut std___detail__List_node_base,
        __position: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base9_M_unhookEv"]
    pub fn std___detail__List_node_base__M_unhook(this: *mut std___detail__List_node_base);
}
impl std___detail__List_node_base {
    #[inline]
    pub unsafe fn swap(
        __x: *mut std___detail__List_node_base,
        __y: *mut std___detail__List_node_base,
    ) {
        std___detail__List_node_base_swap(__x, __y)
    }
    #[inline]
    pub unsafe fn _M_transfer(
        &mut self,
        __first: *mut std___detail__List_node_base,
        __last: *mut std___detail__List_node_base,
    ) {
        std___detail__List_node_base__M_transfer(self, __first, __last)
    }
    #[inline]
    pub unsafe fn _M_reverse(&mut self) {
        std___detail__List_node_base__M_reverse(self)
    }
    #[inline]
    pub unsafe fn _M_hook(&mut self, __position: *mut std___detail__List_node_base) {
        std___detail__List_node_base__M_hook(self, __position)
    }
    #[inline]
    pub unsafe fn _M_unhook(&mut self) {
        std___detail__List_node_base__M_unhook(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__List_node_header {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_std___detail__List_node_header() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__List_node_header>(),
        24usize,
        concat!("Size of: ", stringify!(std___detail__List_node_header))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__List_node_header>(),
        8usize,
        concat!("Alignment of ", stringify!(std___detail__List_node_header))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_base {
    pub _address: u8,
}
pub type std___hash_base_result_type = u8;
pub type std___hash_base_argument_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___poison_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std__Hash_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std__Hash_impl() {
    assert_eq!(
        ::std::mem::size_of::<std__Hash_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std__Hash_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Hash_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Hash_impl))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std__Fnv_hash_impl {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std__Fnv_hash_impl() {
    assert_eq!(
        ::std::mem::size_of::<std__Fnv_hash_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std__Fnv_hash_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Fnv_hash_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Fnv_hash_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_fast_hash {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}npos"]
    pub static std_npos: std_basic_string_size_type;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std___cow_string {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std___cow_string__bindgen_ty_1 {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std___cow_string__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<std___cow_string__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(std___cow_string__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<std___cow_string__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(std___cow_string__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_std___cow_string() {
    assert_eq!(
        ::std::mem::size_of::<std___cow_string>(),
        8usize,
        concat!("Size of: ", stringify!(std___cow_string))
    );
    assert_eq!(
        ::std::mem::align_of::<std___cow_string>(),
        8usize,
        concat!("Alignment of ", stringify!(std___cow_string))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1Ev"]
    pub fn std___cow_string___cow_string(this: *mut std___cow_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std___cow_string___cow_string1(this: *mut std___cow_string, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EPKcy"]
    pub fn std___cow_string___cow_string2(
        this: *mut std___cow_string,
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKS_"]
    pub fn std___cow_string___cow_string3(
        this: *mut std___cow_string,
        arg1: *const std___cow_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EOS_"]
    pub fn std___cow_string___cow_string4(this: *mut std___cow_string, arg1: *mut std___cow_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringD1Ev"]
    pub fn std___cow_string___cow_string_destructor(this: *mut std___cow_string);
}
impl std___cow_string {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *mut std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___cow_string___cow_string_destructor(self)
    }
}
pub type std___sso_string = [u64; 4usize];
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_logic_error {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_logic_error() {
    assert_eq!(
        ::std::mem::size_of::<std_logic_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_logic_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_logic_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_logic_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_logic_error_logic_error(this: *mut std_logic_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EPKc"]
    pub fn std_logic_error_logic_error1(
        this: *mut std_logic_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EOS_"]
    pub fn std_logic_error_logic_error2(this: *mut std_logic_error, arg1: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKS_"]
    pub fn std_logic_error_logic_error3(this: *mut std_logic_error, arg1: *const std_logic_error);
}
impl std_logic_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorD1Ev"]
    pub fn std_logic_error_logic_error_destructor(this: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt11logic_error4whatEv"]
    pub fn std_logic_error_what(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_domain_error {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_domain_error() {
    assert_eq!(
        ::std::mem::size_of::<std_domain_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_domain_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_domain_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_domain_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_domain_error_domain_error(this: *mut std_domain_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1EPKc"]
    pub fn std_domain_error_domain_error1(
        this: *mut std_domain_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_domain_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorD1Ev"]
    pub fn std_domain_error_domain_error_destructor(this: *mut std_domain_error);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_invalid_argument {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_invalid_argument() {
    assert_eq!(
        ::std::mem::size_of::<std_invalid_argument>(),
        16usize,
        concat!("Size of: ", stringify!(std_invalid_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<std_invalid_argument>(),
        8usize,
        concat!("Alignment of ", stringify!(std_invalid_argument))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_invalid_argument_invalid_argument(
        this: *mut std_invalid_argument,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1EPKc"]
    pub fn std_invalid_argument_invalid_argument1(
        this: *mut std_invalid_argument,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_invalid_argument {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentD1Ev"]
    pub fn std_invalid_argument_invalid_argument_destructor(this: *mut std_invalid_argument);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_length_error {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_length_error() {
    assert_eq!(
        ::std::mem::size_of::<std_length_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_length_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_length_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_length_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_length_error_length_error(this: *mut std_length_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1EPKc"]
    pub fn std_length_error_length_error1(
        this: *mut std_length_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_length_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorD1Ev"]
    pub fn std_length_error_length_error_destructor(this: *mut std_length_error);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_out_of_range {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_out_of_range() {
    assert_eq!(
        ::std::mem::size_of::<std_out_of_range>(),
        16usize,
        concat!("Size of: ", stringify!(std_out_of_range))
    );
    assert_eq!(
        ::std::mem::align_of::<std_out_of_range>(),
        8usize,
        concat!("Alignment of ", stringify!(std_out_of_range))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_out_of_range_out_of_range(this: *mut std_out_of_range, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1EPKc"]
    pub fn std_out_of_range_out_of_range1(
        this: *mut std_out_of_range,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_out_of_range {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeD1Ev"]
    pub fn std_out_of_range_out_of_range_destructor(this: *mut std_out_of_range);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_runtime_error {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_runtime_error() {
    assert_eq!(
        ::std::mem::size_of::<std_runtime_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_runtime_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_runtime_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_runtime_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_runtime_error_runtime_error(this: *mut std_runtime_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EPKc"]
    pub fn std_runtime_error_runtime_error1(
        this: *mut std_runtime_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EOS_"]
    pub fn std_runtime_error_runtime_error2(
        this: *mut std_runtime_error,
        arg1: *mut std_runtime_error,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKS_"]
    pub fn std_runtime_error_runtime_error3(
        this: *mut std_runtime_error,
        arg1: *const std_runtime_error,
    );
}
impl std_runtime_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorD1Ev"]
    pub fn std_runtime_error_runtime_error_destructor(this: *mut std_runtime_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt13runtime_error4whatEv"]
    pub fn std_runtime_error_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_range_error {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_range_error() {
    assert_eq!(
        ::std::mem::size_of::<std_range_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_range_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_range_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_range_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_range_error_range_error(this: *mut std_range_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1EPKc"]
    pub fn std_range_error_range_error1(
        this: *mut std_range_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_range_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorD1Ev"]
    pub fn std_range_error_range_error_destructor(this: *mut std_range_error);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_overflow_error {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_overflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_overflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_overflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_overflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_overflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_overflow_error_overflow_error(
        this: *mut std_overflow_error,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1EPKc"]
    pub fn std_overflow_error_overflow_error1(
        this: *mut std_overflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_overflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorD1Ev"]
    pub fn std_overflow_error_overflow_error_destructor(this: *mut std_overflow_error);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_underflow_error {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_underflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_underflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_underflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_underflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_underflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_underflow_error_underflow_error(
        this: *mut std_underflow_error,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1EPKc"]
    pub fn std_underflow_error_underflow_error1(
        this: *mut std_underflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_underflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorD1Ev"]
    pub fn std_underflow_error_underflow_error_destructor(this: *mut std_underflow_error);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_code_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_condition_enum {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_error_category {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_error_category() {
    assert_eq!(
        ::std::mem::size_of::<std_error_category>(),
        8usize,
        concat!("Size of: ", stringify!(std_error_category))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_category>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_category))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V214error_categoryD1Ev"]
    pub fn std_error_category_error_category_destructor(this: *mut std_error_category);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category23default_error_conditionEi"]
    pub fn std_error_category_default_error_condition(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
    ) -> std_error_condition;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentEiRKSt15error_condition"]
    pub fn std_error_category_equivalent(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
        __cond: *const std_error_condition,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentERKSt10error_codei"]
    pub fn std_error_category_equivalent1(
        this: *mut ::std::os::raw::c_void,
        __code: *const std_error_code,
        __i: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V216generic_categoryEv"]
    pub fn std_generic_category() -> *const std_error_category;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V215system_categoryEv"]
    pub fn std_system_category() -> *const std_error_category;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_error_code {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_error_code() {
    assert_eq!(
        ::std::mem::size_of::<std_error_code>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_code))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_code>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_code))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt10error_code23default_error_conditionEv"]
    pub fn std_error_code_default_error_condition(
        this: *const std_error_code,
    ) -> std_error_condition;
}
impl std_error_code {
    #[inline]
    pub unsafe fn default_error_condition(&self) -> std_error_condition {
        std_error_code_default_error_condition(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_error_condition {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std_error_condition() {
    assert_eq!(
        ::std::mem::size_of::<std_error_condition>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_condition))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_condition>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_condition))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_system_error {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_std_system_error() {
    assert_eq!(
        ::std::mem::size_of::<std_system_error>(),
        32usize,
        concat!("Size of: ", stringify!(std_system_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_system_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_system_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12system_errorD1Ev"]
    pub fn std_system_error_system_error_destructor(this: *mut std_system_error);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std___mutex_base {
    pub _bindgen_opaque_blob: u64,
}
pub type std___mutex_base___native_type = u64;
#[test]
fn bindgen_test_layout_std___mutex_base() {
    assert_eq!(
        ::std::mem::size_of::<std___mutex_base>(),
        8usize,
        concat!("Size of: ", stringify!(std___mutex_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___mutex_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std___mutex_base))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_mutex {
    pub _bindgen_opaque_blob: u64,
}
pub type std_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_mutex>(),
        8usize,
        concat!("Size of: ", stringify!(std_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_mutex))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_defer_lock_t {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_defer_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<std_defer_lock_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_defer_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_defer_lock_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_defer_lock_t))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_try_to_lock_t {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_try_to_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<std_try_to_lock_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_try_to_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_try_to_lock_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_try_to_lock_t))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_adopt_lock_t {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_adopt_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<std_adopt_lock_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_adopt_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_adopt_lock_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_adopt_lock_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZStL10defer_lock"]
    pub static std_defer_lock: std_defer_lock_t;
}
extern "C" {
    #[link_name = "\u{1}_ZStL11try_to_lock"]
    pub static std_try_to_lock: std_try_to_lock_t;
}
extern "C" {
    #[link_name = "\u{1}_ZStL10adopt_lock"]
    pub static std_adopt_lock: std_adopt_lock_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_lock_guard {
    pub _address: u8,
}
pub type std_lock_guard_mutex_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_lock {
    pub _address: u8,
}
pub type std_unique_lock_mutex_type = u8;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std___recursive_mutex_base {
    pub _bindgen_opaque_blob: u64,
}
pub type std___recursive_mutex_base___native_type = u64;
#[test]
fn bindgen_test_layout_std___recursive_mutex_base() {
    assert_eq!(
        ::std::mem::size_of::<std___recursive_mutex_base>(),
        8usize,
        concat!("Size of: ", stringify!(std___recursive_mutex_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___recursive_mutex_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std___recursive_mutex_base))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_recursive_mutex {
    pub _bindgen_opaque_blob: u64,
}
pub type std_recursive_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_recursive_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_recursive_mutex>(),
        8usize,
        concat!("Size of: ", stringify!(std_recursive_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_recursive_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_recursive_mutex))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___timed_mutex_impl {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_timed_mutex {
    pub _bindgen_opaque_blob: u64,
}
pub type std_timed_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_timed_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_timed_mutex>(),
        8usize,
        concat!("Size of: ", stringify!(std_timed_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_timed_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_timed_mutex))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_recursive_timed_mutex {
    pub _bindgen_opaque_blob: u64,
}
pub type std_recursive_timed_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_recursive_timed_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_recursive_timed_mutex>(),
        8usize,
        concat!("Size of: ", stringify!(std_recursive_timed_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_recursive_timed_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_recursive_timed_mutex))
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_once_flag {
    pub _bindgen_opaque_blob: u32,
}
pub type std_once_flag___native_type = u32;
#[test]
fn bindgen_test_layout_std_once_flag() {
    assert_eq!(
        ::std::mem::size_of::<std_once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(std_once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(std_once_flag))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt15__once_callable"]
    pub static mut std___once_callable: *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZSt11__once_call"]
    pub static mut std___once_call: ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "\u{1}__once_proxy"]
    pub fn std___once_proxy();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_bitwise_relocatable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vector_base {
    pub _address: u8,
}
pub type std__Vector_base__Tp_alloc_type = u8;
pub type std__Vector_base_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vector_base__Vector_impl_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vector_base__Vector_impl {
    pub _address: u8,
}
pub type std__Vector_base_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
pub type std__Bit_type = u32;
pub const _S_word_bit: std__bindgen_ty_1 = 32;
pub type std__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_reference {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std__Bit_reference() {
    assert_eq!(
        ::std::mem::size_of::<std__Bit_reference>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_reference))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_reference>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_reference))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator_base {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_std__Bit_iterator_base() {
    assert_eq!(
        ::std::mem::size_of::<std__Bit_iterator_base>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_iterator_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_iterator_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_iterator_base))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type std__Bit_iterator_reference = [u64; 2usize];
pub type std__Bit_iterator_pointer = u64;
#[test]
fn bindgen_test_layout_std__Bit_iterator() {
    assert_eq!(
        ::std::mem::size_of::<std__Bit_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_iterator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_const_iterator {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type std__Bit_const_iterator_reference = u8;
pub type std__Bit_const_iterator_const_reference = u8;
pub type std__Bit_const_iterator_pointer = u64;
#[test]
fn bindgen_test_layout_std__Bit_const_iterator() {
    assert_eq!(
        ::std::mem::size_of::<std__Bit_const_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_const_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_const_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_const_iterator))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bvector_base {
    pub _address: u8,
}
pub type std__Bvector_base__Bit_alloc_type = u8;
pub type std__Bvector_base__Bit_alloc_traits = u8;
pub type std__Bvector_base__Bit_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bvector_base__Bvector_impl_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bvector_base__Bvector_impl {
    pub _address: u8,
}
pub type std__Bvector_base_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocated_ptr {
    pub _address: u8,
}
pub type std___allocated_ptr_pointer = u8;
pub type std___allocated_ptr_value_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_node {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_iterator {
    pub _address: u8,
}
pub type std__List_iterator__Self = u8;
pub type std__List_iterator__Node = u8;
pub type std__List_iterator_difference_type = u64;
pub type std__List_iterator_iterator_category = u8;
pub type std__List_iterator_value_type = u8;
pub type std__List_iterator_pointer = u8;
pub type std__List_iterator_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_const_iterator {
    pub _address: u8,
}
pub type std__List_const_iterator__Self = u8;
pub type std__List_const_iterator__Node = u8;
pub type std__List_const_iterator_iterator = u8;
pub type std__List_const_iterator_difference_type = u64;
pub type std__List_const_iterator_iterator_category = u8;
pub type std__List_const_iterator_value_type = u8;
pub type std__List_const_iterator_pointer = u8;
pub type std__List_const_iterator_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Temporary_buffer {
    pub _address: u8,
}
pub type std__Temporary_buffer_value_type = u8;
pub type std__Temporary_buffer_pointer = u8;
pub type std__Temporary_buffer_iterator = u8;
pub type std__Temporary_buffer_size_type = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_raw_storage_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl__Ptr {
    pub _address: u8,
}
pub type std___uniq_ptr_impl__Ptr_type = u8;
pub type std___uniq_ptr_impl__DeleterConstraint = u8;
pub type std___uniq_ptr_impl_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__MakeUniq {
    pub _address: u8,
}
pub type std__MakeUniq___single_object = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_unary_or_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits_base {
    pub _address: u8,
}
pub type std__Mem_fn_traits_base___result_type = u8;
pub type std__Mem_fn_traits_base___maybe_type = u8;
pub type std__Mem_fn_traits_base___arity = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_get_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Reference_wrapper_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper {
    pub _address: u8,
}
pub type std_reference_wrapper___not_same = u8;
pub type std_reference_wrapper_type = u8;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_weak_ptr {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_bad_weak_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_weak_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_weak_ptr))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt12bad_weak_ptr4whatEv"]
    pub fn std_bad_weak_ptr_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12bad_weak_ptrD1Ev"]
    pub fn std_bad_weak_ptr_bad_weak_ptr_destructor(this: *mut std_bad_weak_ptr);
}
pub const std__Mutex_base__S_need_barriers: std__Mutex_base__bindgen_ty_1 = 0;
pub type std__Mutex_base__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}_M_add_ref_lock"]
    pub fn std__Sp_counted_base__M_add_ref_lock(this: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}_M_add_ref_lock_nothrow"]
    pub fn std__Sp_counted_base__M_add_ref_lock_nothrow(this: *mut u8) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_owner_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_counted_deleter__Impl {
    pub _address: u8,
}
pub type std__Sp_counted_deleter__Impl__Del_base = u8;
pub type std__Sp_counted_deleter__Impl__Alloc_base = u8;
pub type std__Sp_counted_deleter___allocator_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_make_shared_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std__Sp_make_shared_tag() {
    assert_eq!(
        ::std::mem::size_of::<std__Sp_make_shared_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std__Sp_make_shared_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_make_shared_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Sp_make_shared_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_alloc_shared_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_counted_ptr_inplace__Impl {
    pub _address: u8,
}
pub type std__Sp_counted_ptr_inplace__Impl__A_base = u8;
pub type std__Sp_counted_ptr_inplace___allocator_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_array_delete {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___sp_array_delete() {
    assert_eq!(
        ::std::mem::size_of::<std___sp_array_delete>(),
        1usize,
        concat!("Size of: ", stringify!(std___sp_array_delete))
    );
    assert_eq!(
        ::std::mem::align_of::<std___sp_array_delete>(),
        1usize,
        concat!("Alignment of ", stringify!(std___sp_array_delete))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_count___not_alloc_shared_tag {
    pub _address: u8,
}
pub type std___shared_count___not_alloc_shared_tag_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_compatible_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_is_constructible_arr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_is_constructible {
    pub _address: u8,
}
pub type std___shared_ptr_access_element_type = u8;
pub type std___shared_ptr_element_type = u8;
pub type std___shared_ptr__SafeConv = u8;
pub type std___shared_ptr__Compatible = u8;
pub type std___shared_ptr__Assignable = u8;
pub type std___shared_ptr__UniqCompatible = u8;
pub type std___shared_ptr__UniqAssignable = u8;
pub type std___shared_ptr___esft_base_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr___has_esft_base {
    pub _address: u8,
}
pub type std___weak_ptr__Compatible = u8;
pub type std___weak_ptr__Assignable = u8;
pub type std___weak_ptr_element_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_owner_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_weak_ptr {
    pub _address: u8,
}
pub type std_weak_ptr__Constructible = u8;
pub type std_weak_ptr__Assignable = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_enable_shared_from_this {
    pub _address: u8,
}
pub const std_memory_order_memory_order_relaxed: std_memory_order = 0;
pub const std_memory_order_memory_order_consume: std_memory_order = 1;
pub const std_memory_order_memory_order_acquire: std_memory_order = 2;
pub const std_memory_order_memory_order_release: std_memory_order = 3;
pub const std_memory_order_memory_order_acq_rel: std_memory_order = 4;
pub const std_memory_order_memory_order_seq_cst: std_memory_order = 5;
pub type std_memory_order = ::std::os::raw::c_uint;
pub const std___memory_order_modifier___memory_order_mask: std___memory_order_modifier = 65535;
pub const std___memory_order_modifier___memory_order_modifier_mask: std___memory_order_modifier =
    4294901760;
pub const std___memory_order_modifier___memory_order_hle_acquire: std___memory_order_modifier =
    65536;
pub const std___memory_order_modifier___memory_order_hle_release: std___memory_order_modifier =
    131072;
pub type std___memory_order_modifier = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std___atomic_flag_data_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std___atomic_flag_base {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std___atomic_flag_base() {
    assert_eq!(
        ::std::mem::size_of::<std___atomic_flag_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___atomic_flag_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___atomic_flag_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___atomic_flag_base))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic_flag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_atomic_flag() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic_flag>(),
        1usize,
        concat!("Size of: ", stringify!(std_atomic_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_atomic_flag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___atomic_base {
    pub _address: u8,
}
pub type std___atomic_base_value_type = u8;
pub type std___atomic_base_difference_type = u8;
pub type std___atomic_base___int_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_locker {
    pub _bindgen_opaque_blob: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_std__Sp_locker() {
    assert_eq!(
        ::std::mem::size_of::<std__Sp_locker>(),
        2usize,
        concat!("Size of: ", stringify!(std__Sp_locker))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_locker>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Sp_locker))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKv"]
    pub fn std__Sp_locker__Sp_locker(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKvS1_"]
    pub fn std__Sp_locker__Sp_locker1(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerD1Ev"]
    pub fn std__Sp_locker__Sp_locker_destructor(this: *mut std__Sp_locker);
}
impl std__Sp_locker {
    #[inline]
    pub unsafe fn new(arg1: *const ::std::os::raw::c_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std__Sp_locker__Sp_locker_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr_ref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr {
    pub _address: u8,
}
pub type std_auto_ptr_element_type = u8;
pub const std_pointer_safety_relaxed: std_pointer_safety = 0;
pub const std_pointer_safety_preferred: std_pointer_safety = 1;
pub const std_pointer_safety_strict: std_pointer_safety = 2;
pub type std_pointer_safety = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_thread {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__State {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_thread__State() {
    assert_eq!(
        ::std::mem::size_of::<std_thread__State>(),
        8usize,
        concat!("Size of: ", stringify!(std_thread__State))
    );
    assert_eq!(
        ::std::mem::align_of::<std_thread__State>(),
        8usize,
        concat!("Alignment of ", stringify!(std_thread__State))
    );
}
pub type std_thread__State_ptr = u64;
pub type std_thread_native_handle_type = u64;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_thread_id {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_thread_id() {
    assert_eq!(
        ::std::mem::size_of::<std_thread_id>(),
        8usize,
        concat!("Size of: ", stringify!(std_thread_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std_thread_id>(),
        8usize,
        concat!("Alignment of ", stringify!(std_thread_id))
    );
}
pub type std_thread___not_same = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__State_impl {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__Invoker {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__Invoker___result {
    pub _address: u8,
}
pub type std_thread___decayed_tuple = u8;
#[test]
fn bindgen_test_layout_std_thread() {
    assert_eq!(
        ::std::mem::size_of::<std_thread>(),
        8usize,
        concat!("Size of: ", stringify!(std_thread))
    );
    assert_eq!(
        ::std::mem::align_of::<std_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(std_thread))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6thread4joinEv"]
    pub fn std_thread_join(this: *mut std_thread);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6thread6detachEv"]
    pub fn std_thread_detach(this: *mut std_thread);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6thread20hardware_concurrencyEv"]
    pub fn std_thread_hardware_concurrency() -> ::std::os::raw::c_uint;
}
impl std_thread {
    #[inline]
    pub unsafe fn join(&mut self) {
        std_thread_join(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) {
        std_thread_detach(self)
    }
    #[inline]
    pub unsafe fn hardware_concurrency() -> ::std::os::raw::c_uint {
        std_thread_hardware_concurrency()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6thread6_StateD1Ev"]
    pub fn std_thread__State__State_destructor(this: *mut std_thread__State);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11this_thread11__sleep_forENSt6chrono8durationIxSt5ratioILx1ELx1EEEENS1_IxS2_ILx1ELx1000000000EEEE"]
    pub fn std_this_thread___sleep_for(arg1: std_chrono_seconds, arg2: std_chrono_nanoseconds);
}
pub type __gnu_cxx___conditional_type___type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___add_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___add_unsigned___if_type = u8;
pub type __gnu_cxx___add_unsigned___type = __gnu_cxx___add_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___remove_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___remove_unsigned___if_type = u8;
pub type __gnu_cxx___remove_unsigned___type = __gnu_cxx___remove_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_long_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
pub type __gnu_cxx___promote___type = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_2 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_2___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_3 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_3___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_4 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_4___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___is_integer_nonstrict {
    pub _address: u8,
}
pub const __gnu_cxx___is_integer_nonstrict___width: __gnu_cxx___is_integer_nonstrict__bindgen_ty_1 =
    0;
pub type __gnu_cxx___is_integer_nonstrict__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_integer {
    pub _address: u8,
}
// extern "C" {
//     #[link_name = "\u{1}__min"]
//     pub static __gnu_cxx___min: _Value;
// }
// extern "C" {
//     #[link_name = "\u{1}__max"]
//     pub static __gnu_cxx___max: _Value;
// }
extern "C" {
    #[link_name = "\u{1}__is_signed"]
    pub static __gnu_cxx___is_signed: bool;
}
extern "C" {
    #[link_name = "\u{1}__digits"]
    pub static __gnu_cxx___digits: ::std::os::raw::c_int;
}
#[test]
fn __bindgen_test_layout___gnu_cxx___is_integer_nonstrict_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___is_integer_nonstrict>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___is_integer_nonstrict)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___is_integer_nonstrict>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___is_integer_nonstrict)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___is_integer_nonstrict_open0_unsigned___int128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___is_integer_nonstrict>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___is_integer_nonstrict)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___is_integer_nonstrict>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___is_integer_nonstrict)
        )
    );
}
pub type __gnu_cxx___int_traits = __gnu_cxx___numeric_traits_integer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_floating {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}__max_digits10"]
    pub static __gnu_cxx___max_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__digits10"]
    pub static __gnu_cxx___digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__max_exponent10"]
    pub static __gnu_cxx___max_exponent10: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = u8;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_less_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_less_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_less_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_less_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_less_iter>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Iter_less_iter))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_less_val {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_less_val() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_less_val>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_less_val))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_less_val>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Iter_less_val))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_less_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Val_less_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Val_less_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Val_less_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Val_less_iter>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Val_less_iter))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equal_to_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_equal_to_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_equal_to_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_iter>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___ops__Iter_equal_to_iter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equal_to_val {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_equal_to_val() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_val>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_equal_to_val))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_val>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___ops__Iter_equal_to_val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_iter<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_val<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_comp_iter<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_val<_Value> {
    pub _M_value: *mut _Value,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_iter<_Iterator1> {
    pub _M_it1: _Iterator1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_pred<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_val<_Compare, _Value> {
    pub _M_comp: _Compare,
    pub _M_value: *mut _Value,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_iter<_Compare, _Iterator1> {
    pub _M_comp: _Compare,
    pub _M_it1: _Iterator1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_negate<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxx27__verbose_terminate_handlerEv"]
    pub fn __gnu_cxx___verbose_terminate_handler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
pub type __gnu_cxx_new_allocator_size_type = usize;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = u8;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf {
    pub _M_storage: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf__Tp2<_Tp> {
    pub _M_t: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_buffer {
    pub _M_storage: u8,
}
pub const __gnu_cxx__Lock_policy__S_single: __gnu_cxx__Lock_policy = 0;
pub const __gnu_cxx__Lock_policy__S_mutex: __gnu_cxx__Lock_policy = 1;
pub const __gnu_cxx__Lock_policy__S_atomic: __gnu_cxx__Lock_policy = 2;
pub type __gnu_cxx__Lock_policy = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxxL21__default_lock_policyE"]
    pub static __gnu_cxx___default_lock_policy: __gnu_cxx__Lock_policy;
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_lock_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_lock_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_lock_error>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___concurrence_lock_error))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_lock_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_lock_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_unlock_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_unlock_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_unlock_error>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__gnu_cxx___concurrence_unlock_error)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_unlock_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_unlock_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_broadcast_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_broadcast_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_broadcast_error>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__gnu_cxx___concurrence_broadcast_error)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_broadcast_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_broadcast_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_wait_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_wait_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_wait_error>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___concurrence_wait_error))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_wait_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_wait_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___mutex {
    pub _M_mutex: __gthread_mutex_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___mutex() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___mutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___mutex>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___mutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___mutex),
            "::",
            stringify!(_M_mutex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___recursive_mutex {
    pub _M_mutex: __gthread_recursive_mutex_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___recursive_mutex() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___recursive_mutex> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___recursive_mutex>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___recursive_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___recursive_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___recursive_mutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___recursive_mutex),
            "::",
            stringify!(_M_mutex)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___scoped_lock {
    pub _M_device: *mut __gnu_cxx___scoped_lock___mutex_type,
}
pub type __gnu_cxx___scoped_lock___mutex_type = __gnu_cxx___mutex;
#[test]
fn bindgen_test_layout___gnu_cxx___scoped_lock() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___scoped_lock> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___scoped_lock>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___scoped_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___scoped_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___scoped_lock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___scoped_lock),
            "::",
            stringify!(_M_device)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___cond {
    pub _M_cond: __gthread_cond_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___cond() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___cond> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___cond>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___cond))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___cond>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___cond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_cond) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___cond),
            "::",
            stringify!(_M_cond)
        )
    );
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
extern "C" {
    pub fn __mingw_get_crt_info() -> *const ::std::os::raw::c_char;
}
pub type rsize_t = usize;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type errno_t = ::std::os::raw::c_int;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadmbcinfostruct {
    _unused: [u8; 0],
}
pub type pthreadlocinfo = *mut threadlocaleinfostruct;
pub type pthreadmbcinfo = *mut threadmbcinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lc_time_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct localeinfo_struct {
    pub locinfo: pthreadlocinfo,
    pub mbcinfo: pthreadmbcinfo,
}
#[test]
fn bindgen_test_layout_localeinfo_struct() {
    const UNINIT: ::std::mem::MaybeUninit<localeinfo_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<localeinfo_struct>(),
        16usize,
        concat!("Size of: ", stringify!(localeinfo_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<localeinfo_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(localeinfo_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(localeinfo_struct),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(localeinfo_struct),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_tstruct = localeinfo_struct;
pub type _locale_t = *mut localeinfo_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLC_ID {
    pub wLanguage: ::std::os::raw::c_ushort,
    pub wCountry: ::std::os::raw::c_ushort,
    pub wCodePage: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_tagLC_ID() {
    const UNINIT: ::std::mem::MaybeUninit<tagLC_ID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagLC_ID>(),
        6usize,
        concat!("Size of: ", stringify!(tagLC_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<tagLC_ID>(),
        2usize,
        concat!("Alignment of ", stringify!(tagLC_ID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wLanguage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wLanguage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wCountry) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wCountry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wCodePage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wCodePage)
        )
    );
}
pub type LC_ID = tagLC_ID;
pub type LPLC_ID = *mut tagLC_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct {
    pub refcount: ::std::os::raw::c_int,
    pub lc_codepage: ::std::os::raw::c_uint,
    pub lc_collate_cp: ::std::os::raw::c_uint,
    pub lc_handle: [::std::os::raw::c_ulong; 6usize],
    pub lc_id: [LC_ID; 6usize],
    pub lc_category: [threadlocaleinfostruct__bindgen_ty_1; 6usize],
    pub lc_clike: ::std::os::raw::c_int,
    pub mb_cur_max: ::std::os::raw::c_int,
    pub lconv_intl_refcount: *mut ::std::os::raw::c_int,
    pub lconv_num_refcount: *mut ::std::os::raw::c_int,
    pub lconv_mon_refcount: *mut ::std::os::raw::c_int,
    pub lconv: *mut lconv,
    pub ctype1_refcount: *mut ::std::os::raw::c_int,
    pub ctype1: *mut ::std::os::raw::c_ushort,
    pub pctype: *const ::std::os::raw::c_ushort,
    pub pclmap: *const ::std::os::raw::c_uchar,
    pub pcumap: *const ::std::os::raw::c_uchar,
    pub lc_time_curr: *mut __lc_time_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct__bindgen_ty_1 {
    pub locale: *mut ::std::os::raw::c_char,
    pub wlocale: *mut u16,
    pub refcount: *mut ::std::os::raw::c_int,
    pub wrefcount: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<threadlocaleinfostruct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<threadlocaleinfostruct__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<threadlocaleinfostruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(locale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlocale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(wlocale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrefcount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(wrefcount)
        )
    );
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct() {
    const UNINIT: ::std::mem::MaybeUninit<threadlocaleinfostruct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<threadlocaleinfostruct>(),
        352usize,
        concat!("Size of: ", stringify!(threadlocaleinfostruct))
    );
    assert_eq!(
        ::std::mem::align_of::<threadlocaleinfostruct>(),
        8usize,
        concat!("Alignment of ", stringify!(threadlocaleinfostruct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_codepage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_codepage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_collate_cp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_collate_cp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_handle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_id) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_category) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_clike) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_clike)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_cur_max) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lconv_intl_refcount) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_intl_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lconv_num_refcount) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_num_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lconv_mon_refcount) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_mon_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lconv) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype1_refcount) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(ctype1_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype1) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(ctype1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pctype) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pclmap) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pclmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcumap) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pcumap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_time_curr) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_time_curr)
        )
    );
}
pub type threadlocinfo = threadlocaleinfostruct;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type int_least32_t = ::std::os::raw::c_int;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_debug__Safe_iterator {
    pub _address: u8,
}
#[doc = " @class NAME\n\n @brief A class that represents an ISO11783 control function NAME from an address claim."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_NAME {
    #[doc = "< A raw, 64 bit NAME encoded with all NAMEParameters"]
    pub rawName: u64,
}
#[doc = "< Usually the serial number of the ECU, unique for all similar control functions"]
pub const isobus_NAME_NAMEParameters_IdentityNumber: isobus_NAME_NAMEParameters = 0;
#[doc = "< The J1939/ISO11783 manufacturer code of the ECU with this NAME"]
pub const isobus_NAME_NAMEParameters_ManufacturerCode: isobus_NAME_NAMEParameters = 1;
#[doc = "< The ECU instance of the ECU with this NAME. Usually increments in NAME order with similar CFs"]
pub const isobus_NAME_NAMEParameters_EcuInstance: isobus_NAME_NAMEParameters = 2;
#[doc = "< The function instance of the ECU. Similar to Virtual Terminal number."]
pub const isobus_NAME_NAMEParameters_FunctionInstance: isobus_NAME_NAMEParameters = 3;
#[doc = "< The function of the ECU, as defined by ISO11783"]
pub const isobus_NAME_NAMEParameters_FunctionCode: isobus_NAME_NAMEParameters = 4;
#[doc = "< Also known as the vehicle system from J1939, describes general ECU type"]
pub const isobus_NAME_NAMEParameters_DeviceClass: isobus_NAME_NAMEParameters = 5;
#[doc = "< The instance number of this device class"]
pub const isobus_NAME_NAMEParameters_DeviceClassInstance: isobus_NAME_NAMEParameters = 6;
#[doc = "< The industry group associated with this ECU, such as \"agricultural\""]
pub const isobus_NAME_NAMEParameters_IndustryGroup: isobus_NAME_NAMEParameters = 7;
#[doc = "< Defines if this ECU supports address arbitration"]
pub const isobus_NAME_NAMEParameters_ArbitraryAddressCapable: isobus_NAME_NAMEParameters = 8;
#[doc = " @brief The encoded components that comprise a NAME"]
pub type isobus_NAME_NAMEParameters = ::std::os::raw::c_int;
#[doc = "< The typical mechanical power source of the machine"]
pub const isobus_NAME_Function_Engine: isobus_NAME_Function = 0;
#[doc = "< Power source for operating systems without the use of the prime drive engine"]
pub const isobus_NAME_Function_AuxiliaryPowerUnit: isobus_NAME_Function = 1;
#[doc = "< Control system which operates the drive mechanism when it is electrically powered"]
pub const isobus_NAME_Function_ElectricPropulsionControl: isobus_NAME_Function = 2;
#[doc = "< Mechanical system for altering the speed vs. torque output of the engine"]
pub const isobus_NAME_Function_Transmission: isobus_NAME_Function = 3;
#[doc = "< Monitors the condition of a battery pack"]
pub const isobus_NAME_Function_BatteryPackMonitor: isobus_NAME_Function = 4;
#[doc = "< Control Unit that determines and transmits onto the network the gear desired by the operator"]
pub const isobus_NAME_Function_ShiftControl: isobus_NAME_Function = 5;
#[doc = "< System that controls the mechanical power derived from a prime engine and used to operate auxiliary items"]
pub const isobus_NAME_Function_PowerTakeOffRearOrPrimary: isobus_NAME_Function = 6;
#[doc = "< Adjusts attack angle of steering axle"]
pub const isobus_NAME_Function_SteeringAxle: isobus_NAME_Function = 7;
#[doc = "< Adjusts attack angle of driving axle"]
pub const isobus_NAME_Function_DrivingAxle: isobus_NAME_Function = 8;
#[doc = "< Controls service braking system electronically"]
pub const isobus_NAME_Function_SystemControlBrakes: isobus_NAME_Function = 9;
#[doc = "< Control for actuating the service brakes on a steered axle"]
pub const isobus_NAME_Function_SteerAxleControlBrakes: isobus_NAME_Function = 10;
#[doc = "< Control for actuating the service brakes on a drive axle"]
pub const isobus_NAME_Function_DriveAxleControlBrakes: isobus_NAME_Function = 11;
#[doc = "< Controller for the retarder capabilities of the engine"]
pub const isobus_NAME_Function_EnginerRetarder: isobus_NAME_Function = 12;
#[doc = "< Controller for the retarder capabilities of the driveline"]
pub const isobus_NAME_Function_DrivelineRetarder: isobus_NAME_Function = 13;
#[doc = "< Control system for maintaining the vehicle's speed at a fixed operator selectable value"]
pub const isobus_NAME_Function_CruiseControl: isobus_NAME_Function = 14;
#[doc = "< Controls fuel flow from the tank to the filter to the water removal/separator to the engine and then back to the tank"]
pub const isobus_NAME_Function_FuelSystem: isobus_NAME_Function = 15;
#[doc = "< Controls steering in steer-by-wire"]
pub const isobus_NAME_Function_SteeringControl: isobus_NAME_Function = 16;
#[doc = "< Control system for the suspension of a steered axle"]
pub const isobus_NAME_Function_SteerAxleSuspensionControl: isobus_NAME_Function = 17;
#[doc = "< Control system for the suspension of a driven axle"]
pub const isobus_NAME_Function_DriveAxleSuspensionControl: isobus_NAME_Function = 18;
#[doc = "< Gauge display for a vehicle, usually in the cab"]
pub const isobus_NAME_Function_InstrumentCluster: isobus_NAME_Function = 19;
#[doc = "< System for accumulating data versus travel of the vehicle"]
pub const isobus_NAME_Function_TripRecorder: isobus_NAME_Function = 20;
#[doc = "< System for controlling the climate within the cab of the vehicle"]
pub const isobus_NAME_Function_CabClimateControl: isobus_NAME_Function = 21;
#[doc = "< Modifies drag by altering body panels"]
pub const isobus_NAME_Function_AerodynamicControl: isobus_NAME_Function = 22;
#[doc = "< System associated with the vehicles physical location"]
pub const isobus_NAME_Function_VehicleNavigation: isobus_NAME_Function = 23;
#[doc = "< System for comparing operator-provided data sequences against reference"]
pub const isobus_NAME_Function_VehicleSecurity: isobus_NAME_Function = 24;
#[doc = "< ECU for connecting different network segments together"]
pub const isobus_NAME_Function_NetworkInterconnectUnit: isobus_NAME_Function = 25;
#[doc = "< Can handle suspension control for the body sections independent from the axle sections"]
pub const isobus_NAME_Function_BodyControl: isobus_NAME_Function = 26;
#[doc = "< System that controls the mechanical power derived from a prime engine and used to operate auxiliary items"]
pub const isobus_NAME_Function_PowerTakeOffFrontOrSecondary: isobus_NAME_Function = 27;
#[doc = "< ECU for connecting between vehicle network(s) and an off-vehicle system or network"]
pub const isobus_NAME_Function_OffVehicleGateway: isobus_NAME_Function = 28;
#[doc = "< General-purpose intelligent display with a specific message set defined in ISO 11783-6"]
pub const isobus_NAME_Function_VirtualTerminal: isobus_NAME_Function = 29;
#[doc = "< Manages vehicle systems, i.e. powertrain"]
pub const isobus_NAME_Function_ManagementComputerOne: isobus_NAME_Function = 30;
#[doc = "< Unit used to charge propulsion batteries in an electric vehicle"]
pub const isobus_NAME_Function_PropulsionBatteryCharger: isobus_NAME_Function = 31;
#[doc = "< Forward-looking collision avoidance, collision warning, speed controller, or speed control"]
pub const isobus_NAME_Function_HeadwayControl: isobus_NAME_Function = 32;
#[doc = "< Generic system monitor"]
pub const isobus_NAME_Function_SystemMonitor: isobus_NAME_Function = 33;
#[doc = "< Pump controller that provides hydraulic power"]
pub const isobus_NAME_Function_HydraulicPumpControl: isobus_NAME_Function = 34;
#[doc = "< Controller responsible for coordinating the over-all suspension of a vehicle"]
pub const isobus_NAME_Function_SystemControlSuspension: isobus_NAME_Function = 35;
#[doc = "< Controller responsible for coordinating the pneumatics of a vehicle"]
pub const isobus_NAME_Function_SystemControlPneumatic: isobus_NAME_Function = 36;
#[doc = "< Controller located in/near vehicle cab used to perform functions that are grouped together for convenience"]
pub const isobus_NAME_Function_CabController: isobus_NAME_Function = 37;
#[doc = "< Unit that provides control of centralized tire inflation"]
pub const isobus_NAME_Function_TirePressureControl: isobus_NAME_Function = 38;
#[doc = "< Unit for altering the ignition of an engine"]
pub const isobus_NAME_Function_IgnitionControl: isobus_NAME_Function = 39;
#[doc = "< System for controlling the seats (operator and passenger) within the cab"]
pub const isobus_NAME_Function_SeatControl: isobus_NAME_Function = 40;
#[doc = "< Controller for sending the operator lighting controls messages"]
pub const isobus_NAME_Function_OperatorControlsLighting: isobus_NAME_Function = 41;
#[doc = "< Controller for a water pump mounted on the vehicle/machine"]
pub const isobus_NAME_Function_WaterPumpControl: isobus_NAME_Function = 42;
#[doc = "< Display designed specifically to display transmission information"]
pub const isobus_NAME_Function_TransmissionDisplay: isobus_NAME_Function = 43;
#[doc = "< Emissions controller"]
pub const isobus_NAME_Function_ExhaustEmissionControl: isobus_NAME_Function = 44;
#[doc = "< Stability controller"]
pub const isobus_NAME_Function_VehicleDynamicStabilityControl: isobus_NAME_Function = 45;
#[doc = "< Monitors oil level, life, temperature"]
pub const isobus_NAME_Function_OilSystemMonitor: isobus_NAME_Function = 46;
#[doc = "< Information management for a vehicle's application, such as cargo management"]
pub const isobus_NAME_Function_InformationSystemControl: isobus_NAME_Function = 47;
#[doc = "< Loading unloading chairlift, ramps, lifts or tailgates"]
pub const isobus_NAME_Function_RampControl: isobus_NAME_Function = 48;
#[doc = "< When transmission is distributed this handles torque converter lock-up or engine-transmission connection"]
pub const isobus_NAME_Function_ClutchConverterControl: isobus_NAME_Function = 49;
#[doc = "< Primary heat typically being taken from the engine coolant"]
pub const isobus_NAME_Function_AuxiliaryHeater: isobus_NAME_Function = 50;
#[doc = "< System which detects and warns of impending collision"]
pub const isobus_NAME_Function_ForwardLookingCollisionWarningSystem: isobus_NAME_Function = 51;
#[doc = "< Controls the chassis (not body or cab) components"]
pub const isobus_NAME_Function_ChassisControl: isobus_NAME_Function = 52;
#[doc = "< Vehicle's primary on-board charging controller"]
pub const isobus_NAME_Function_AlternatorElectricalChargingSystem: isobus_NAME_Function = 53;
#[doc = "< Radio communications unit designed to communicate via the cellular telephone system"]
pub const isobus_NAME_Function_CommunicationsCellular: isobus_NAME_Function = 54;
#[doc = "< Radio communications unit designed specifically to communicate via some satellite system"]
pub const isobus_NAME_Function_CommunicationsSatellite: isobus_NAME_Function = 55;
#[doc = "< Radio unit designed specifically to communicate via a terrestrial p2p system"]
pub const isobus_NAME_Function_CommunicationsRadio: isobus_NAME_Function = 56;
#[doc = "< Unit that gathers the operator inputs from switches/levers/etc and transmits associated messages"]
pub const isobus_NAME_Function_OperatorControlsSteeringColumn: isobus_NAME_Function = 57;
#[doc = "< Primary control system affecting the operation of the main cooling fan"]
pub const isobus_NAME_Function_FanDriveControl: isobus_NAME_Function = 58;
#[doc = "< Mechanical system for initiating rotation in an engine"]
pub const isobus_NAME_Function_Starter: isobus_NAME_Function = 59;
#[doc = "< Used for a fairly elaborate in cab display, non VT and non instrument cluster"]
pub const isobus_NAME_Function_CabDisplayCab: isobus_NAME_Function = 60;
#[doc = "< Printing or file storage unit on the network"]
pub const isobus_NAME_Function_FileServerOrPrinter: isobus_NAME_Function = 61;
#[doc = "< Tool that can be permanently mounted on the vehicle and which may not support all of the ISO 11783-12 messages"]
pub const isobus_NAME_Function_OnboardDiagnosticUnit: isobus_NAME_Function = 62;
#[doc = "< Control system used to manipulate the actuation of engine intake or exhaust"]
pub const isobus_NAME_Function_EngineValveController: isobus_NAME_Function = 63;
#[doc = "< Sum of all units in a vehicle which enable the driver to brake with virtually no friction"]
pub const isobus_NAME_Function_EnduranceBraking: isobus_NAME_Function = 64;
#[doc = "< Provides measurement of gas flow rates and associated parameters"]
pub const isobus_NAME_Function_GasFlowMeasurement: isobus_NAME_Function = 65;
#[doc = "< Reporting and/or control unit for external input and output channels"]
pub const isobus_NAME_Function_IOController: isobus_NAME_Function = 66;
#[doc = "< Can include load centres, fuse boxes and power distribution boards"]
pub const isobus_NAME_Function_ElectricalSystemController: isobus_NAME_Function = 67;
#[doc = "< Reserved range beginning"]
pub const isobus_NAME_Function_Reserved: isobus_NAME_Function = 68;
#[doc = "< Max allocated function code"]
pub const isobus_NAME_Function_MaxFunctionCode: isobus_NAME_Function = 127;
#[doc = " @brief See ISO11783-1 For complete descriptions of the ISO NAME function codes"]
pub type isobus_NAME_Function = ::std::os::raw::c_int;
#[doc = " @brief A structure that tracks the pair of a NAME parameter and associated value"]
pub type isobus_NAME_NameParameterFilter = u8;
#[test]
fn bindgen_test_layout_isobus_NAME() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_NAME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_NAME>(),
        8usize,
        concat!("Size of: ", stringify!(isobus_NAME))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_NAME>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_NAME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rawName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_NAME),
            "::",
            stringify!(rawName)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns if the ECU is capable of address arbitration\n @returns true if the ECU can arbitrate addresses"]
    #[link_name = "\u{1}_ZNK6isobus4NAME29get_arbitrary_address_capableEv"]
    pub fn isobus_NAME_get_arbitrary_address_capable(this: *const isobus_NAME) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the data in the NAME that corresponds to the arbitration capability of the ECU\n @param[in] value True if the ECU supports arbitration, false if not"]
    #[link_name = "\u{1}_ZN6isobus4NAME29set_arbitrary_address_capableEb"]
    pub fn isobus_NAME_set_arbitrary_address_capable(this: *mut isobus_NAME, value: bool);
}
extern "C" {
    #[doc = " @brief Returns the industry group encoded in the NAME\n @returns The industry group encoded in the NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME18get_industry_groupEv"]
    pub fn isobus_NAME_get_industry_group(this: *const isobus_NAME) -> u8;
}
extern "C" {
    #[doc = " @brief Sets the industry group encoded in the NAME\n @param[in] value The industry group to encode in the NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME18set_industry_groupEh"]
    pub fn isobus_NAME_set_industry_group(this: *mut isobus_NAME, value: u8);
}
extern "C" {
    #[doc = " @brief Returns the device class (vehicle system) encoded in the NAME\n @returns The device class (vehicle system) encoded in the NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME25get_device_class_instanceEv"]
    pub fn isobus_NAME_get_device_class_instance(this: *const isobus_NAME) -> u8;
}
extern "C" {
    #[doc = " @brief Sets the device class instance (vehicle system) to be encoded in the NAME\n @param[in] value The device class instance (vehicle system) to be encoded in the NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME25set_device_class_instanceEh"]
    pub fn isobus_NAME_set_device_class_instance(this: *mut isobus_NAME, value: u8);
}
extern "C" {
    #[doc = " @brief Returns the device class (vehicle system) encoded in the NAME\n @returns The device class (vehicle system) encoded in the NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME16get_device_classEv"]
    pub fn isobus_NAME_get_device_class(this: *const isobus_NAME) -> u8;
}
extern "C" {
    #[doc = " @brief Sets the device class (vehicle system) to be encoded in the NAME\n @param[in] value The device class (vehicle system) to be encoded in the NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME16set_device_classEh"]
    pub fn isobus_NAME_set_device_class(this: *mut isobus_NAME, value: u8);
}
extern "C" {
    #[doc = " @brief Gets the function code encoded in the NAME\n @returns The function code encoded in the NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME17get_function_codeEv"]
    pub fn isobus_NAME_get_function_code(this: *const isobus_NAME) -> u8;
}
extern "C" {
    #[doc = " @brief Sets the function code encoded in the NAME\n @param[in] value The function code to be encoded in the NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME17set_function_codeEh"]
    pub fn isobus_NAME_set_function_code(this: *mut isobus_NAME, value: u8);
}
extern "C" {
    #[doc = " @brief Gets the function instance encoded in the NAME\n @returns The function instance encoded in the NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME21get_function_instanceEv"]
    pub fn isobus_NAME_get_function_instance(this: *const isobus_NAME) -> u8;
}
extern "C" {
    #[doc = " @brief Sets the function instance encoded in the NAME\n @param[in] value The function instance to be encoded in the NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME21set_function_instanceEh"]
    pub fn isobus_NAME_set_function_instance(this: *mut isobus_NAME, value: u8);
}
extern "C" {
    #[doc = " @brief Gets the ecu instance encoded in the NAME\n @returns The ecu instance encoded in the NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME16get_ecu_instanceEv"]
    pub fn isobus_NAME_get_ecu_instance(this: *const isobus_NAME) -> u8;
}
extern "C" {
    #[doc = " @brief Sets the ecu instance encoded in the NAME\n @param[in] value The ecu instance to be encoded in the NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME16set_ecu_instanceEh"]
    pub fn isobus_NAME_set_ecu_instance(this: *mut isobus_NAME, value: u8);
}
extern "C" {
    #[doc = " @brief Gets the manufacturer code encoded in the NAME\n @returns The manufacturer code encoded in the NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME21get_manufacturer_codeEv"]
    pub fn isobus_NAME_get_manufacturer_code(this: *const isobus_NAME) -> u16;
}
extern "C" {
    #[doc = " @brief Sets the manufacturer code encoded in the NAME\n @param[in] value The manufacturer code to be encoded in the NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME21set_manufacturer_codeEt"]
    pub fn isobus_NAME_set_manufacturer_code(this: *mut isobus_NAME, value: u16);
}
extern "C" {
    #[doc = " @brief Gets the identity number encoded in the NAME\n @returns The identity number encoded in the NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME19get_identity_numberEv"]
    pub fn isobus_NAME_get_identity_number(this: *const isobus_NAME) -> u32;
}
extern "C" {
    #[doc = " @brief Sets the identity number encoded in the NAME\n @param[in] value The identity number to be encoded in the NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME19set_identity_numberEj"]
    pub fn isobus_NAME_set_identity_number(this: *mut isobus_NAME, value: u32);
}
extern "C" {
    #[doc = " @brief Gets the raw 64 bit NAME\n @returns The raw 64 bit NAME"]
    #[link_name = "\u{1}_ZNK6isobus4NAME13get_full_nameEv"]
    pub fn isobus_NAME_get_full_name(this: *const isobus_NAME) -> u64;
}
extern "C" {
    #[doc = " @brief Sets the raw, encoded 64 bit NAME\n @param[in] value The raw, encoded 64 bit NAME"]
    #[link_name = "\u{1}_ZN6isobus4NAME13set_full_nameEy"]
    pub fn isobus_NAME_set_full_name(this: *mut isobus_NAME, value: u64);
}
extern "C" {
    #[doc = " @brief Constructor for a NAME\n @param[in] rawNAMEData The raw 64 bit NAME of an ECU"]
    #[link_name = "\u{1}_ZN6isobus4NAMEC1Ey"]
    pub fn isobus_NAME_NAME(this: *mut isobus_NAME, rawNAMEData: u64);
}
impl isobus_NAME {
    #[inline]
    pub unsafe fn get_arbitrary_address_capable(&self) -> bool {
        isobus_NAME_get_arbitrary_address_capable(self)
    }
    #[inline]
    pub unsafe fn set_arbitrary_address_capable(&mut self, value: bool) {
        isobus_NAME_set_arbitrary_address_capable(self, value)
    }
    #[inline]
    pub unsafe fn get_industry_group(&self) -> u8 {
        isobus_NAME_get_industry_group(self)
    }
    #[inline]
    pub unsafe fn set_industry_group(&mut self, value: u8) {
        isobus_NAME_set_industry_group(self, value)
    }
    #[inline]
    pub unsafe fn get_device_class_instance(&self) -> u8 {
        isobus_NAME_get_device_class_instance(self)
    }
    #[inline]
    pub unsafe fn set_device_class_instance(&mut self, value: u8) {
        isobus_NAME_set_device_class_instance(self, value)
    }
    #[inline]
    pub unsafe fn get_device_class(&self) -> u8 {
        isobus_NAME_get_device_class(self)
    }
    #[inline]
    pub unsafe fn set_device_class(&mut self, value: u8) {
        isobus_NAME_set_device_class(self, value)
    }
    #[inline]
    pub unsafe fn get_function_code(&self) -> u8 {
        isobus_NAME_get_function_code(self)
    }
    #[inline]
    pub unsafe fn set_function_code(&mut self, value: u8) {
        isobus_NAME_set_function_code(self, value)
    }
    #[inline]
    pub unsafe fn get_function_instance(&self) -> u8 {
        isobus_NAME_get_function_instance(self)
    }
    #[inline]
    pub unsafe fn set_function_instance(&mut self, value: u8) {
        isobus_NAME_set_function_instance(self, value)
    }
    #[inline]
    pub unsafe fn get_ecu_instance(&self) -> u8 {
        isobus_NAME_get_ecu_instance(self)
    }
    #[inline]
    pub unsafe fn set_ecu_instance(&mut self, value: u8) {
        isobus_NAME_set_ecu_instance(self, value)
    }
    #[inline]
    pub unsafe fn get_manufacturer_code(&self) -> u16 {
        isobus_NAME_get_manufacturer_code(self)
    }
    #[inline]
    pub unsafe fn set_manufacturer_code(&mut self, value: u16) {
        isobus_NAME_set_manufacturer_code(self, value)
    }
    #[inline]
    pub unsafe fn get_identity_number(&self) -> u32 {
        isobus_NAME_get_identity_number(self)
    }
    #[inline]
    pub unsafe fn set_identity_number(&mut self, value: u32) {
        isobus_NAME_set_identity_number(self, value)
    }
    #[inline]
    pub unsafe fn get_full_name(&self) -> u64 {
        isobus_NAME_get_full_name(self)
    }
    #[inline]
    pub unsafe fn set_full_name(&mut self, value: u64) {
        isobus_NAME_set_full_name(self, value)
    }
    #[inline]
    pub unsafe fn new(rawNAMEData: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_NAME_NAME(__bindgen_tmp.as_mut_ptr(), rawNAMEData);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @class AddressClaimStateMachine\n\n @brief State machine for managing the J1939/ISO11783 address claim process\n\n @details This class manages address claiming for internal control functions\n and keeps track of things like requests for address claim."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_AddressClaimStateMachine {
    #[doc = "< The ISO NAME to claim as"]
    pub m_isoname: isobus_NAME,
    #[doc = "< The address claim state machine state"]
    pub m_currentState: isobus_AddressClaimStateMachine_State,
    #[doc = "< A generic timestamp in milliseconds used to find timeouts"]
    pub m_timestamp_ms: u32,
    #[doc = "< The CAN channel index to claim on"]
    pub m_portIndex: u8,
    #[doc = "< The address we'd prefer to claim as (we may not get it)"]
    pub m_preferredAddress: u8,
    #[doc = "< The random delay as required by the ISO11783 standard"]
    pub m_randomClaimDelay_ms: u8,
    #[doc = "< The actual address we ended up claiming"]
    pub m_claimedAddress: u8,
    #[doc = "<  Enable/disable state for this state machine"]
    pub m_enabled: bool,
}
#[doc = "< Address claiming is uninitialized"]
pub const isobus_AddressClaimStateMachine_State_None: isobus_AddressClaimStateMachine_State = 0;
#[doc = "< State machine is waiting for the random delay time"]
pub const isobus_AddressClaimStateMachine_State_WaitForClaim:
    isobus_AddressClaimStateMachine_State = 1;
#[doc = "< State machine is sending the request for address claim"]
pub const isobus_AddressClaimStateMachine_State_SendRequestForClaim:
    isobus_AddressClaimStateMachine_State = 2;
#[doc = "< State machine is waiting for the address claim contention period"]
pub const isobus_AddressClaimStateMachine_State_WaitForRequestContentionPeriod:
    isobus_AddressClaimStateMachine_State = 3;
#[doc = "< State machine is claiming the prefferred address"]
pub const isobus_AddressClaimStateMachine_State_SendPreferredAddressClaim:
    isobus_AddressClaimStateMachine_State = 4;
#[doc = "< State machine is contending the prefferred address"]
pub const isobus_AddressClaimStateMachine_State_ContendForPreferredAddress:
    isobus_AddressClaimStateMachine_State = 5;
#[doc = "< State machine is claiming an address"]
pub const isobus_AddressClaimStateMachine_State_SendArbitraryAddressClaim:
    isobus_AddressClaimStateMachine_State = 6;
#[doc = "< An ECU requested address claim, inform the bus of our current address"]
pub const isobus_AddressClaimStateMachine_State_SendReclaimAddressOnRequest:
    isobus_AddressClaimStateMachine_State = 7;
#[doc = "< State machine could not claim an address"]
pub const isobus_AddressClaimStateMachine_State_UnableToClaim:
    isobus_AddressClaimStateMachine_State = 8;
#[doc = "< Address claiming is complete and we have an address"]
pub const isobus_AddressClaimStateMachine_State_AddressClaimingComplete:
    isobus_AddressClaimStateMachine_State = 9;
#[doc = " @brief Defines the state machine states for address claiming"]
pub type isobus_AddressClaimStateMachine_State = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_isobus_AddressClaimStateMachine() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_AddressClaimStateMachine> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_AddressClaimStateMachine>(),
        24usize,
        concat!("Size of: ", stringify!(isobus_AddressClaimStateMachine))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_AddressClaimStateMachine>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_AddressClaimStateMachine))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_isoname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_AddressClaimStateMachine),
            "::",
            stringify!(m_isoname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_currentState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_AddressClaimStateMachine),
            "::",
            stringify!(m_currentState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_timestamp_ms) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_AddressClaimStateMachine),
            "::",
            stringify!(m_timestamp_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_portIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_AddressClaimStateMachine),
            "::",
            stringify!(m_portIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_preferredAddress) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_AddressClaimStateMachine),
            "::",
            stringify!(m_preferredAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_randomClaimDelay_ms) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_AddressClaimStateMachine),
            "::",
            stringify!(m_randomClaimDelay_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_claimedAddress) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_AddressClaimStateMachine),
            "::",
            stringify!(m_claimedAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_enabled) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_AddressClaimStateMachine),
            "::",
            stringify!(m_enabled)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns the current state of the state machine\n @returns The current state of the state machine"]
    #[link_name = "\u{1}_ZNK6isobus24AddressClaimStateMachine17get_current_stateEv"]
    pub fn isobus_AddressClaimStateMachine_get_current_state(
        this: *const isobus_AddressClaimStateMachine,
    ) -> isobus_AddressClaimStateMachine_State;
}
extern "C" {
    #[doc = " @brief Enables or disables the address claimer\n @param[in] value true if you want the class to claim, false if you want to be a sniffer only"]
    #[link_name = "\u{1}_ZN6isobus24AddressClaimStateMachine14set_is_enabledEb"]
    pub fn isobus_AddressClaimStateMachine_set_is_enabled(
        this: *mut isobus_AddressClaimStateMachine,
        value: bool,
    );
}
extern "C" {
    #[doc = " @brief Returns if the address claimer is enabled\n @returns true if the class will address claim, false if in sniffing mode"]
    #[link_name = "\u{1}_ZNK6isobus24AddressClaimStateMachine11get_enabledEv"]
    pub fn isobus_AddressClaimStateMachine_get_enabled(
        this: *const isobus_AddressClaimStateMachine,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the address claimed by the state machine or 0xFE if none claimed\n @returns The address claimed by the state machine or 0xFE if no address has been claimed"]
    #[link_name = "\u{1}_ZNK6isobus24AddressClaimStateMachine19get_claimed_addressEv"]
    pub fn isobus_AddressClaimStateMachine_get_claimed_address(
        this: *const isobus_AddressClaimStateMachine,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Updates the state machine, should be called periodically"]
    #[link_name = "\u{1}_ZN6isobus24AddressClaimStateMachine6updateEv"]
    pub fn isobus_AddressClaimStateMachine_update(this: *mut isobus_AddressClaimStateMachine);
}
extern "C" {
    #[doc = " @brief The constructor of the state machine class\n @param[in] preferredAddressValue The address you prefer to claim\n @param[in] ControlFunctionNAME The NAME you want to claim\n @param[in] portIndex The CAN channel index to claim on"]
    #[link_name = "\u{1}_ZN6isobus24AddressClaimStateMachineC1EhNS_4NAMEEh"]
    pub fn isobus_AddressClaimStateMachine_AddressClaimStateMachine(
        this: *mut isobus_AddressClaimStateMachine,
        preferredAddressValue: u8,
        ControlFunctionNAME: isobus_NAME,
        portIndex: u8,
    );
}
extern "C" {
    #[doc = " @brief The destructor for the address claim state machine"]
    #[link_name = "\u{1}_ZN6isobus24AddressClaimStateMachineD1Ev"]
    pub fn isobus_AddressClaimStateMachine_AddressClaimStateMachine_destructor(
        this: *mut isobus_AddressClaimStateMachine,
    );
}
impl isobus_AddressClaimStateMachine {
    #[inline]
    pub unsafe fn get_current_state(&self) -> isobus_AddressClaimStateMachine_State {
        isobus_AddressClaimStateMachine_get_current_state(self)
    }
    #[inline]
    pub unsafe fn set_is_enabled(&mut self, value: bool) {
        isobus_AddressClaimStateMachine_set_is_enabled(self, value)
    }
    #[inline]
    pub unsafe fn get_enabled(&self) -> bool {
        isobus_AddressClaimStateMachine_get_enabled(self)
    }
    #[inline]
    pub unsafe fn get_claimed_address(&self) -> u8 {
        isobus_AddressClaimStateMachine_get_claimed_address(self)
    }
    #[inline]
    pub unsafe fn update(&mut self) {
        isobus_AddressClaimStateMachine_update(self)
    }
    #[inline]
    pub unsafe fn new(
        preferredAddressValue: u8,
        ControlFunctionNAME: isobus_NAME,
        portIndex: u8,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_AddressClaimStateMachine_AddressClaimStateMachine(
            __bindgen_tmp.as_mut_ptr(),
            preferredAddressValue,
            ControlFunctionNAME,
            portIndex,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        isobus_AddressClaimStateMachine_AddressClaimStateMachine_destructor(self)
    }
}
#[doc = "! @cond DoNotRaiseWarning"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_CANLibBadge {
    pub _address: u8,
}
#[repr(C)]
pub struct isobus_ControlFunction__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @class ControlFunction\n\n @brief A class that describes an ISO11783 control function, which includes a NAME and address."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_ControlFunction {
    pub vtable_: *const isobus_ControlFunction__bindgen_vtable,
    #[doc = "< The NAME of the control function"]
    pub controlFunctionNAME: isobus_NAME,
    #[doc = "< The Type of the control function"]
    pub controlFunctionType: isobus_ControlFunction_Type,
    #[doc = "< The address of the control function"]
    pub address: u8,
    #[doc = "< The CAN channel index of the control function"]
    pub canPortIndex: u8,
}
#[doc = "< The control function is part of our stack and can address claim"]
pub const isobus_ControlFunction_Type_Internal: isobus_ControlFunction_Type = 0;
#[doc = "< The control function is some other device on the bus"]
pub const isobus_ControlFunction_Type_External: isobus_ControlFunction_Type = 1;
#[doc = "< An external control function that you explicitly want to talk to"]
pub const isobus_ControlFunction_Type_Partnered: isobus_ControlFunction_Type = 2;
#[doc = " @brief The type of the control function"]
pub type isobus_ControlFunction_Type = ::std::os::raw::c_int;
extern "C" {
    #[doc = "< Protects the control function tables"]
    #[link_name = "\u{1}_ZN6isobus15ControlFunction30controlFunctionProcessingMutexE"]
    pub static mut isobus_ControlFunction_controlFunctionProcessingMutex: std_mutex;
}
#[test]
fn bindgen_test_layout_isobus_ControlFunction() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_ControlFunction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_ControlFunction>(),
        24usize,
        concat!("Size of: ", stringify!(isobus_ControlFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_ControlFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_ControlFunction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controlFunctionNAME) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ControlFunction),
            "::",
            stringify!(controlFunctionNAME)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controlFunctionType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ControlFunction),
            "::",
            stringify!(controlFunctionType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ControlFunction),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canPortIndex) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ControlFunction),
            "::",
            stringify!(canPortIndex)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns the current address of the control function\n @returns The current address of the control function"]
    #[link_name = "\u{1}_ZNK6isobus15ControlFunction11get_addressEv"]
    pub fn isobus_ControlFunction_get_address(this: *const isobus_ControlFunction) -> u8;
}
extern "C" {
    #[doc = " @brief Describes if the control function has a valid address (not NULL or global)\n @returns true if the address is < 0xFE"]
    #[link_name = "\u{1}_ZNK6isobus15ControlFunction17get_address_validEv"]
    pub fn isobus_ControlFunction_get_address_valid(this: *const isobus_ControlFunction) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the CAN channel index the control function communicates on\n @returns The control function's CAN channel index"]
    #[link_name = "\u{1}_ZNK6isobus15ControlFunction12get_can_portEv"]
    pub fn isobus_ControlFunction_get_can_port(this: *const isobus_ControlFunction) -> u8;
}
extern "C" {
    #[doc = " @brief Returns the NAME of the control function as described by its address claim message\n @returns The control function's NAME"]
    #[link_name = "\u{1}_ZNK6isobus15ControlFunction8get_NAMEEv"]
    pub fn isobus_ControlFunction_get_NAME(this: *const isobus_ControlFunction) -> isobus_NAME;
}
extern "C" {
    #[doc = " @brief Returns the `Type` of the control function\n @returns The control function type"]
    #[link_name = "\u{1}_ZNK6isobus15ControlFunction8get_typeEv"]
    pub fn isobus_ControlFunction_get_type(
        this: *const isobus_ControlFunction,
    ) -> isobus_ControlFunction_Type;
}
extern "C" {
    #[doc = " @brief The base class constructor for a control function\n @param[in] NAMEValue The NAME of the control function\n @param[in] addressValue The current address of the control function\n @param[in] CANPort The CAN channel index that the control function communicates on"]
    #[link_name = "\u{1}_ZN6isobus15ControlFunctionC1ENS_4NAMEEhh"]
    pub fn isobus_ControlFunction_ControlFunction(
        this: *mut isobus_ControlFunction,
        NAMEValue: isobus_NAME,
        addressValue: u8,
        CANPort: u8,
    );
}
impl isobus_ControlFunction {
    #[inline]
    pub unsafe fn get_address(&self) -> u8 {
        isobus_ControlFunction_get_address(self)
    }
    #[inline]
    pub unsafe fn get_address_valid(&self) -> bool {
        isobus_ControlFunction_get_address_valid(self)
    }
    #[inline]
    pub unsafe fn get_can_port(&self) -> u8 {
        isobus_ControlFunction_get_can_port(self)
    }
    #[inline]
    pub unsafe fn get_NAME(&self) -> isobus_NAME {
        isobus_ControlFunction_get_NAME(self)
    }
    #[inline]
    pub unsafe fn get_type(&self) -> isobus_ControlFunction_Type {
        isobus_ControlFunction_get_type(self)
    }
    #[inline]
    pub unsafe fn new(NAMEValue: isobus_NAME, addressValue: u8, CANPort: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_ControlFunction_ControlFunction(
            __bindgen_tmp.as_mut_ptr(),
            NAMEValue,
            addressValue,
            CANPort,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @brief The base class destructor for a control function"]
    #[link_name = "\u{1}_ZN6isobus15ControlFunctionD1Ev"]
    pub fn isobus_ControlFunction_ControlFunction_destructor(this: *mut isobus_ControlFunction);
}
#[doc = " @class CANIdentifier\n\n @brief A utility class that allows easy interpretation of a 32 bit CAN identifier"]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_CANIdentifier {
    #[doc = "< The raw encoded 29 bit ID"]
    pub m_RawIdentifier: u32,
}
#[doc = "< Highest CAN priority"]
pub const isobus_CANIdentifier_CANPriority_PriorityHighest0: isobus_CANIdentifier_CANPriority = 0;
#[doc = "< Priority highest - 1"]
pub const isobus_CANIdentifier_CANPriority_Priority1: isobus_CANIdentifier_CANPriority = 1;
#[doc = "< Priority highest - 2"]
pub const isobus_CANIdentifier_CANPriority_Priority2: isobus_CANIdentifier_CANPriority = 2;
#[doc = "< Priority highest - 3 (Control messages priority)"]
pub const isobus_CANIdentifier_CANPriority_Priority3: isobus_CANIdentifier_CANPriority = 3;
#[doc = "< Priority highest - 4"]
pub const isobus_CANIdentifier_CANPriority_Priority4: isobus_CANIdentifier_CANPriority = 4;
#[doc = "< Priority highest - 5"]
pub const isobus_CANIdentifier_CANPriority_Priority5: isobus_CANIdentifier_CANPriority = 5;
#[doc = "< The default priority"]
pub const isobus_CANIdentifier_CANPriority_PriorityDefault6: isobus_CANIdentifier_CANPriority = 6;
#[doc = "< The lowest priority"]
pub const isobus_CANIdentifier_CANPriority_PriorityLowest7: isobus_CANIdentifier_CANPriority = 7;
#[doc = " @brief Defines all the CAN frame priorities that can be encoded in a frame ID"]
pub type isobus_CANIdentifier_CANPriority = ::std::os::raw::c_uint;
#[doc = "< Frame is an 11bit ID standard (legacy) message with no PGN and highest priority"]
pub const isobus_CANIdentifier_Type_Standard: isobus_CANIdentifier_Type = 0;
#[doc = "< Frame is a modern 29 bit ID CAN frame"]
pub const isobus_CANIdentifier_Type_Extended: isobus_CANIdentifier_Type = 1;
#[doc = " @brief Defines if a frame is a standard (11 bit) or extended (29 bit) ID frame"]
pub type isobus_CANIdentifier_Type = ::std::os::raw::c_uint;
#[doc = "< This bit denotes if the frame is standard or extended format"]
pub const isobus_CANIdentifier_IDENTIFIER_TYPE_BIT_MASK: u32 = 2147483648;
#[doc = "< A fake PGN used internally to denote a NULL PGN"]
pub const isobus_CANIdentifier_UNDEFINED_PARAMETER_GROUP_NUMBER: u32 = 4294967295;
#[doc = "< The broadcast CAN address"]
pub const isobus_CANIdentifier_GLOBAL_ADDRESS: u8 = 255;
#[doc = "< The NULL CAN address as defined by ISO11783"]
pub const isobus_CANIdentifier_NULL_ADDRESS: u8 = 254;
#[doc = "< Broadcast PGNs don't mask off the bits used for destination in the PGN"]
pub const isobus_CANIdentifier_BROADCAST_PGN_MASK: u32 = 262143;
#[doc = "< Destination specific PGNs mask the destination out of the PGN itself"]
pub const isobus_CANIdentifier_DESTINATION_SPECIFIC_PGN_MASK: u32 = 261888;
#[doc = "< Mask that denotes the ID as being PDU2 format"]
pub const isobus_CANIdentifier_PDU2_FORMAT_MASK: u32 = 15728640;
#[doc = "< PGN is offset 8 bits into the ID"]
pub const isobus_CANIdentifier_PARAMTER_GROUP_NUMBER_OFFSET: u8 = 8;
#[doc = "< Priority is offset 26 bits into the ID"]
pub const isobus_CANIdentifier_PRIORITY_DATA_BIT_OFFSET: u8 = 26;
#[test]
fn bindgen_test_layout_isobus_CANIdentifier() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_CANIdentifier> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_CANIdentifier>(),
        4usize,
        concat!("Size of: ", stringify!(isobus_CANIdentifier))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_CANIdentifier>(),
        4usize,
        concat!("Alignment of ", stringify!(isobus_CANIdentifier))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_RawIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANIdentifier),
            "::",
            stringify!(m_RawIdentifier)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns the raw encoded ID of the CAN identifier\n @returns The raw encoded ID of the CAN identifier"]
    #[link_name = "\u{1}_ZNK6isobus13CANIdentifier14get_identifierEv"]
    pub fn isobus_CANIdentifier_get_identifier(this: *const isobus_CANIdentifier) -> u32;
}
extern "C" {
    #[doc = " @brief Returns the identifier type (standard vs extended)\n @returns The identifier type (standard vs extended)"]
    #[link_name = "\u{1}_ZNK6isobus13CANIdentifier19get_identifier_typeEv"]
    pub fn isobus_CANIdentifier_get_identifier_type(
        this: *const isobus_CANIdentifier,
    ) -> isobus_CANIdentifier_Type;
}
extern "C" {
    #[doc = " @brief Returns the PGN encoded in the identifier\n @returns The PGN encoded in the identifier"]
    #[link_name = "\u{1}_ZNK6isobus13CANIdentifier26get_parameter_group_numberEv"]
    pub fn isobus_CANIdentifier_get_parameter_group_number(
        this: *const isobus_CANIdentifier,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Returns the priority of the frame encoded in the identifier\n @returns The priority of the frame encoded in the identifier"]
    #[link_name = "\u{1}_ZNK6isobus13CANIdentifier12get_priorityEv"]
    pub fn isobus_CANIdentifier_get_priority(
        this: *const isobus_CANIdentifier,
    ) -> isobus_CANIdentifier_CANPriority;
}
extern "C" {
    #[doc = " @brief Returns the destination address of the frame encoded in the identifier\n @returns The destination address of the frame encoded in the identifier"]
    #[link_name = "\u{1}_ZNK6isobus13CANIdentifier23get_destination_addressEv"]
    pub fn isobus_CANIdentifier_get_destination_address(this: *const isobus_CANIdentifier) -> u8;
}
extern "C" {
    #[doc = " @brief Returns the source address of the frame encoded in the identifier\n @returns The source address of the frame encoded in the identifier"]
    #[link_name = "\u{1}_ZNK6isobus13CANIdentifier18get_source_addressEv"]
    pub fn isobus_CANIdentifier_get_source_address(this: *const isobus_CANIdentifier) -> u8;
}
extern "C" {
    #[doc = " @brief Returns if the ID is valid based on some range checking\n @returns Frame valid status"]
    #[link_name = "\u{1}_ZNK6isobus13CANIdentifier12get_is_validEv"]
    pub fn isobus_CANIdentifier_get_is_valid(this: *const isobus_CANIdentifier) -> bool;
}
extern "C" {
    #[doc = " @brief Constructor for a CAN Identifier class based on a raw 32 bit ID\n @param[in] rawIdentifierData The raw 32 bit ID to interpret"]
    #[link_name = "\u{1}_ZN6isobus13CANIdentifierC1Ej"]
    pub fn isobus_CANIdentifier_CANIdentifier(
        this: *mut isobus_CANIdentifier,
        rawIdentifierData: u32,
    );
}
extern "C" {
    #[doc = " @brief Constructor for a CAN Identifier class based on all discrete components\n @param[in] identifierType Type of frame, either standard 11 bit ID, or extended 29 bit ID\n @param[in] pgn The parameter group number encoded in the frame (extended only)\n @param[in] priority The priority of the frame (extended only)\n @param[in] destinationAddress The destination address of the frame\n @param[in] sourceAddress The source address of the frame"]
    #[link_name = "\u{1}_ZN6isobus13CANIdentifierC1ENS0_4TypeEjNS0_11CANPriorityEhh"]
    pub fn isobus_CANIdentifier_CANIdentifier1(
        this: *mut isobus_CANIdentifier,
        identifierType: isobus_CANIdentifier_Type,
        pgn: u32,
        priority: isobus_CANIdentifier_CANPriority,
        destinationAddress: u8,
        sourceAddress: u8,
    );
}
extern "C" {
    #[doc = " @brief Copy constructor for a CAN Identifier\n @param[in] copiedObject The object to copy"]
    #[link_name = "\u{1}_ZN6isobus13CANIdentifierC1ERKS0_"]
    pub fn isobus_CANIdentifier_CANIdentifier2(
        this: *mut isobus_CANIdentifier,
        copiedObject: *const isobus_CANIdentifier,
    );
}
extern "C" {
    #[doc = " @brief Destructor for the CANIdentifier"]
    #[link_name = "\u{1}_ZN6isobus13CANIdentifierD1Ev"]
    pub fn isobus_CANIdentifier_CANIdentifier_destructor(this: *mut isobus_CANIdentifier);
}
impl isobus_CANIdentifier {
    #[inline]
    pub unsafe fn get_identifier(&self) -> u32 {
        isobus_CANIdentifier_get_identifier(self)
    }
    #[inline]
    pub unsafe fn get_identifier_type(&self) -> isobus_CANIdentifier_Type {
        isobus_CANIdentifier_get_identifier_type(self)
    }
    #[inline]
    pub unsafe fn get_parameter_group_number(&self) -> u32 {
        isobus_CANIdentifier_get_parameter_group_number(self)
    }
    #[inline]
    pub unsafe fn get_priority(&self) -> isobus_CANIdentifier_CANPriority {
        isobus_CANIdentifier_get_priority(self)
    }
    #[inline]
    pub unsafe fn get_destination_address(&self) -> u8 {
        isobus_CANIdentifier_get_destination_address(self)
    }
    #[inline]
    pub unsafe fn get_source_address(&self) -> u8 {
        isobus_CANIdentifier_get_source_address(self)
    }
    #[inline]
    pub unsafe fn get_is_valid(&self) -> bool {
        isobus_CANIdentifier_get_is_valid(self)
    }
    #[inline]
    pub unsafe fn new(rawIdentifierData: u32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_CANIdentifier_CANIdentifier(__bindgen_tmp.as_mut_ptr(), rawIdentifierData);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        identifierType: isobus_CANIdentifier_Type,
        pgn: u32,
        priority: isobus_CANIdentifier_CANPriority,
        destinationAddress: u8,
        sourceAddress: u8,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_CANIdentifier_CANIdentifier1(
            __bindgen_tmp.as_mut_ptr(),
            identifierType,
            pgn,
            priority,
            destinationAddress,
            sourceAddress,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(copiedObject: *const isobus_CANIdentifier) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_CANIdentifier_CANIdentifier2(__bindgen_tmp.as_mut_ptr(), copiedObject);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        isobus_CANIdentifier_CANIdentifier_destructor(self)
    }
}
#[repr(C)]
pub struct isobus_CANMessage__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @class CANMessage\n\n @brief A class that represents a generic CAN message of arbitrary length."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_CANMessage {
    pub vtable_: *const isobus_CANMessage__bindgen_vtable,
    #[doc = "< A data buffer for the message, used when not using data chunk callbacks"]
    pub data: [u64; 3usize],
    #[doc = "< The source control function of the message"]
    pub source: *mut isobus_ControlFunction,
    #[doc = "< The destination control function of the message"]
    pub destination: *mut isobus_ControlFunction,
    #[doc = "< The CAN ID of the message"]
    pub identifier: isobus_CANIdentifier,
    #[doc = "< The internal message type associated with the message"]
    pub messageType: isobus_CANMessage_Type,
    #[doc = "< The unique ID of the message, an internal value for tracking and stats"]
    pub messageUniqueID: u32,
    #[doc = "< The CAN channel index associated with the message"]
    pub CANPortIndex: u8,
}
#[doc = "< Message is to be transmitted from the stack"]
pub const isobus_CANMessage_Type_Transmit: isobus_CANMessage_Type = 0;
#[doc = "< Message is being received"]
pub const isobus_CANMessage_Type_Receive: isobus_CANMessage_Type = 1;
#[doc = "< Message is being used internally as data storage for a protocol"]
pub const isobus_CANMessage_Type_Internal: isobus_CANMessage_Type = 2;
#[doc = " @brief The internal message type"]
pub type isobus_CANMessage_Type = ::std::os::raw::c_int;
#[doc = " @brief ISO11783-3 defines this: The maximum number of packets that can be sent in a single connection\n with extended transport protocol is restricted by the extended data packet offset (3 bytes).\n This yields a maximum message size of (2^24-1 packets) x (7 bytes/packet) = 117440505 bytes\n @returns The maximum length of any CAN message as defined by ETP in ISO11783"]
pub const isobus_CANMessage_ABSOLUTE_MAX_MESSAGE_LENGTH: u32 = 117440505;
extern "C" {
    #[doc = "< A unique, sequential ID for this CAN message"]
    #[link_name = "\u{1}_ZN6isobus10CANMessage21lastGeneratedUniqueIDE"]
    pub static mut isobus_CANMessage_lastGeneratedUniqueID: u32;
}
#[test]
fn bindgen_test_layout_isobus_CANMessage() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_CANMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_CANMessage>(),
        64usize,
        concat!("Size of: ", stringify!(isobus_CANMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_CANMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_CANMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANMessage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANMessage),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANMessage),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANMessage),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageType) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANMessage),
            "::",
            stringify!(messageType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageUniqueID) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANMessage),
            "::",
            stringify!(messageUniqueID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CANPortIndex) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANMessage),
            "::",
            stringify!(CANPortIndex)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns the CAN message type\n @returns The type of the CAN message"]
    #[link_name = "\u{1}_ZNK6isobus10CANMessage8get_typeEv"]
    pub fn isobus_CANMessage_get_type(this: *const isobus_CANMessage) -> isobus_CANMessage_Type;
}
extern "C" {
    #[doc = " @brief Gets a reference to the data in the CAN message\n @returns A reference to the data in the CAN message"]
    #[link_name = "\u{1}_ZN6isobus10CANMessage8get_dataEv"]
    // pub fn isobus_CANMessage_get_data(this: *mut isobus_CANMessage) -> *mut [u64; 3usize];
    pub fn isobus_CANMessage_get_data(this: *mut isobus_CANMessage) -> *mut [u8];
}
extern "C" {
    #[doc = " @brief Gets the source control function that the message is from\n @returns The source control function that the message is from"]
    #[link_name = "\u{1}_ZNK6isobus10CANMessage27get_source_control_functionEv"]
    pub fn isobus_CANMessage_get_source_control_function(
        this: *const isobus_CANMessage,
    ) -> *mut isobus_ControlFunction;
}
extern "C" {
    #[doc = " @brief Gets the destination control function that the message is to\n @returns The destination control function that the message is to"]
    #[link_name = "\u{1}_ZNK6isobus10CANMessage32get_destination_control_functionEv"]
    pub fn isobus_CANMessage_get_destination_control_function(
        this: *const isobus_CANMessage,
    ) -> *mut isobus_ControlFunction;
}
extern "C" {
    #[doc = " @brief Returns the identifier of the message\n @returns The identifier of the message"]
    #[link_name = "\u{1}_ZNK6isobus10CANMessage14get_identifierEv"]
    pub fn isobus_CANMessage_get_identifier(this: *const isobus_CANMessage)
        -> isobus_CANIdentifier;
}
extern "C" {
    #[doc = " @brief Returns the unique message ID\n @returns The unique message ID"]
    #[link_name = "\u{1}_ZNK6isobus10CANMessage21get_message_unique_idEv"]
    pub fn isobus_CANMessage_get_message_unique_id(this: *const isobus_CANMessage) -> u32;
}
extern "C" {
    #[doc = " @brief Returns the CAN channel index associated with the message\n @returns The CAN channel index associated with the message"]
    #[link_name = "\u{1}_ZNK6isobus10CANMessage18get_can_port_indexEv"]
    pub fn isobus_CANMessage_get_can_port_index(this: *const isobus_CANMessage) -> u8;
}
extern "C" {
    #[doc = " @brief Constructor for a CAN message\n @param[in] CANPort The can channel index the message uses"]
    #[link_name = "\u{1}_ZN6isobus10CANMessageC1Eh"]
    pub fn isobus_CANMessage_CANMessage(this: *mut isobus_CANMessage, CANPort: u8);
}
impl isobus_CANMessage {
    #[inline]
    pub unsafe fn get_type(&self) -> isobus_CANMessage_Type {
        isobus_CANMessage_get_type(self)
    }
    #[inline]
    pub unsafe fn get_data(&mut self) -> *mut [u8] {
        isobus_CANMessage_get_data(self)
    }
    #[inline]
    pub unsafe fn get_source_control_function(&self) -> *mut isobus_ControlFunction {
        isobus_CANMessage_get_source_control_function(self)
    }
    #[inline]
    pub unsafe fn get_destination_control_function(&self) -> *mut isobus_ControlFunction {
        isobus_CANMessage_get_destination_control_function(self)
    }
    #[inline]
    pub unsafe fn get_identifier(&self) -> isobus_CANIdentifier {
        isobus_CANMessage_get_identifier(self)
    }
    #[inline]
    pub unsafe fn get_message_unique_id(&self) -> u32 {
        isobus_CANMessage_get_message_unique_id(self)
    }
    #[inline]
    pub unsafe fn get_can_port_index(&self) -> u8 {
        isobus_CANMessage_get_can_port_index(self)
    }
    #[inline]
    pub unsafe fn new(CANPort: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_CANMessage_CANMessage(__bindgen_tmp.as_mut_ptr(), CANPort);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @brief Returns the length of the data in the CAN message\n @returns The message data payload length"]
    #[link_name = "\u{1}_ZNK6isobus10CANMessage15get_data_lengthEv"]
    pub fn isobus_CANMessage_get_data_length(this: *mut ::std::os::raw::c_void) -> u32;
}
#[doc = "< \"ACK\" Indicates that the request was completed"]
pub const isobus_AcknowledgementType_Positive: isobus_AcknowledgementType = 0;
#[doc = "< \"NACK\" Indicates the request was not completed or we do not support the PGN"]
pub const isobus_AcknowledgementType_Negative: isobus_AcknowledgementType = 1;
#[doc = "< Signals to the requestor that their CF is not allowed to request this PGN"]
pub const isobus_AcknowledgementType_AccessDenied: isobus_AcknowledgementType = 2;
#[doc = "< Signals to the requestor that we are unable to accept the request for some reason"]
pub const isobus_AcknowledgementType_CannotRespond: isobus_AcknowledgementType = 3;
#[doc = " @brief The types of acknowldegement that can be sent in the Ack PGN"]
pub type isobus_AcknowledgementType = u8;
#[doc = " @brief A callback for control functions to get CAN messages"]
pub type isobus_CANLibCallback = ::std::option::Option<
    unsafe extern "C" fn(
        message: *mut isobus_CANMessage,
        parentPointer: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief A callback to get chunks of data for transfer by a protocol"]
pub type isobus_DataChunkCallback = ::std::option::Option<
    unsafe extern "C" fn(
        callbackIndex: u32,
        bytesOffset: u32,
        numberOfBytesNeeded: u32,
        chunkBuffer: *mut u8,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " @brief A callback for when a transmit is completed by the stack"]
pub type isobus_TransmitCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        parameterGroupNumber: u32,
        dataLength: u32,
        sourceControlFunction: *mut isobus_InternalControlFunction,
        destinationControlFunction: *mut isobus_ControlFunction,
        successful: bool,
        parentPointer: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief A callback for handling a PGN request"]
pub type isobus_PGNRequestCallback = ::std::option::Option<
    unsafe extern "C" fn(
        parameterGroupNumber: u32,
        requestingControlFunction: *mut isobus_ControlFunction,
        acknowledge: *mut bool,
        acknowledgeType: *mut isobus_AcknowledgementType,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " @brief A callback for handling a request for repetition rate for a specific PGN"]
pub type isobus_PGNRequestForRepetitionRateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        parameterGroupNumber: u32,
        requestingControlFunction: *mut isobus_ControlFunction,
        repetitionRate: u32,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " @class ParameterGroupNumberCallbackData\n\n @brief A storage class to hold data about PGN callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_ParameterGroupNumberCallbackData {
    #[doc = "< The callback that will get called when a matching PGN is received"]
    pub mCallback: isobus_CANLibCallback,
    #[doc = "< The PGN assocuiated with this callback"]
    pub mParameterGroupNumber: u32,
    #[doc = "< A generic variable that can provide context to which object the callback was meant for"]
    pub mParent: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_isobus_ParameterGroupNumberCallbackData() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_ParameterGroupNumberCallbackData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_ParameterGroupNumberCallbackData>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(isobus_ParameterGroupNumberCallbackData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_ParameterGroupNumberCallbackData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_ParameterGroupNumberCallbackData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mCallback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberCallbackData),
            "::",
            stringify!(mCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mParameterGroupNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberCallbackData),
            "::",
            stringify!(mParameterGroupNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mParent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberCallbackData),
            "::",
            stringify!(mParent)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns the PGN associated with this callback data\n @returns The PGN associated with this callback data"]
    #[link_name = "\u{1}_ZNK6isobus32ParameterGroupNumberCallbackData26get_parameter_group_numberEv"]
    pub fn isobus_ParameterGroupNumberCallbackData_get_parameter_group_number(
        this: *const isobus_ParameterGroupNumberCallbackData,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Returns the callback pointer for this data object\n @returns The callback pointer for this data object"]
    #[link_name = "\u{1}_ZNK6isobus32ParameterGroupNumberCallbackData12get_callbackEv"]
    pub fn isobus_ParameterGroupNumberCallbackData_get_callback(
        this: *const isobus_ParameterGroupNumberCallbackData,
    ) -> isobus_CANLibCallback;
}
extern "C" {
    #[doc = " @brief Returns the parent pointer for this data object"]
    #[link_name = "\u{1}_ZNK6isobus32ParameterGroupNumberCallbackData10get_parentEv"]
    pub fn isobus_ParameterGroupNumberCallbackData_get_parent(
        this: *const isobus_ParameterGroupNumberCallbackData,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief A constructor for holding callback data\n @param[in] parameterGroupNumber The PGN you want to register a callback for\n @param[in] callback The function you want the stack to call when it gets receives a message with a matching PGN\n @param[in] parentPointer A generic variable that can provide context to which object the callback was meant for"]
    #[link_name = "\u{1}_ZN6isobus32ParameterGroupNumberCallbackDataC1EjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_ParameterGroupNumberCallbackData_ParameterGroupNumberCallbackData(
        this: *mut isobus_ParameterGroupNumberCallbackData,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief A copy constructor for holding callback data\n @param[in] oldObj The object to copy from"]
    #[link_name = "\u{1}_ZN6isobus32ParameterGroupNumberCallbackDataC1ERKS0_"]
    pub fn isobus_ParameterGroupNumberCallbackData_ParameterGroupNumberCallbackData1(
        this: *mut isobus_ParameterGroupNumberCallbackData,
        oldObj: *const isobus_ParameterGroupNumberCallbackData,
    );
}
impl isobus_ParameterGroupNumberCallbackData {
    #[inline]
    pub unsafe fn get_parameter_group_number(&self) -> u32 {
        isobus_ParameterGroupNumberCallbackData_get_parameter_group_number(self)
    }
    #[inline]
    pub unsafe fn get_callback(&self) -> isobus_CANLibCallback {
        isobus_ParameterGroupNumberCallbackData_get_callback(self)
    }
    #[inline]
    pub unsafe fn get_parent(&self) -> *mut ::std::os::raw::c_void {
        isobus_ParameterGroupNumberCallbackData_get_parent(self)
    }
    #[inline]
    pub unsafe fn new(
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_ParameterGroupNumberCallbackData_ParameterGroupNumberCallbackData(
            __bindgen_tmp.as_mut_ptr(),
            parameterGroupNumber,
            callback,
            parentPointer,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(oldObj: *const isobus_ParameterGroupNumberCallbackData) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_ParameterGroupNumberCallbackData_ParameterGroupNumberCallbackData1(
            __bindgen_tmp.as_mut_ptr(),
            oldObj,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = "< An invalid NAME used as a default"]
pub const isobus_DEFAULT_NAME: u64 = 18446744073709551615;
#[doc = "< An invalid identifier used as a default"]
pub const isobus_DEFAULT_IDENTIFIER: u32 = 4294967295;
#[doc = "< The NULL CAN address defined by J1939 and ISO11783"]
pub const isobus_NULL_CAN_ADDRESS: u8 = 254;
#[doc = "< The global/broadcast CAN address"]
pub const isobus_BROADCAST_CAN_ADDRESS: u8 = 255;
#[doc = "< The length of a classical CAN frame"]
pub const isobus_CAN_DATA_LENGTH: u8 = 8;
#[doc = "< An arbitrary limit for memory consumption"]
pub const isobus_CAN_PORT_MAXIMUM: u32 = 4;
#[doc = " @class CANLibManagedMessage\n\n @brief A derived CAN message class that the stack can use to manipulate CAN message data\n in order to construct a message to send or track message details in a protocol class."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_CANLibManagedMessage {
    pub _base: isobus_CANMessage,
    #[doc = "< The size of the message when using callbacks and not the internal data vector"]
    pub callbackMessageSize: u32,
}
#[test]
fn bindgen_test_layout_isobus_CANLibManagedMessage() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_CANLibManagedMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_CANLibManagedMessage>(),
        72usize,
        concat!("Size of: ", stringify!(isobus_CANLibManagedMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_CANLibManagedMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_CANLibManagedMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackMessageSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANLibManagedMessage),
            "::",
            stringify!(callbackMessageSize)
        )
    );
}
extern "C" {
    #[doc = " @brief Sets the message data to the value supplied. Creates a copy.\n @param[in] dataBuffer The data payload\n @param[in] length the length of the data payload in bytes"]
    #[link_name = "\u{1}_ZN6isobus20CANLibManagedMessage8set_dataEPKhj"]
    pub fn isobus_CANLibManagedMessage_set_data(
        this: *mut isobus_CANLibManagedMessage,
        dataBuffer: *const u8,
        length: u32,
    );
}
extern "C" {
    #[doc = " @brief Sets one byte of data in the message data payload\n @param[in] dataByte One byte of data\n @param[in] insertPosition The position in the message at which to insert the data byte"]
    #[link_name = "\u{1}_ZN6isobus20CANLibManagedMessage8set_dataEhj"]
    pub fn isobus_CANLibManagedMessage_set_data1(
        this: *mut isobus_CANLibManagedMessage,
        dataByte: u8,
        insertPosition: u32,
    );
}
extern "C" {
    #[doc = " @brief Sets the size of the data payload\n @param[in] length The desired length of the data payload"]
    #[link_name = "\u{1}_ZN6isobus20CANLibManagedMessage13set_data_sizeEj"]
    pub fn isobus_CANLibManagedMessage_set_data_size(
        this: *mut isobus_CANLibManagedMessage,
        length: u32,
    );
}
extern "C" {
    #[doc = " @brief Sets the source control function for the message\n @param[in] value The source control function"]
    #[link_name = "\u{1}_ZN6isobus20CANLibManagedMessage27set_source_control_functionEPNS_15ControlFunctionE"]
    pub fn isobus_CANLibManagedMessage_set_source_control_function(
        this: *mut isobus_CANLibManagedMessage,
        value: *mut isobus_ControlFunction,
    );
}
extern "C" {
    #[doc = " @brief Sets the destination control function for the message\n @param[in] value The destination control function"]
    #[link_name = "\u{1}_ZN6isobus20CANLibManagedMessage32set_destination_control_functionEPNS_15ControlFunctionE"]
    pub fn isobus_CANLibManagedMessage_set_destination_control_function(
        this: *mut isobus_CANLibManagedMessage,
        value: *mut isobus_ControlFunction,
    );
}
extern "C" {
    #[doc = " @brief Sets the CAN ID of the message\n @param[in] value The CAN ID for the message"]
    #[link_name = "\u{1}_ZN6isobus20CANLibManagedMessage14set_identifierENS_13CANIdentifierE"]
    pub fn isobus_CANLibManagedMessage_set_identifier(
        this: *mut isobus_CANLibManagedMessage,
        value: isobus_CANIdentifier,
    );
}
extern "C" {
    #[doc = " @brief Gets the size of the message when using callbacks and not the internal data vector"]
    #[link_name = "\u{1}_ZNK6isobus20CANLibManagedMessage25get_callback_message_sizeEv"]
    pub fn isobus_CANLibManagedMessage_get_callback_message_size(
        this: *const isobus_CANLibManagedMessage,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Constructor for the CANLibManagedMessage\n @param[in] CANPort The can channel index the message uses"]
    #[link_name = "\u{1}_ZN6isobus20CANLibManagedMessageC1Eh"]
    pub fn isobus_CANLibManagedMessage_CANLibManagedMessage(
        this: *mut isobus_CANLibManagedMessage,
        CANPort: u8,
    );
}
impl isobus_CANLibManagedMessage {
    #[inline]
    pub unsafe fn set_data(&mut self, dataBuffer: *const u8, length: u32) {
        isobus_CANLibManagedMessage_set_data(self, dataBuffer, length)
    }
    #[inline]
    pub unsafe fn set_data1(&mut self, dataByte: u8, insertPosition: u32) {
        isobus_CANLibManagedMessage_set_data1(self, dataByte, insertPosition)
    }
    #[inline]
    pub unsafe fn set_data_size(&mut self, length: u32) {
        isobus_CANLibManagedMessage_set_data_size(self, length)
    }
    #[inline]
    pub unsafe fn set_source_control_function(&mut self, value: *mut isobus_ControlFunction) {
        isobus_CANLibManagedMessage_set_source_control_function(self, value)
    }
    #[inline]
    pub unsafe fn set_destination_control_function(&mut self, value: *mut isobus_ControlFunction) {
        isobus_CANLibManagedMessage_set_destination_control_function(self, value)
    }
    #[inline]
    pub unsafe fn set_identifier(&mut self, value: isobus_CANIdentifier) {
        isobus_CANLibManagedMessage_set_identifier(self, value)
    }
    #[inline]
    pub unsafe fn get_callback_message_size(&self) -> u32 {
        isobus_CANLibManagedMessage_get_callback_message_size(self)
    }
    #[inline]
    pub unsafe fn new(CANPort: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_CANLibManagedMessage_CANLibManagedMessage(__bindgen_tmp.as_mut_ptr(), CANPort);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @brief Gets the size of the data payload\n @returns The length of the data payload"]
    #[link_name = "\u{1}_ZNK6isobus20CANLibManagedMessage15get_data_lengthEv"]
    pub fn isobus_CANLibManagedMessage_get_data_length(this: *mut ::std::os::raw::c_void) -> u32;
}
#[repr(C)]
pub struct isobus_CANLibProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @class CANLibProtocol\n\n @brief A base class for a CAN protocol\n @details CANLibProtocols are objects that manage different statful CAN protocols defined by\n ISO11783 and/or J1939. They could also be used for abitrary processing inside the CAN stack."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_CANLibProtocol {
    pub vtable_: *const isobus_CANLibProtocol__bindgen_vtable,
    #[doc = "< Keeps track of if the protocol has been initialized by the network manager"]
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_isobus_CANLibProtocol() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_CANLibProtocol> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_CANLibProtocol>(),
        16usize,
        concat!("Size of: ", stringify!(isobus_CANLibProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_CANLibProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_CANLibProtocol))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANLibProtocol),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns whether or not the protocol has been initialized by the network manager\n @returns true if the protocol has been initialized by the network manager"]
    #[link_name = "\u{1}_ZNK6isobus14CANLibProtocol18get_is_initializedEv"]
    pub fn isobus_CANLibProtocol_get_is_initialized(this: *const isobus_CANLibProtocol) -> bool;
}
extern "C" {
    #[doc = " @brief Gets a CAN protocol by index from the list of all protocols\n @param[in] index The index of the protocol to get from the list of protocols\n @param[out] returnedProtocol The returned protocol\n @returns true if a protocol was successfully returned, false if index was out of range"]
    #[link_name = "\u{1}_ZN6isobus14CANLibProtocol12get_protocolEjRPS0_"]
    pub fn isobus_CANLibProtocol_get_protocol(
        index: u32,
        returnedProtocol: *mut *mut isobus_CANLibProtocol,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the number of all created protocols\n @returns The number of all created protocols"]
    #[link_name = "\u{1}_ZN6isobus14CANLibProtocol20get_number_protocolsEv"]
    pub fn isobus_CANLibProtocol_get_number_protocols() -> u32;
}
extern "C" {
    #[doc = " @brief The base class constructor for a CANLibProtocol"]
    #[link_name = "\u{1}_ZN6isobus14CANLibProtocolC2Ev"]
    pub fn isobus_CANLibProtocol_CANLibProtocol(this: *mut isobus_CANLibProtocol);
}
impl isobus_CANLibProtocol {
    #[inline]
    pub unsafe fn get_is_initialized(&self) -> bool {
        isobus_CANLibProtocol_get_is_initialized(self)
    }
    #[inline]
    pub unsafe fn get_protocol(
        index: u32,
        returnedProtocol: *mut *mut isobus_CANLibProtocol,
    ) -> bool {
        isobus_CANLibProtocol_get_protocol(index, returnedProtocol)
    }
    #[inline]
    pub unsafe fn get_number_protocols() -> u32 {
        isobus_CANLibProtocol_get_number_protocols()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_CANLibProtocol_CANLibProtocol(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @brief The base class destructor for a CANLibProtocol"]
    #[link_name = "\u{1}_ZN6isobus14CANLibProtocolD1Ev"]
    pub fn isobus_CANLibProtocol_CANLibProtocol_destructor(this: *mut isobus_CANLibProtocol);
}
extern "C" {
    #[doc = " @brief A generic way to initialize a protocol\n @details The network manager will call a protocol's initialize function\n when it is first updated, if it has yet to be initialized."]
    #[link_name = "\u{1}_ZN6isobus14CANLibProtocol10initializeENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_CANLibProtocol_initialize(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
#[doc = " @class ExtendedTransportProtocolManager\n\n @brief A class that handles the ISO11783 extended transport protocol.\n @details This class handles transmission and reception of CAN messages more than 1785 bytes.\n Simply call send_can_message on the network manager with an appropriate data length,\n and the protocol will be automatically selected to be used."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_ExtendedTransportProtocolManager {
    pub _base: isobus_CANLibProtocol,
    #[doc = "< A list of all active TP sessions"]
    pub activeSessions: [u64; 3usize],
}
#[doc = "< Reserved, not to be used, but should be tolerated"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_Reserved:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 0;
#[doc = "< We are already in a session and can't support another"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_AlreadyInConnectionManagedSessionAndCannotSupportAnother : isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 1 ;
#[doc = "< Session must be aborted because the system needs resources"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_SystemResourcesNeededForAnotherTask : isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 2 ;
#[doc = "< General timeout"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_Timeout:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 3;
#[doc = "< A CTS was received while already processing the last CTS"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_ClearToSendReceivedWhenDataTransferInProgress : isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 4 ;
#[doc = "< Maxmimum retries for the data has been reached"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_MaximumRetransmitRequestLimitReached : isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 5 ;
#[doc = "< A data packet was received outside the proper state"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_UnexpectedDataTransferPacket : isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 6 ;
#[doc = "< Incorrect sequence number was received and cannot be recovered"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_BadSequenceNumber:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 7;
#[doc = "< Re-received a sequence number we've already processed"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_DuplicateSequenceNumber:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 8;
#[doc = "< EDPO Received in an invalid state"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_UnexpectedEDPOPacket:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 9;
#[doc = "< Unexpected PGN in received EDPO"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_UnexpectedEDPOPgn:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 10;
#[doc = "< Number of EDPO packets is > CTS"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_EDPONumberOfPacketsGreaterThanClearToSend : isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 11 ;
#[doc = "< EDPO offset was invalid"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_BadEDPOOffset:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 12;
#[doc = "< Don't use this. Use AnyOtherReason instead"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_DeprecatedReason:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 13;
#[doc = "< PGN in received ECTS doesn't match session"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_UnexpectedECTSPgn:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 14;
#[doc = "< ETP Can't support a message this large (CANMessage::ABSOLUTE_MAX_MESSAGE_LENGTH)"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_ECTSRequestedPacketsExceedsMessageSize : isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 15 ;
#[doc = "< Any other error not enumerated above, 0xFE"]
pub const isobus_ExtendedTransportProtocolManager_ConnectionAbortReason_AnyOtherReason:
    isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = 254;
#[doc = "  @brief A list of all defined abort reasons in ISO11783"]
pub type isobus_ExtendedTransportProtocolManager_ConnectionAbortReason = ::std::os::raw::c_int;
#[doc = "< Protocol session is not in progress"]
pub const isobus_ExtendedTransportProtocolManager_StateMachineState_None:
    isobus_ExtendedTransportProtocolManager_StateMachineState = 0;
#[doc = "< We are sending the request to send message"]
pub const isobus_ExtendedTransportProtocolManager_StateMachineState_RequestToSend:
    isobus_ExtendedTransportProtocolManager_StateMachineState = 1;
#[doc = "< We are waiting for a clear to send message"]
pub const isobus_ExtendedTransportProtocolManager_StateMachineState_WaitForClearToSend:
    isobus_ExtendedTransportProtocolManager_StateMachineState = 2;
#[doc = "< We are receiving data packets"]
pub const isobus_ExtendedTransportProtocolManager_StateMachineState_RxDataSession:
    isobus_ExtendedTransportProtocolManager_StateMachineState = 3;
#[doc = "< We are sending clear to send message"]
pub const isobus_ExtendedTransportProtocolManager_StateMachineState_ClearToSend:
    isobus_ExtendedTransportProtocolManager_StateMachineState = 4;
#[doc = "< We are waiting for an EDPO message"]
pub const isobus_ExtendedTransportProtocolManager_StateMachineState_WaitForExtendedDataPacketOffset : isobus_ExtendedTransportProtocolManager_StateMachineState = 5 ;
#[doc = "< We are transmitting EDPOs and data packets"]
pub const isobus_ExtendedTransportProtocolManager_StateMachineState_TxDataSession:
    isobus_ExtendedTransportProtocolManager_StateMachineState = 6;
#[doc = "< We are waiting for an end of message acknowledgement"]
pub const isobus_ExtendedTransportProtocolManager_StateMachineState_WaitForEndOfMessageAcknowledge : isobus_ExtendedTransportProtocolManager_StateMachineState = 7 ;
#[doc = " @brief The states that a ETP session could be in. Used for the internal state machine."]
pub type isobus_ExtendedTransportProtocolManager_StateMachineState = ::std::os::raw::c_int;
#[doc = " @class ExtendedTransportProtocolSession\n\n @brief A storage object to keep track of session information internally"]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession {
    #[doc = "< The state machine state for this session"]
    pub state: isobus_ExtendedTransportProtocolManager_StateMachineState,
    #[doc = "< A CAN message is used in the session to represent and store data like PGN"]
    pub sessionMessage: isobus_CANLibManagedMessage,
    #[doc = "< A callback that is to be called when the session is completed"]
    pub sessionCompleteCallback: isobus_TransmitCompleteCallback,
    #[doc = "< A callback that might be used to get chunks of data to send"]
    pub frameChunkCallback: isobus_DataChunkCallback,
    #[doc = "< A generic context variable that helps identify what object callbacks are destined for. Can be nullptr"]
    pub parent: *mut ::std::os::raw::c_void,
    #[doc = "< A timestamp used to track session timeouts"]
    pub timestamp_ms: u32,
    #[doc = "< The last processed sequence number for this set of packets"]
    pub lastPacketNumber: u32,
    #[doc = "< The total number of packets to receive or send in this session"]
    pub packetCount: u32,
    #[doc = "< The total processed packet count for the whole session so far"]
    pub processedPacketsThisSession: u32,
    #[doc = "< Represents Tx or Rx session"]
    pub sessionDirection:
        isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession_Direction,
}
#[doc = "< We are transmitting a message"]
pub const isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession_Direction_Transmit : isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession_Direction = 0 ;
#[doc = "< We are receving a message"]
pub const isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession_Direction_Receive : isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession_Direction = 1 ;
#[doc = " @brief Enumerates the possible session directions, Rx or Tx"]
pub type isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession_Direction =
    ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession() {
    const UNINIT: ::std::mem::MaybeUninit<
        isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession,
        >(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionMessage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(sessionMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionCompleteCallback) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(sessionCompleteCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameChunkCallback) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(frameChunkCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_ms) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(timestamp_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastPacketNumber) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(lastPacketNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetCount) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(packetCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processedPacketsThisSession) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(processedPacketsThisSession)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionDirection) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolSession),
            "::",
            stringify!(sessionDirection)
        )
    );
}
#[doc = "< The max payload this protocol can support"]
pub const isobus_ExtendedTransportProtocolManager_MAX_PROTOCOL_DATA_LENGTH: u32 = 117440505;
#[doc = "< The min payload this protocol can support"]
pub const isobus_ExtendedTransportProtocolManager_MIN_PROTOCOL_DATA_LENGTH: u32 = 1786;
#[doc = "< The Tr timeout as defined by the standard"]
pub const isobus_ExtendedTransportProtocolManager_TR_TIMEOUT_MS: u32 = 200;
#[doc = "< The t1 timeout as defined by the standard"]
pub const isobus_ExtendedTransportProtocolManager_T1_TIMEOUT_MS: u32 = 750;
#[doc = "< The t2/t3 timeouts as defined by the standard"]
pub const isobus_ExtendedTransportProtocolManager_T2_3_TIMEOUT_MS: u32 = 1250;
#[doc = "< The Th timout as defined by the standard"]
pub const isobus_ExtendedTransportProtocolManager_TH_TIMEOUT_MS: u32 = 500;
#[doc = "< The multiplexor for the extended request to send message"]
pub const isobus_ExtendedTransportProtocolManager_EXTENDED_REQUEST_TO_SEND_MULTIPLEXOR: u8 = 20;
#[doc = "< The multiplexor for the extended clear to send message"]
pub const isobus_ExtendedTransportProtocolManager_EXTENDED_CLEAR_TO_SEND_MULTIPLEXOR: u8 = 21;
#[doc = "< The multiplexor for the extended data packet offset message"]
pub const isobus_ExtendedTransportProtocolManager_EXTENDED_DATA_PACKET_OFFSET_MULTIPLEXOR: u8 = 22;
#[doc = "< Multiplexor for the extended end of message acknowledgement message"]
pub const isobus_ExtendedTransportProtocolManager_EXTENDED_END_OF_MESSAGE_ACKNOWLEDGEMENT: u8 = 23;
#[doc = "< Multiplexor for the extended connection abort message"]
pub const isobus_ExtendedTransportProtocolManager_EXTENDED_CONNECTION_ABORT_MULTIPLEXOR: u8 = 255;
#[doc = "< The number of payload bytes per frame minus overhead of sequence number"]
pub const isobus_ExtendedTransportProtocolManager_PROTOCOL_BYTES_PER_FRAME: u8 = 7;
#[doc = "< The index of the sequence number in a frame"]
pub const isobus_ExtendedTransportProtocolManager_SEQUENCE_NUMBER_DATA_INDEX: u8 = 0;
#[test]
fn bindgen_test_layout_isobus_ExtendedTransportProtocolManager() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_ExtendedTransportProtocolManager> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_ExtendedTransportProtocolManager>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(isobus_ExtendedTransportProtocolManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_ExtendedTransportProtocolManager>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_ExtendedTransportProtocolManager)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activeSessions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ExtendedTransportProtocolManager),
            "::",
            stringify!(activeSessions)
        )
    );
}
extern "C" {
    #[doc = " @brief A generic way for a protocol to process a received message\n @param[in] message A received CAN message\n @param[in] parent Provides the context to the actual TP manager object"]
    #[link_name = "\u{1}_ZN6isobus32ExtendedTransportProtocolManager15process_messageEPNS_10CANMessageEPv"]
    pub fn isobus_ExtendedTransportProtocolManager_process_message1(
        message: *mut isobus_CANMessage,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief The constructor for the TransportProtocolManager"]
    #[link_name = "\u{1}_ZN6isobus32ExtendedTransportProtocolManagerC1Ev"]
    pub fn isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolManager(
        this: *mut isobus_ExtendedTransportProtocolManager,
    );
}
impl isobus_ExtendedTransportProtocolManager {
    #[inline]
    pub unsafe fn process_message(
        message: *mut isobus_CANMessage,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_ExtendedTransportProtocolManager_process_message1(message, parent)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolManager(
            __bindgen_tmp.as_mut_ptr(),
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @brief The destructor for the TransportProtocolManager"]
    #[link_name = "\u{1}_ZN6isobus32ExtendedTransportProtocolManagerD1Ev"]
    pub fn isobus_ExtendedTransportProtocolManager_ExtendedTransportProtocolManager_destructor(
        this: *mut isobus_ExtendedTransportProtocolManager,
    );
}
extern "C" {
    #[doc = " @brief The protocol's initializer function"]
    #[link_name = "\u{1}_ZN6isobus32ExtendedTransportProtocolManager10initializeENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_ExtendedTransportProtocolManager_initialize(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
extern "C" {
    #[doc = " @brief A generic way for a protocol to process a received message\n @param[in] message A received CAN message"]
    #[link_name = "\u{1}_ZN6isobus32ExtendedTransportProtocolManager15process_messageEPNS_10CANMessageE"]
    pub fn isobus_ExtendedTransportProtocolManager_process_message(
        this: *mut ::std::os::raw::c_void,
        message: *mut isobus_CANMessage,
    );
}
extern "C" {
    #[doc = " @brief The network manager calls this to see if the protocol can accept a long CAN message for processing\n @param[in] parameterGroupNumber The PGN of the message\n @param[in] data The data to be sent\n @param[in] messageLength The length of the data to be sent\n @param[in] source The source control function\n @param[in] destination The destination control function\n @param[in] transmitCompleteCallback A callback for when the protocol completes its work\n @param[in] parentPointer A generic context object for the tx complete and chunk callbacks\n @param[in] frameChunkCallback A callback to get some data to send\n @returns true if the message was accepted by the protocol for processing"]
    #[link_name = "\u{1}_ZN6isobus32ExtendedTransportProtocolManager25protocol_transmit_messageEjPKhjPNS_15ControlFunctionES4_PFvjjPNS_23InternalControlFunctionES4_bPvES7_PFbjjjPhS7_E"]
    pub fn isobus_ExtendedTransportProtocolManager_protocol_transmit_message(
        this: *mut ::std::os::raw::c_void,
        parameterGroupNumber: u32,
        data: *const u8,
        messageLength: u32,
        source: *mut isobus_ControlFunction,
        destination: *mut isobus_ControlFunction,
        transmitCompleteCallback: isobus_TransmitCompleteCallback,
        parentPointer: *mut ::std::os::raw::c_void,
        frameChunkCallback: isobus_DataChunkCallback,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Updates the protocol cyclically"]
    #[link_name = "\u{1}_ZN6isobus32ExtendedTransportProtocolManager6updateENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_ExtendedTransportProtocolManager_update(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
#[doc = " @class HardwareInterfaceCANFrame\n\n @brief A CAN frame for interfacing with a hardware layer, like socket CAN or other interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_HardwareInterfaceCANFrame {
    #[doc = "< A microsecond timestamp"]
    pub timestamp_us: u64,
    #[doc = "< The 32 bit identifier of the frame"]
    pub identifier: u32,
    #[doc = "< The CAN channel index associated with the frame"]
    pub channel: u8,
    #[doc = "< The data payload of the frame"]
    pub data: [u8; 8usize],
    #[doc = "< The length of the data used in the frame"]
    pub dataLength: u8,
    #[doc = "< Denotes if the frame is extended format"]
    pub isExtendedFrame: bool,
}
#[test]
fn bindgen_test_layout_isobus_HardwareInterfaceCANFrame() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_HardwareInterfaceCANFrame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_HardwareInterfaceCANFrame>(),
        24usize,
        concat!("Size of: ", stringify!(isobus_HardwareInterfaceCANFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_HardwareInterfaceCANFrame>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_HardwareInterfaceCANFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_HardwareInterfaceCANFrame),
            "::",
            stringify!(timestamp_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_HardwareInterfaceCANFrame),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_HardwareInterfaceCANFrame),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_HardwareInterfaceCANFrame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLength) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_HardwareInterfaceCANFrame),
            "::",
            stringify!(dataLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isExtendedFrame) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_HardwareInterfaceCANFrame),
            "::",
            stringify!(isExtendedFrame)
        )
    );
}
pub const isobus_CANLibParameterGroupNumber_Any: isobus_CANLibParameterGroupNumber = 0;
pub const isobus_CANLibParameterGroupNumber_DiagnosticMessage22: isobus_CANLibParameterGroupNumber =
    49920;
pub const isobus_CANLibParameterGroupNumber_ExtendedTransportProtocolDataTransfer:
    isobus_CANLibParameterGroupNumber = 50944;
pub const isobus_CANLibParameterGroupNumber_ExtendedTransportProtocolConnectionManagement:
    isobus_CANLibParameterGroupNumber = 51200;
pub const isobus_CANLibParameterGroupNumber_RequestForRepetitionRate:
    isobus_CANLibParameterGroupNumber = 52224;
pub const isobus_CANLibParameterGroupNumber_DiagnosticMessage13: isobus_CANLibParameterGroupNumber =
    57088;
pub const isobus_CANLibParameterGroupNumber_VirtualTerminalToECU:
    isobus_CANLibParameterGroupNumber = 58880;
pub const isobus_CANLibParameterGroupNumber_ECUtoVirtualTerminal:
    isobus_CANLibParameterGroupNumber = 59136;
pub const isobus_CANLibParameterGroupNumber_Acknowledge: isobus_CANLibParameterGroupNumber = 59392;
pub const isobus_CANLibParameterGroupNumber_ParameterGroupNumberRequest:
    isobus_CANLibParameterGroupNumber = 59904;
pub const isobus_CANLibParameterGroupNumber_TransportProtocolData:
    isobus_CANLibParameterGroupNumber = 60160;
pub const isobus_CANLibParameterGroupNumber_TransportProtocolCommand:
    isobus_CANLibParameterGroupNumber = 60416;
pub const isobus_CANLibParameterGroupNumber_AddressClaim: isobus_CANLibParameterGroupNumber = 60928;
pub const isobus_CANLibParameterGroupNumber_ProprietaryA: isobus_CANLibParameterGroupNumber = 61184;
pub const isobus_CANLibParameterGroupNumber_ProductIdentification:
    isobus_CANLibParameterGroupNumber = 64653;
pub const isobus_CANLibParameterGroupNumber_DiagnosticProtocolIdentification:
    isobus_CANLibParameterGroupNumber = 64818;
pub const isobus_CANLibParameterGroupNumber_WorkingSetMaster: isobus_CANLibParameterGroupNumber =
    65037;
pub const isobus_CANLibParameterGroupNumber_ECUIdentificationInformation:
    isobus_CANLibParameterGroupNumber = 64965;
pub const isobus_CANLibParameterGroupNumber_DiagnosticMessage1: isobus_CANLibParameterGroupNumber =
    65226;
pub const isobus_CANLibParameterGroupNumber_DiagnosticMessage2: isobus_CANLibParameterGroupNumber =
    65227;
pub const isobus_CANLibParameterGroupNumber_DiagnosticMessage3: isobus_CANLibParameterGroupNumber =
    65228;
pub const isobus_CANLibParameterGroupNumber_DiagnosticMessage11: isobus_CANLibParameterGroupNumber =
    65235;
pub const isobus_CANLibParameterGroupNumber_SoftwareIdentification:
    isobus_CANLibParameterGroupNumber = 65242;
#[doc = " @brief PGNs commonly used by the CAN stack"]
pub type isobus_CANLibParameterGroupNumber = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @brief The abstraction layer between the hardware and the stack\n @param[in] frame The frame to transmit from the hardware"]
    #[link_name = "\u{1}_ZN6isobus28send_can_message_to_hardwareENS_25HardwareInterfaceCANFrameE"]
    pub fn isobus_send_can_message_to_hardware(frame: isobus_HardwareInterfaceCANFrame) -> bool;
}
#[doc = " @class InternalControlFunction\n\n @brief Describes an internal ECU's NAME and address data. Used to send CAN messages.\n @details This class is used to define your own ECU's NAME, and is used to transmit messages.\n Each instance of this class will claim a unique address on the bus, and can be used to\n send messages."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_InternalControlFunction {
    pub _base: isobus_ControlFunction,
    #[doc = "< The address claimer for this ICF"]
    pub stateMachine: isobus_AddressClaimStateMachine,
    #[doc = "< Tracks if this object has changed address since the last update"]
    pub objectChangedAddressSinceLastUpdate: bool,
}
extern "C" {
    #[doc = "< A list of all internal control functions that exist"]
    #[link_name = "\u{1}_ZN6isobus23InternalControlFunction27internalControlFunctionListE"]
    pub static mut isobus_InternalControlFunction_internalControlFunctionList: u8;
}
extern "C" {
    #[doc = "< Lets the network manager know if any ICF changed address since the last update"]
    #[link_name = "\u{1}_ZN6isobus23InternalControlFunction17anyChangedAddressE"]
    pub static mut isobus_InternalControlFunction_anyChangedAddress: bool;
}
#[test]
fn bindgen_test_layout_isobus_InternalControlFunction() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_InternalControlFunction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_InternalControlFunction>(),
        56usize,
        concat!("Size of: ", stringify!(isobus_InternalControlFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_InternalControlFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_InternalControlFunction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateMachine) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_InternalControlFunction),
            "::",
            stringify!(stateMachine)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).objectChangedAddressSinceLastUpdate) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_InternalControlFunction),
            "::",
            stringify!(objectChangedAddressSinceLastUpdate)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns a an internal control function from the list of all internal control functions\n @param[in] index The index in the list internalControlFunctionList from which to get an ICF\n @returns The requested internal control function or `nullptr` if the index is out of range"]
    #[link_name = "\u{1}_ZN6isobus23InternalControlFunction29get_internal_control_functionEj"]
    pub fn isobus_InternalControlFunction_get_internal_control_function(
        index: u32,
    ) -> *mut isobus_InternalControlFunction;
}
extern "C" {
    #[doc = " @brief Returns the number of internal control functions that exist"]
    #[link_name = "\u{1}_ZN6isobus23InternalControlFunction37get_number_internal_control_functionsEv"]
    pub fn isobus_InternalControlFunction_get_number_internal_control_functions() -> u32;
}
extern "C" {
    #[doc = " @brief Lets network manager know a control function changed address recently\n @details These tell the network manager when the address table needs to be explicitly\n updated for an internal control function claiming a new address.\n Other CF types are handled in Rx message processing."]
    #[link_name = "\u{1}_ZN6isobus23InternalControlFunction49get_any_internal_control_function_changed_addressENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_InternalControlFunction_get_any_internal_control_function_changed_address(
        arg1: isobus_CANLibBadge,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Used to determine if the internal control function changed address since the last network manager update\n @returns true if the ICF changed address since the last network manager update"]
    #[link_name = "\u{1}_ZNK6isobus23InternalControlFunction37get_changed_address_since_last_updateENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_InternalControlFunction_get_changed_address_since_last_update(
        this: *const isobus_InternalControlFunction,
        arg1: isobus_CANLibBadge,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Updates all address claim state machines"]
    #[link_name = "\u{1}_ZN6isobus23InternalControlFunction23update_address_claimingENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_InternalControlFunction_update_address_claiming(arg1: isobus_CANLibBadge);
}
extern "C" {
    #[doc = " @brief Constructor for an internal control function\n @param[in] desiredName The NAME for this control function to claim as\n @param[in] preferredAddress The preferred NAME for this control function\n @param[in] CANPort The CAN channel index for this control function to use"]
    #[link_name = "\u{1}_ZN6isobus23InternalControlFunctionC1ENS_4NAMEEhh"]
    pub fn isobus_InternalControlFunction_InternalControlFunction(
        this: *mut isobus_InternalControlFunction,
        desiredName: isobus_NAME,
        preferredAddress: u8,
        CANPort: u8,
    );
}
impl isobus_InternalControlFunction {
    #[inline]
    pub unsafe fn get_internal_control_function(index: u32) -> *mut isobus_InternalControlFunction {
        isobus_InternalControlFunction_get_internal_control_function(index)
    }
    #[inline]
    pub unsafe fn get_number_internal_control_functions() -> u32 {
        isobus_InternalControlFunction_get_number_internal_control_functions()
    }
    #[inline]
    pub unsafe fn get_any_internal_control_function_changed_address(
        arg1: isobus_CANLibBadge,
    ) -> bool {
        isobus_InternalControlFunction_get_any_internal_control_function_changed_address(arg1)
    }
    #[inline]
    pub unsafe fn get_changed_address_since_last_update(&self, arg1: isobus_CANLibBadge) -> bool {
        isobus_InternalControlFunction_get_changed_address_since_last_update(self, arg1)
    }
    #[inline]
    pub unsafe fn update_address_claiming(arg1: isobus_CANLibBadge) {
        isobus_InternalControlFunction_update_address_claiming(arg1)
    }
    #[inline]
    pub unsafe fn new(desiredName: isobus_NAME, preferredAddress: u8, CANPort: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_InternalControlFunction_InternalControlFunction(
            __bindgen_tmp.as_mut_ptr(),
            desiredName,
            preferredAddress,
            CANPort,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @brief Destructor for an internal control function"]
    #[link_name = "\u{1}_ZN6isobus23InternalControlFunctionD1Ev"]
    pub fn isobus_InternalControlFunction_InternalControlFunction_destructor(
        this: *mut isobus_InternalControlFunction,
    );
}
#[doc = " @class NAMEFilter\n\n @brief A class that associates a NAME parameter with a value of that parameter.\n @details This class is used to match a partner control function with specific criteria that\n defines it. Use these to define what device you want to talk to."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_NAMEFilter {
    #[doc = "< The NAME component to filter against"]
    pub parameter: isobus_NAME_NAMEParameters,
    #[doc = "< The value of the data associated with the filter component"]
    pub value: u32,
}
#[test]
fn bindgen_test_layout_isobus_NAMEFilter() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_NAMEFilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_NAMEFilter>(),
        8usize,
        concat!("Size of: ", stringify!(isobus_NAMEFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_NAMEFilter>(),
        4usize,
        concat!("Alignment of ", stringify!(isobus_NAMEFilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_NAMEFilter),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_NAMEFilter),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " @brief Returns the parameter data associated with this filter\n @returns The parameter/NAME component associated with this filter"]
    #[link_name = "\u{1}_ZNK6isobus10NAMEFilter13get_parameterEv"]
    pub fn isobus_NAMEFilter_get_parameter(
        this: *const isobus_NAMEFilter,
    ) -> isobus_NAME_NAMEParameters;
}
extern "C" {
    #[doc = " @brief Returns the value associated with this filter\n @returns The data associated with this filter component"]
    #[link_name = "\u{1}_ZNK6isobus10NAMEFilter9get_valueEv"]
    pub fn isobus_NAMEFilter_get_value(this: *const isobus_NAMEFilter) -> u32;
}
extern "C" {
    #[doc = " @brief Returns true if a NAME matches this filter class's components\n @returns true if a NAME matches this filter class's components"]
    #[link_name = "\u{1}_ZN6isobus10NAMEFilter25check_name_matches_filterERKNS_4NAMEE"]
    pub fn isobus_NAMEFilter_check_name_matches_filter(
        this: *mut isobus_NAMEFilter,
        nameToCompare: *const isobus_NAME,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Constructor for the NAMEFilter\n @param[in] nameParameter The component of the NAME to filter on\n @param[in] parameterMatchValue The value to match with the nameParameter"]
    #[link_name = "\u{1}_ZN6isobus10NAMEFilterC1ENS_4NAME14NAMEParametersEj"]
    pub fn isobus_NAMEFilter_NAMEFilter(
        this: *mut isobus_NAMEFilter,
        nameParameter: isobus_NAME_NAMEParameters,
        parameterMatchValue: u32,
    );
}
impl isobus_NAMEFilter {
    #[inline]
    pub unsafe fn get_parameter(&self) -> isobus_NAME_NAMEParameters {
        isobus_NAMEFilter_get_parameter(self)
    }
    #[inline]
    pub unsafe fn get_value(&self) -> u32 {
        isobus_NAMEFilter_get_value(self)
    }
    #[inline]
    pub unsafe fn check_name_matches_filter(&mut self, nameToCompare: *const isobus_NAME) -> bool {
        isobus_NAMEFilter_check_name_matches_filter(self, nameToCompare)
    }
    #[inline]
    pub unsafe fn new(nameParameter: isobus_NAME_NAMEParameters, parameterMatchValue: u32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_NAMEFilter_NAMEFilter(
            __bindgen_tmp.as_mut_ptr(),
            nameParameter,
            parameterMatchValue,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @class CANNetworkConfiguration\n\n @brief A class that defines stack-wide configuration data. You can set the values in there\n to suit your specific memory constraints."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_CANNetworkConfiguration {
    pub _address: u8,
}
#[doc = "< The default time between BAM frames, as defined by J1939"]
pub const isobus_CANNetworkConfiguration_DEFAULT_BAM_PACKET_DELAY_TIME_MS: u8 = 50;
extern "C" {
    #[doc = "< The max number of TP sessions allowed"]
    #[link_name = "\u{1}_ZN6isobus23CANNetworkConfiguration34maxNumberTransportProtocolSessionsE"]
    pub static mut isobus_CANNetworkConfiguration_maxNumberTransportProtocolSessions: u32;
}
extern "C" {
    #[doc = "< The configurable time between BAM frames"]
    #[link_name = "\u{1}_ZN6isobus23CANNetworkConfiguration44minimumTimeBetweenTransportProtocolBAMFramesE"]
    pub static mut isobus_CANNetworkConfiguration_minimumTimeBetweenTransportProtocolBAMFrames: u32;
}
#[test]
fn bindgen_test_layout_isobus_CANNetworkConfiguration() {
    assert_eq!(
        ::std::mem::size_of::<isobus_CANNetworkConfiguration>(),
        1usize,
        concat!("Size of: ", stringify!(isobus_CANNetworkConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_CANNetworkConfiguration>(),
        1usize,
        concat!("Alignment of ", stringify!(isobus_CANNetworkConfiguration))
    );
}
extern "C" {
    #[doc = " @brief Configures the max number of concurrent TP sessions to provide a RAM limit for TP sessions\n @param[in] value The max allowable number of TP sessions"]
    #[link_name = "\u{1}_ZN6isobus23CANNetworkConfiguration41set_max_number_transport_protcol_sessionsEj"]
    pub fn isobus_CANNetworkConfiguration_set_max_number_transport_protcol_sessions(value: u32);
}
extern "C" {
    #[doc = " @brief Returns the max number of concurrent TP sessions\n @returns The max number of concurrent TP sessions"]
    #[link_name = "\u{1}_ZN6isobus23CANNetworkConfiguration41get_max_number_transport_protcol_sessionsEv"]
    pub fn isobus_CANNetworkConfiguration_get_max_number_transport_protcol_sessions() -> u32;
}
extern "C" {
    #[doc = " @brief Sets the minimum time to wait between sending BAM frames\n @details The acceptable range as defined by ISO-11783 is 10 to 200 ms.\n This is a minumum time, so if you set it to some value, like 10 ms, the\n stack will attempt to transmit it as close to that time as it can, but it is\n not possible to 100% ensure it.\n @param[in] value The minimum time to wait between sending BAM frames"]
    #[link_name = "\u{1}_ZN6isobus23CANNetworkConfiguration54set_minimum_time_between_transport_protocol_bam_framesEj"]
    pub fn isobus_CANNetworkConfiguration_set_minimum_time_between_transport_protocol_bam_frames(
        value: u32,
    );
}
extern "C" {
    #[doc = " @brief Returns the minimum time to wait between sending BAM frames\n @returns The minimum time to wait between sending BAM frames"]
    #[link_name = "\u{1}_ZN6isobus23CANNetworkConfiguration54get_minimum_time_between_transport_protocol_bam_framesEv"]
    pub fn isobus_CANNetworkConfiguration_get_minimum_time_between_transport_protocol_bam_frames(
    ) -> u32;
}
extern "C" {
    #[doc = " @brief The constructor for the configuration object"]
    #[link_name = "\u{1}_ZN6isobus23CANNetworkConfigurationC1Ev"]
    pub fn isobus_CANNetworkConfiguration_CANNetworkConfiguration(
        this: *mut isobus_CANNetworkConfiguration,
    );
}
extern "C" {
    #[doc = " @brief The destructor for the configuration object"]
    #[link_name = "\u{1}_ZN6isobus23CANNetworkConfigurationD1Ev"]
    pub fn isobus_CANNetworkConfiguration_CANNetworkConfiguration_destructor(
        this: *mut isobus_CANNetworkConfiguration,
    );
}
impl isobus_CANNetworkConfiguration {
    #[inline]
    pub unsafe fn set_max_number_transport_protcol_sessions(value: u32) {
        isobus_CANNetworkConfiguration_set_max_number_transport_protcol_sessions(value)
    }
    #[inline]
    pub unsafe fn get_max_number_transport_protcol_sessions() -> u32 {
        isobus_CANNetworkConfiguration_get_max_number_transport_protcol_sessions()
    }
    #[inline]
    pub unsafe fn set_minimum_time_between_transport_protocol_bam_frames(value: u32) {
        isobus_CANNetworkConfiguration_set_minimum_time_between_transport_protocol_bam_frames(value)
    }
    #[inline]
    pub unsafe fn get_minimum_time_between_transport_protocol_bam_frames() -> u32 {
        isobus_CANNetworkConfiguration_get_minimum_time_between_transport_protocol_bam_frames()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_CANNetworkConfiguration_CANNetworkConfiguration(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        isobus_CANNetworkConfiguration_CANNetworkConfiguration_destructor(self)
    }
}
#[doc = " @class TransportProtocolManager\n\n @brief A class that handles the ISO11783/J1939 transport protocol.\n @details This class handles transmission and reception of CAN messages up to 1785 bytes.\n Both broadcast and connection mode are supported. Simply call send_can_message on the\n network manager with an appropriate data length, and the protocol will be automatically\n selected to be used. As a note, use of BAM is discouraged, as it has profound\n packet timing implications for your application, and is limited to only 1 active session at a time.\n That session could be busy if you are using DM1 or any other BAM protocol, causing intermittant\n transmit failures from this class. This is not a bug, rather a limitation of the protocol\n definition."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_TransportProtocolManager {
    pub _base: isobus_CANLibProtocol,
    #[doc = "< A list of all active TP sessions"]
    pub activeSessions: [u64; 3usize],
}
#[doc = "< Protocol session is not in progress"]
pub const isobus_TransportProtocolManager_StateMachineState_None:
    isobus_TransportProtocolManager_StateMachineState = 0;
#[doc = "< We are sending clear to send message"]
pub const isobus_TransportProtocolManager_StateMachineState_ClearToSend:
    isobus_TransportProtocolManager_StateMachineState = 1;
#[doc = "< Rx data session is in progress"]
pub const isobus_TransportProtocolManager_StateMachineState_RxDataSession:
    isobus_TransportProtocolManager_StateMachineState = 2;
#[doc = "< We are sending the request to send message"]
pub const isobus_TransportProtocolManager_StateMachineState_RequestToSend:
    isobus_TransportProtocolManager_StateMachineState = 3;
#[doc = "< We are waiting for a clear to send message"]
pub const isobus_TransportProtocolManager_StateMachineState_WaitForClearToSend:
    isobus_TransportProtocolManager_StateMachineState = 4;
#[doc = "< We are sending the broadcast announce message (BAM)"]
pub const isobus_TransportProtocolManager_StateMachineState_BroadcastAnnounce:
    isobus_TransportProtocolManager_StateMachineState = 5;
#[doc = "< A Tx data session is in progress"]
pub const isobus_TransportProtocolManager_StateMachineState_TxDataSession:
    isobus_TransportProtocolManager_StateMachineState = 6;
#[doc = "< We are waiting for an end of message acknowledgement"]
pub const isobus_TransportProtocolManager_StateMachineState_WaitForEndOfMessageAcknowledge:
    isobus_TransportProtocolManager_StateMachineState = 7;
#[doc = " @brief The states that a TP session could be in. Used for the internal state machine."]
pub type isobus_TransportProtocolManager_StateMachineState = ::std::os::raw::c_int;
#[doc = " @class TransportProtocolSession\n\n @brief A storage object to keep track of session information internally"]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_TransportProtocolManager_TransportProtocolSession {
    #[doc = "< The state machine state for this session"]
    pub state: isobus_TransportProtocolManager_StateMachineState,
    #[doc = "< A CAN message is used in the session to represent and store data like PGN"]
    pub sessionMessage: isobus_CANLibManagedMessage,
    #[doc = "< A callback that is to be called when the session is completed"]
    pub sessionCompleteCallback: isobus_TransmitCompleteCallback,
    #[doc = "< A callback that might be used to get chunks of data to send"]
    pub frameChunkCallback: isobus_DataChunkCallback,
    #[doc = "< A generic context variable that helps identify what object callbacks are destined for. Can be nullptr"]
    pub parent: *mut ::std::os::raw::c_void,
    #[doc = "< A timestamp used to track session timeouts"]
    pub timestamp_ms: u32,
    #[doc = "< The last processed sequence number for this set of packets"]
    pub lastPacketNumber: u16,
    #[doc = "< The total number of packets to receive or send in this session"]
    pub packetCount: u8,
    #[doc = "< The total processed packet count for the whole session so far"]
    pub processedPacketsThisSession: u8,
    #[doc = "< The max packets that can be sent per CTS as indicated by the RTS message"]
    pub clearToSendPacketMax: u8,
    #[doc = "< Represents Tx or Rx session"]
    pub sessionDirection: isobus_TransportProtocolManager_TransportProtocolSession_Direction,
}
#[doc = "< We are transmitting a message"]
pub const isobus_TransportProtocolManager_TransportProtocolSession_Direction_Transmit:
    isobus_TransportProtocolManager_TransportProtocolSession_Direction = 0;
#[doc = "< We are receving a message"]
pub const isobus_TransportProtocolManager_TransportProtocolSession_Direction_Receive:
    isobus_TransportProtocolManager_TransportProtocolSession_Direction = 1;
#[doc = " @brief Enumerates the possible session directions, Rx or Tx"]
pub type isobus_TransportProtocolManager_TransportProtocolSession_Direction = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_isobus_TransportProtocolManager_TransportProtocolSession() {
    const UNINIT: ::std::mem::MaybeUninit<
        isobus_TransportProtocolManager_TransportProtocolSession,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_TransportProtocolManager_TransportProtocolSession>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_TransportProtocolManager_TransportProtocolSession>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionMessage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(sessionMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionCompleteCallback) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(sessionCompleteCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameChunkCallback) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(frameChunkCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_ms) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(timestamp_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastPacketNumber) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(lastPacketNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetCount) as usize - ptr as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(packetCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processedPacketsThisSession) as usize - ptr as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(processedPacketsThisSession)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clearToSendPacketMax) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(clearToSendPacketMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionDirection) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager_TransportProtocolSession),
            "::",
            stringify!(sessionDirection)
        )
    );
}
#[doc = "< Reserved, not to be used, but should be tolerated"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_Reserved:
    isobus_TransportProtocolManager_ConnectionAbortReason = 0;
#[doc = "< We are already in a connection mode session and can't support another"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_AlreadyInCMSession:
    isobus_TransportProtocolManager_ConnectionAbortReason = 1;
#[doc = "< Session must be aborted because the system needs resources"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_SystemResourcesNeeded:
    isobus_TransportProtocolManager_ConnectionAbortReason = 2;
#[doc = "< General timeout"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_Timeout:
    isobus_TransportProtocolManager_ConnectionAbortReason = 3;
#[doc = "< A CTS was received while already processing the last CTS"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_ClearToSendReceivedWhileTransferInProgress : isobus_TransportProtocolManager_ConnectionAbortReason = 4 ;
#[doc = "< Maxmimum retries for the data has been reached"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_MaximumRetransmitRequestLimitReached : isobus_TransportProtocolManager_ConnectionAbortReason = 5 ;
#[doc = "< A data packet was received outside the proper state"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_UnexpectedDataTransferPacketReceived : isobus_TransportProtocolManager_ConnectionAbortReason = 6 ;
#[doc = "< Incorrect sequence number was received and cannot be recovered"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_BadSequenceNumber:
    isobus_TransportProtocolManager_ConnectionAbortReason = 7;
#[doc = "< Re-received a sequence number we've already processed"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_DuplicateSequenceNumber:
    isobus_TransportProtocolManager_ConnectionAbortReason = 8;
#[doc = "< TP Can't support a message this large (>1785 bytes)"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_TotalMessageSizeTooBig:
    isobus_TransportProtocolManager_ConnectionAbortReason = 9;
#[doc = "< Any other error not enumerated above, 0xFE"]
pub const isobus_TransportProtocolManager_ConnectionAbortReason_AnyOtherError:
    isobus_TransportProtocolManager_ConnectionAbortReason = 250;
#[doc = "  @brief A list of all defined abort reasons in ISO11783"]
pub type isobus_TransportProtocolManager_ConnectionAbortReason = u8;
#[doc = "< TP.CM_RTS Multiplexor"]
pub const isobus_TransportProtocolManager_REQUEST_TO_SEND_MULTIPLEXOR: u32 = 16;
#[doc = "< TP.CM_CTS Multiplexor"]
pub const isobus_TransportProtocolManager_CLEAR_TO_SEND_MULTIPLEXOR: u32 = 17;
#[doc = "< TP.CM_EOM_ACK Multiplexor"]
pub const isobus_TransportProtocolManager_END_OF_MESSAGE_ACKNOWLEDGE_MULTIPLEXOR: u32 = 19;
#[doc = "< TP.BAM Multiplexor"]
pub const isobus_TransportProtocolManager_BROADCAST_ANNOUNCE_MESSAGE_MULTIPLEXOR: u32 = 32;
#[doc = "< Abort multiplexor"]
pub const isobus_TransportProtocolManager_CONNECTION_ABORT_MULTIPLEXOR: u32 = 255;
#[doc = "< The max number of bytes that this protocol can transfer"]
pub const isobus_TransportProtocolManager_MAX_PROTOCOL_DATA_LENGTH: u32 = 1785;
#[doc = "< The t1 timeout as defined by the standard"]
pub const isobus_TransportProtocolManager_T1_TIMEOUT_MS: u32 = 750;
#[doc = "< The t2/t3 timeouts as defined by the standard"]
pub const isobus_TransportProtocolManager_T2_T3_TIMEOUT_MS: u32 = 1250;
#[doc = "< The t4 timeout as defined by the standard"]
pub const isobus_TransportProtocolManager_T4_TIMEOUT_MS: u32 = 1050;
#[doc = "< The index of the sequence number in a frame"]
pub const isobus_TransportProtocolManager_SEQUENCE_NUMBER_DATA_INDEX: u8 = 0;
#[doc = "< The Tr Timeout as defined by the standard"]
pub const isobus_TransportProtocolManager_MESSAGE_TR_TIMEOUT_MS: u8 = 200;
#[doc = "< The number of payload bytes per frame minus overhead of sequence number"]
pub const isobus_TransportProtocolManager_PROTOCOL_BYTES_PER_FRAME: u8 = 7;
#[test]
fn bindgen_test_layout_isobus_TransportProtocolManager() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_TransportProtocolManager> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_TransportProtocolManager>(),
        40usize,
        concat!("Size of: ", stringify!(isobus_TransportProtocolManager))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_TransportProtocolManager>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_TransportProtocolManager))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activeSessions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_TransportProtocolManager),
            "::",
            stringify!(activeSessions)
        )
    );
}
extern "C" {
    #[doc = " @brief A generic way for a protocol to process a received message\n @param[in] message A received CAN message\n @param[in] parent Provides the context to the actual TP manager object"]
    #[link_name = "\u{1}_ZN6isobus24TransportProtocolManager15process_messageEPNS_10CANMessageEPv"]
    pub fn isobus_TransportProtocolManager_process_message1(
        message: *mut isobus_CANMessage,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief The constructor for the TransportProtocolManager"]
    #[link_name = "\u{1}_ZN6isobus24TransportProtocolManagerC1Ev"]
    pub fn isobus_TransportProtocolManager_TransportProtocolManager(
        this: *mut isobus_TransportProtocolManager,
    );
}
impl isobus_TransportProtocolManager {
    #[inline]
    pub unsafe fn process_message(
        message: *mut isobus_CANMessage,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_TransportProtocolManager_process_message1(message, parent)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_TransportProtocolManager_TransportProtocolManager(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @brief The destructor for the TransportProtocolManager"]
    #[link_name = "\u{1}_ZN6isobus24TransportProtocolManagerD1Ev"]
    pub fn isobus_TransportProtocolManager_TransportProtocolManager_destructor(
        this: *mut isobus_TransportProtocolManager,
    );
}
extern "C" {
    #[doc = " @brief The protocol's initializer function"]
    #[link_name = "\u{1}_ZN6isobus24TransportProtocolManager10initializeENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_TransportProtocolManager_initialize(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
extern "C" {
    #[doc = " @brief A generic way for a protocol to process a received message\n @param[in] message A received CAN message"]
    #[link_name = "\u{1}_ZN6isobus24TransportProtocolManager15process_messageEPNS_10CANMessageE"]
    pub fn isobus_TransportProtocolManager_process_message(
        this: *mut ::std::os::raw::c_void,
        message: *mut isobus_CANMessage,
    );
}
extern "C" {
    #[doc = " @brief The network manager calls this to see if the protocol can accept a long CAN message for processing\n @param[in] parameterGroupNumber The PGN of the message\n @param[in] data The data to be sent\n @param[in] messageLength The length of the data to be sent\n @param[in] source The source control function\n @param[in] destination The destination control function\n @param[in] transmitCompleteCallback A callback for when the protocol completes its work\n @param[in] parentPointer A generic context object for the tx complete and chunk callbacks\n @param[in] frameChunkCallback A callback to get some data to send\n @returns true if the message was accepted by the protocol for processing"]
    #[link_name = "\u{1}_ZN6isobus24TransportProtocolManager25protocol_transmit_messageEjPKhjPNS_15ControlFunctionES4_PFvjjPNS_23InternalControlFunctionES4_bPvES7_PFbjjjPhS7_E"]
    pub fn isobus_TransportProtocolManager_protocol_transmit_message(
        this: *mut ::std::os::raw::c_void,
        parameterGroupNumber: u32,
        data: *const u8,
        messageLength: u32,
        source: *mut isobus_ControlFunction,
        destination: *mut isobus_ControlFunction,
        transmitCompleteCallback: isobus_TransmitCompleteCallback,
        parentPointer: *mut ::std::os::raw::c_void,
        frameChunkCallback: isobus_DataChunkCallback,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Updates the protocol cyclically"]
    #[link_name = "\u{1}_ZN6isobus24TransportProtocolManager6updateENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_TransportProtocolManager_update(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
#[doc = " @class CANNetworkManager\n\n @brief The main CAN network manager object, handles protocol management and updating other\n stack components. Provides an interface for sending CAN messages."]
#[repr(C)]
pub struct isobus_CANNetworkManager {
    #[doc = "< A list of all created protocol classes"]
    pub protocolList: [u64; 3usize],
    #[doc = "< Static instance of the protocol manager"]
    pub extendedTransportProtocol: isobus_ExtendedTransportProtocolManager,
    #[doc = "< Static instance of the transport protocol manager"]
    pub transportProtocol: isobus_TransportProtocolManager,
    #[doc = "< Table to maintain address to NAME mappings"]
    pub controlFunctionTable: [u64; 1024usize],
    #[doc = "< A list of active control function used to track connected devices"]
    pub activeControlFunctions: [u64; 3usize],
    #[doc = "< A list of inactive control functions, used to track disconnected devices"]
    pub inactiveControlFunctions: [u64; 3usize],
    #[doc = "< A list of PGN callback registered by CAN protocols"]
    pub protocolPGNCallbacks: [u64; 3usize],
    #[doc = "< A queue of Rx messages to process"]
    pub receiveMessageList: [u64; 3usize],
    #[doc = "< A list of all global PGN callbacks"]
    pub globalParameterGroupNumberCallbacks: [u64; 3usize],
    #[doc = "< A list of all global PGN callbacks"]
    pub anyControlFunctionParameterGroupNumberCallbacks: [u64; 3usize],
    #[doc = "< A mutex for receive messages thread safety"]
    pub receiveMessageMutex: std_mutex,
    #[doc = "< A mutex for PGN callback thread safety"]
    pub protocolPGNCallbacksMutex: std_mutex,
    #[doc = "< Mutex to protect the \"any CF\" callbacks"]
    pub anyControlFunctionCallbacksMutex: std_mutex,
    #[doc = "< Keeps track of the last time the CAN stack was update in milliseconds"]
    pub updateTimestamp_ms: u32,
    #[doc = "< True if the network manager has been initialized by the update function"]
    pub initialized: bool,
}
extern "C" {
    #[doc = "< Static singleton of the one network manager. Use this to access stack functionality."]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager10CANNetworkE"]
    pub static mut isobus_CANNetworkManager_CANNetwork: isobus_CANNetworkManager;
}
#[test]
fn bindgen_test_layout_isobus_CANNetworkManager() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_CANNetworkManager> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_CANNetworkManager>(),
        8472usize,
        concat!("Size of: ", stringify!(isobus_CANNetworkManager))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_CANNetworkManager>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_CANNetworkManager))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocolList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(protocolList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extendedTransportProtocol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(extendedTransportProtocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportProtocol) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(transportProtocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controlFunctionTable) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(controlFunctionTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activeControlFunctions) as usize - ptr as usize },
        8296usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(activeControlFunctions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inactiveControlFunctions) as usize - ptr as usize },
        8320usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(inactiveControlFunctions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocolPGNCallbacks) as usize - ptr as usize },
        8344usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(protocolPGNCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiveMessageList) as usize - ptr as usize },
        8368usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(receiveMessageList)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).globalParameterGroupNumberCallbacks) as usize - ptr as usize
        },
        8392usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(globalParameterGroupNumberCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).anyControlFunctionParameterGroupNumberCallbacks) as usize
                - ptr as usize
        },
        8416usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(anyControlFunctionParameterGroupNumberCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiveMessageMutex) as usize - ptr as usize },
        8440usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(receiveMessageMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocolPGNCallbacksMutex) as usize - ptr as usize },
        8448usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(protocolPGNCallbacksMutex)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).anyControlFunctionCallbacksMutex) as usize - ptr as usize
        },
        8456usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(anyControlFunctionCallbacksMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).updateTimestamp_ms) as usize - ptr as usize },
        8464usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(updateTimestamp_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        8468usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_CANNetworkManager),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " @brief Initializer function for the network manager"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager10initializeEv"]
    pub fn isobus_CANNetworkManager_initialize(this: *mut isobus_CANNetworkManager);
}
extern "C" {
    #[doc = " @brief Called only by the stack, returns a control function based on certain port and address\n @param[in] CANPort CAN Channel index of the control function\n @param[in] CFAddress Address of the control function\n @returns A control function that matches the parameters, or nullptr if no match was found"]
    #[link_name = "\u{1}_ZNK6isobus17CANNetworkManager20get_control_functionEhhNS_11CANLibBadgeINS_24AddressClaimStateMachineEEE"]
    pub fn isobus_CANNetworkManager_get_control_function(
        this: *const isobus_CANNetworkManager,
        CANPort: u8,
        CFAddress: u8,
        arg1: isobus_CANLibBadge,
    ) -> *mut isobus_ControlFunction;
}
extern "C" {
    #[doc = " @brief Called only by the stack, adds a new contorl function with specified parameters\n @param[in] CANPort The CAN channel index associated with the control function\n @param[in] newControlFunction The new control function to be processed\n @param[in] CFAddress The new control function's address"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager20add_control_functionEhPNS_15ControlFunctionEhNS_11CANLibBadgeINS_24AddressClaimStateMachineEEE"]
    pub fn isobus_CANNetworkManager_add_control_function(
        this: *mut isobus_CANNetworkManager,
        CANPort: u8,
        newControlFunction: *mut isobus_ControlFunction,
        CFAddress: u8,
        arg1: isobus_CANLibBadge,
    );
}
extern "C" {
    #[doc = " @brief This is how you register a callback for any PGN destined for the global address (0xFF)\n @param[in] parameterGroupNumber The PGN you want to register for\n @param[in] callback The callback that will be called when parameterGroupNumber is recieved from the global address (0xFF)\n @param[in] parent A generic context variable that helps identify what object the callback is destined for. Can be nullptr if you don't want to use it."]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager42add_global_parameter_group_number_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_CANNetworkManager_add_global_parameter_group_number_callback(
        this: *mut isobus_CANNetworkManager,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief This is how you remove a callback for any PGN destined for the global address (0xFF)\n @param[in] parameterGroupNumber The PGN of the callback to remove\n @param[in] callback The callback that will be removed\n @param[in] parent A generic context variable that helps identify what object the callback was destined for"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager45remove_global_parameter_group_number_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_CANNetworkManager_remove_global_parameter_group_number_callback(
        this: *mut isobus_CANNetworkManager,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Returns the number of global PGN callbacks that have been registered with the network manager\n @returns The number of global PGN callbacks that have been registered with the network manager"]
    #[link_name = "\u{1}_ZNK6isobus17CANNetworkManager50get_number_global_parameter_group_number_callbacksEv"]
    pub fn isobus_CANNetworkManager_get_number_global_parameter_group_number_callbacks(
        this: *const isobus_CANNetworkManager,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Registers a callback for ANY control function sending the associated PGN\n @param[in] parameterGroupNumber The PGN you want to register for\n @param[in] callback The callback that will be called when parameterGroupNumber is recieved from any control function\n @param[in] parent A generic context variable that helps identify what object the callback is destined for. Can be nullptr if you don't want to use it."]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager56add_any_control_function_parameter_group_number_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_CANNetworkManager_add_any_control_function_parameter_group_number_callback(
        this: *mut isobus_CANNetworkManager,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief This is how you remove a callback added with add_any_control_function_parameter_group_number_callback\n @param[in] parameterGroupNumber The PGN of the callback to remove\n @param[in] callback The callback that will be removed\n @param[in] parent A generic context variable that helps identify what object the callback was destined for"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager59remove_any_control_function_parameter_group_number_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_CANNetworkManager_remove_any_control_function_parameter_group_number_callback(
        this: *mut isobus_CANNetworkManager,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Returns an internal control function if the passed-in control function is an internal type\n @returns An internal control function casted from the passed in control function"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager29get_internal_control_functionEPNS_15ControlFunctionE"]
    pub fn isobus_CANNetworkManager_get_internal_control_function(
        this: *mut isobus_CANNetworkManager,
        controlFunction: *mut isobus_ControlFunction,
    ) -> *mut isobus_InternalControlFunction;
}
extern "C" {
    #[doc = " @brief This is the main way to send a CAN message of any length.\n @details This function will automatically choose an appropriate transport protocol if needed.\n If you don't specify a destination (or use nullptr) you message will be sent as a broadcast\n if it is valid to do so.\n You can also get a callback on success or failure of the transmit.\n @returns `true` if the message was sent, otherwise `false`"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager16send_can_messageEjPKhjPNS_23InternalControlFunctionEPNS_15ControlFunctionENS_13CANIdentifier11CANPriorityEPFvjjS4_S6_bPvES9_PFbjjjPhS9_E"]
    pub fn isobus_CANNetworkManager_send_can_message(
        this: *mut isobus_CANNetworkManager,
        parameterGroupNumber: u32,
        dataBuffer: *const u8,
        dataLength: u32,
        sourceControlFunction: *mut isobus_InternalControlFunction,
        destinationControlFunction: *mut isobus_ControlFunction,
        priority: isobus_CANIdentifier_CANPriority,
        txCompleteCallback: isobus_TransmitCompleteCallback,
        parentPointer: *mut ::std::os::raw::c_void,
        frameChunkCallback: isobus_DataChunkCallback,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief This is the main function used by the stack to receive CAN messages and add them to a queue.\n @details This function is called by the stack itself when you call can_lib_process_rx_message.\n @param[in] message The message to be received"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager19receive_can_messageENS_10CANMessageE"]
    pub fn isobus_CANNetworkManager_receive_can_message(
        this: *mut isobus_CANNetworkManager,
        message: isobus_CANMessage,
    );
}
extern "C" {
    #[doc = " @brief The main update function for the network manager. Updates all protocols."]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager6updateEv"]
    pub fn isobus_CANNetworkManager_update(this: *mut isobus_CANNetworkManager);
}
extern "C" {
    #[doc = " @brief Process the CAN Rx queue\n @param[in] rxFrame Frame to process\n @param[in] parentClass A generic context variable"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager26can_lib_process_rx_messageERNS_25HardwareInterfaceCANFrameEPv"]
    pub fn isobus_CANNetworkManager_can_lib_process_rx_message(
        rxFrame: *mut isobus_HardwareInterfaceCANFrame,
        parentClass: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Informs the network manager that a partner was deleted so that it can be purged from the address/cf tables\n @param[in] partner Pointer to the partner being deleted"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager18on_partner_deletedEPNS_24PartneredControlFunctionENS_11CANLibBadgeIS1_EE"]
    pub fn isobus_CANNetworkManager_on_partner_deleted(
        this: *mut isobus_CANNetworkManager,
        partner: *mut isobus_PartneredControlFunction,
        arg1: isobus_CANLibBadge,
    );
}
extern "C" {
    #[doc = " @brief Adds a PGN callback for a protocol class\n @param[in] parameterGroupNumber The PGN to register for\n @param[in] callback The callback to call when the PGN is received\n @param[in] parentPointer A generic context variable that helps identify what object the callback was destined for\n @returns `true` if the callback was added, otherwise `false`"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager44add_protocol_parameter_group_number_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_CANNetworkManager_add_protocol_parameter_group_number_callback(
        this: *mut isobus_CANNetworkManager,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Removes a PGN callback for a protocol class\n @param[in] parameterGroupNumber The PGN to register for\n @param[in] callback The callback to call when the PGN is received\n @param[in] parentPointer A generic context variable that helps identify what object the callback was destined for\n @returns `true` if the callback was removed, otherwise `false`"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager47remove_protocol_parameter_group_number_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_CANNetworkManager_remove_protocol_parameter_group_number_callback(
        this: *mut isobus_CANNetworkManager,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends a CAN message using raw addresses. Used only by the stack.\n @param[in] portIndex The CAN channel index to send the message from\n @param[in] sourceAddress The source address to send the CAN message from\n @param[in] destAddress The destination address to send the message to\n @param[in] parameterGroupNumber The PGN to use when sending the message\n @param[in] priority The CAN priority of the message being sent\n @param[in] data A pointer to the data buffer to send from\n @param[in] size The size of the messgage to send\n @returns `true` if the message was sent, otherwise `false`"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager20send_can_message_rawEjhhjhPKvjNS_11CANLibBadgeINS_24AddressClaimStateMachineEEE"]
    pub fn isobus_CANNetworkManager_send_can_message_raw(
        this: *mut isobus_CANNetworkManager,
        portIndex: u32,
        sourceAddress: u8,
        destAddress: u8,
        parameterGroupNumber: u32,
        priority: u8,
        data: *const ::std::os::raw::c_void,
        size: u32,
        arg1: isobus_CANLibBadge,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Processes completed protocol messages. Causes PGN callbacks to trigger.\n @param[in] protocolMessage The completed protocol message"]
    #[link_name = "\u{1}_ZN6isobus17CANNetworkManager25protocol_message_callbackEPNS_10CANMessageE"]
    pub fn isobus_CANNetworkManager_protocol_message_callback(
        this: *mut isobus_CANNetworkManager,
        protocolMessage: *mut isobus_CANMessage,
    );
}
impl isobus_CANNetworkManager {
    #[inline]
    pub unsafe fn initialize(&mut self) {
        isobus_CANNetworkManager_initialize(self)
    }
    #[inline]
    pub unsafe fn get_control_function(
        &self,
        CANPort: u8,
        CFAddress: u8,
        arg1: isobus_CANLibBadge,
    ) -> *mut isobus_ControlFunction {
        isobus_CANNetworkManager_get_control_function(self, CANPort, CFAddress, arg1)
    }
    #[inline]
    pub unsafe fn add_control_function(
        &mut self,
        CANPort: u8,
        newControlFunction: *mut isobus_ControlFunction,
        CFAddress: u8,
        arg1: isobus_CANLibBadge,
    ) {
        isobus_CANNetworkManager_add_control_function(
            self,
            CANPort,
            newControlFunction,
            CFAddress,
            arg1,
        )
    }
    #[inline]
    pub unsafe fn add_global_parameter_group_number_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_CANNetworkManager_add_global_parameter_group_number_callback(
            self,
            parameterGroupNumber,
            callback,
            parent,
        )
    }
    #[inline]
    pub unsafe fn remove_global_parameter_group_number_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_CANNetworkManager_remove_global_parameter_group_number_callback(
            self,
            parameterGroupNumber,
            callback,
            parent,
        )
    }
    #[inline]
    pub unsafe fn get_number_global_parameter_group_number_callbacks(&self) -> u32 {
        isobus_CANNetworkManager_get_number_global_parameter_group_number_callbacks(self)
    }
    #[inline]
    pub unsafe fn add_any_control_function_parameter_group_number_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_CANNetworkManager_add_any_control_function_parameter_group_number_callback(
            self,
            parameterGroupNumber,
            callback,
            parent,
        )
    }
    #[inline]
    pub unsafe fn remove_any_control_function_parameter_group_number_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_CANNetworkManager_remove_any_control_function_parameter_group_number_callback(
            self,
            parameterGroupNumber,
            callback,
            parent,
        )
    }
    #[inline]
    pub unsafe fn get_internal_control_function(
        &mut self,
        controlFunction: *mut isobus_ControlFunction,
    ) -> *mut isobus_InternalControlFunction {
        isobus_CANNetworkManager_get_internal_control_function(self, controlFunction)
    }
    #[inline]
    pub unsafe fn send_can_message(
        &mut self,
        parameterGroupNumber: u32,
        dataBuffer: *const u8,
        dataLength: u32,
        sourceControlFunction: *mut isobus_InternalControlFunction,
        destinationControlFunction: *mut isobus_ControlFunction,
        priority: isobus_CANIdentifier_CANPriority,
        txCompleteCallback: isobus_TransmitCompleteCallback,
        parentPointer: *mut ::std::os::raw::c_void,
        frameChunkCallback: isobus_DataChunkCallback,
    ) -> bool {
        isobus_CANNetworkManager_send_can_message(
            self,
            parameterGroupNumber,
            dataBuffer,
            dataLength,
            sourceControlFunction,
            destinationControlFunction,
            priority,
            txCompleteCallback,
            parentPointer,
            frameChunkCallback,
        )
    }
    #[inline]
    pub unsafe fn receive_can_message(&mut self, message: isobus_CANMessage) {
        isobus_CANNetworkManager_receive_can_message(self, message)
    }
    #[inline]
    pub unsafe fn update(&mut self) {
        isobus_CANNetworkManager_update(self)
    }
    #[inline]
    pub unsafe fn can_lib_process_rx_message(
        rxFrame: *mut isobus_HardwareInterfaceCANFrame,
        parentClass: *mut ::std::os::raw::c_void,
    ) {
        isobus_CANNetworkManager_can_lib_process_rx_message(rxFrame, parentClass)
    }
    #[inline]
    pub unsafe fn on_partner_deleted(
        &mut self,
        partner: *mut isobus_PartneredControlFunction,
        arg1: isobus_CANLibBadge,
    ) {
        isobus_CANNetworkManager_on_partner_deleted(self, partner, arg1)
    }
    #[inline]
    pub unsafe fn add_protocol_parameter_group_number_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool {
        isobus_CANNetworkManager_add_protocol_parameter_group_number_callback(
            self,
            parameterGroupNumber,
            callback,
            parentPointer,
        )
    }
    #[inline]
    pub unsafe fn remove_protocol_parameter_group_number_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool {
        isobus_CANNetworkManager_remove_protocol_parameter_group_number_callback(
            self,
            parameterGroupNumber,
            callback,
            parentPointer,
        )
    }
    #[inline]
    pub unsafe fn send_can_message_raw(
        &mut self,
        portIndex: u32,
        sourceAddress: u8,
        destAddress: u8,
        parameterGroupNumber: u32,
        priority: u8,
        data: *const ::std::os::raw::c_void,
        size: u32,
        arg1: isobus_CANLibBadge,
    ) -> bool {
        isobus_CANNetworkManager_send_can_message_raw(
            self,
            portIndex,
            sourceAddress,
            destAddress,
            parameterGroupNumber,
            priority,
            data,
            size,
            arg1,
        )
    }
    #[inline]
    pub unsafe fn protocol_message_callback(&mut self, protocolMessage: *mut isobus_CANMessage) {
        isobus_CANNetworkManager_protocol_message_callback(self, protocolMessage)
    }
}
#[doc = " @class ParameterGroupNumberRequestProtocol\n\n @brief A protocol that handles PGN requests\n @details The purpose of this protocol is to simplify and standardize how PGN requests\n are made and responded to. It provides a way to easily send a PGN request or a request for\n repitition rate, as well as methods to receive PGN requests."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_ParameterGroupNumberRequestProtocol {
    pub _base: isobus_CANLibProtocol,
    #[doc = "< The internal control function that this protocol will send from"]
    pub myControlFunction: [u64; 2usize],
    #[doc = "< A list of all registered PGN callbacks and the PGN associated with each callback"]
    pub pgnRequestCallbacks: [u64; 3usize],
    #[doc = "< A list of all registered request for repetition rate callbacks and the PGN associated with the callback"]
    pub repetitionRateCallbacks: [u64; 3usize],
    #[doc = "< A mutex to protect the callback lists"]
    pub pgnRequestMutex: std_mutex,
}
#[doc = " @brief A storage class for holding PGN callbacks and their associated PGN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo {
    #[doc = "< The actual callback"]
    pub callbackFunction: isobus_PGNRequestCallback,
    #[doc = "< The PGN associated with the callback"]
    pub pgn: u32,
    #[doc = "< Pointer to the class that registered the callback, or `nullptr`"]
    pub parent: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackFunction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo),
            "::",
            stringify!(callbackFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pgn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo),
            "::",
            stringify!(pgn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    #[doc = " @brief Constructor for PGNRequestCallbackInfo\n @param[in] callback A PGNRequestCallback\n @param[in] parameterGroupNumber The PGN associcated with the callback\n @param[in] parentPointer Pointer to the class that registered the callback, or `nullptr`"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol22PGNRequestCallbackInfoC1EPFbjPNS_15ControlFunctionERbRNS_19AcknowledgementTypeEPvEjS7_"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo_PGNRequestCallbackInfo(
        this: *mut isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo,
        callback: isobus_PGNRequestCallback,
        parameterGroupNumber: u32,
        parentPointer: *mut ::std::os::raw::c_void,
    );
}
impl isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo {
    #[inline]
    pub unsafe fn new(
        callback: isobus_PGNRequestCallback,
        parameterGroupNumber: u32,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_ParameterGroupNumberRequestProtocol_PGNRequestCallbackInfo_PGNRequestCallbackInfo(
            __bindgen_tmp.as_mut_ptr(),
            callback,
            parameterGroupNumber,
            parentPointer,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief A storage class for holding PGN callbacks and their associated PGN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo {
    #[doc = "< The actual callback"]
    pub callbackFunction: isobus_PGNRequestForRepetitionRateCallback,
    #[doc = "< The PGN associated with the callback"]
    pub pgn: u32,
    #[doc = "< Pointer to the class that registered the callback, or `nullptr`"]
    pub parent: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo,
        >(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(
                isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackFunction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo
            ),
            "::",
            stringify!(callbackFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pgn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo
            ),
            "::",
            stringify!(pgn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(
                isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo
            ),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    #[doc = " @brief Constructor for PGNRequestCallbackInfo\n @param[in] callback A PGNRequestCallback\n @param[in] parameterGroupNumber The PGN associcated with the callback\n @param[in] parentPointer Pointer to the class that registered the callback, or `nullptr`"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol39PGNRequestForRepetitionRateCallbackInfoC1EPFbjPNS_15ControlFunctionEjPvEjS4_"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo_PGNRequestForRepetitionRateCallbackInfo(
        this : * mut isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo,
        callback: isobus_PGNRequestForRepetitionRateCallback,
        parameterGroupNumber: u32,
        parentPointer: *mut ::std::os::raw::c_void,
    );
}
impl isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo {
    #[inline]
    pub unsafe fn new(
        callback: isobus_PGNRequestForRepetitionRateCallback,
        parameterGroupNumber: u32,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_ParameterGroupNumberRequestProtocol_PGNRequestForRepetitionRateCallbackInfo_PGNRequestForRepetitionRateCallbackInfo (__bindgen_tmp . as_mut_ptr () , callback , parameterGroupNumber , parentPointer) ;
        __bindgen_tmp.assume_init()
    }
}
#[doc = "< The CAN data length of a PGN request"]
pub const isobus_ParameterGroupNumberRequestProtocol_PGN_REQUEST_LENGTH: u8 = 3;
extern "C" {
    #[doc = "< List of all PGN request protocol instances (one per ICF)"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol22pgnRequestProtocolListB5cxx11E"]
    pub static mut isobus_ParameterGroupNumberRequestProtocol_pgnRequestProtocolList: u8;
}
#[test]
fn bindgen_test_layout_isobus_ParameterGroupNumberRequestProtocol() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_ParameterGroupNumberRequestProtocol> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_ParameterGroupNumberRequestProtocol>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_ParameterGroupNumberRequestProtocol>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).myControlFunction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol),
            "::",
            stringify!(myControlFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pgnRequestCallbacks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol),
            "::",
            stringify!(pgnRequestCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repetitionRateCallbacks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol),
            "::",
            stringify!(repetitionRateCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pgnRequestMutex) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ParameterGroupNumberRequestProtocol),
            "::",
            stringify!(pgnRequestMutex)
        )
    );
}
extern "C" {
    #[doc = " @brief Used to tell the CAN stack that PGN requests should be handled for the specified internal control function\n @details This will allocate an instance of this protocol\n @returns `true` If the protocol instance was created OK with the passed in ICF"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol56assign_pgn_request_protocol_to_internal_control_functionESt10shared_ptrINS_23InternalControlFunctionEE"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_assign_pgn_request_protocol_to_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Used to tell the CAN stack that PGN requests should no longer be handled for the specified internal control function\n @details This will delete an instance of this protocol\n @returns `true` If the protocol instance was deleted OK according to the passed in ICF"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol58deassign_pgn_request_protocol_to_internal_control_functionESt10shared_ptrINS_23InternalControlFunctionEE"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_deassign_pgn_request_protocol_to_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Retuns the pgn request protocol assigned to an internal control function, if any\n @param internalControlFunction The internal control function to search against\n @returns The protocol object associated to the passed in ICF, or `nullptr` if none found that match the passed in ICF"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol53get_pgn_request_protocol_by_internal_control_functionESt10shared_ptrINS_23InternalControlFunctionEE"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_get_pgn_request_protocol_by_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> *mut isobus_ParameterGroupNumberRequestProtocol;
}
extern "C" {
    #[doc = " @brief Sends a PGN request to the specified control function\n @param[in] pgn The PGN to request\n @param[in] source The internal control function to send from\n @param[in] destination The control function to request `pgn` from\n @returns `true` if the request was successfully sent"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol30request_parameter_group_numberEjPNS_23InternalControlFunctionEPNS_15ControlFunctionE"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_request_parameter_group_number(
        pgn: u32,
        source: *mut isobus_InternalControlFunction,
        destination: *mut isobus_ControlFunction,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends a PGN request for repitition rate\n @details Use this if you want the requestee to send you the specified PGN at some fixed interval\n @param[in] pgn The PGN to request\n @param[in] repetitionRate_ms The repetition rate to request in milliseconds\n @param[in] source The internal control function to send from\n @param[in] destination The control function to send the request to\n @returns `true` if the request was sent"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol23request_repetition_rateEjtPNS_23InternalControlFunctionEPNS_15ControlFunctionE"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_request_repetition_rate(
        pgn: u32,
        repetitionRate_ms: u16,
        source: *mut isobus_InternalControlFunction,
        destination: *mut isobus_ControlFunction,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Registers for a callback on receipt of a PGN request\n @param[in] pgn The PGN you want to handle in the callback\n @param[in] callback The callback function to register\n @param[in] parentPointer Generic context variable, usually the `this` pointer of the class registering the callback\n @returns true if the callback was registered, false if the callback is nullptr or is already registered for the same PGN"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol29register_pgn_request_callbackEjPFbjPNS_15ControlFunctionERbRNS_19AcknowledgementTypeEPvES6_"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_register_pgn_request_callback(
        this: *mut isobus_ParameterGroupNumberRequestProtocol,
        pgn: u32,
        callback: isobus_PGNRequestCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Registers for a callback on receipt of a request for repetition rate\n @param[in] pgn The PGN you want to handle in the callback\n @param[in] callback The callback function to register\n @param[in] parentPointer Generic context variable, usually the `this` pointer of the class registering the callback\n @returns true if the callback was registered, false if the callback is nullptr or is already registered for the same PGN"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol45register_request_for_repetition_rate_callbackEjPFbjPNS_15ControlFunctionEjPvES3_"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_register_request_for_repetition_rate_callback(
        this: *mut isobus_ParameterGroupNumberRequestProtocol,
        pgn: u32,
        callback: isobus_PGNRequestForRepetitionRateCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Removes a previously registered PGN request callback\n @param[in] pgn The PGN associated with the callback\n @param[in] callback The callback function to remove\n @param[in] parentPointer Generic context variable, usually the `this` pointer of the class that registered the callback\n @returns true if the callback was removed, false if no callback matched the parameters"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol27remove_pgn_request_callbackEjPFbjPNS_15ControlFunctionERbRNS_19AcknowledgementTypeEPvES6_"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_remove_pgn_request_callback(
        this: *mut isobus_ParameterGroupNumberRequestProtocol,
        pgn: u32,
        callback: isobus_PGNRequestCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Removes a callback for repitition rate requests\n @param[in] pgn The PGN associated with the callback\n @param[in] callback The callback function to remove\n @param[in] parentPointer Generic context variable, usually the `this` pointer of the class that registered the callback\n @returns true if the callback was registered, false if the callback is nullptr or is already registered for the same PGN"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol43remove_request_for_repetition_rate_callbackEjPFbjPNS_15ControlFunctionEjPvES3_"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_remove_request_for_repetition_rate_callback(
        this: *mut isobus_ParameterGroupNumberRequestProtocol,
        pgn: u32,
        callback: isobus_PGNRequestForRepetitionRateCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the number of PGN request callbacks that have been registered with this protocol instance\n @returns The number of PGN request callbacks that have been registered with this protocol instance"]
    #[link_name = "\u{1}_ZNK6isobus35ParameterGroupNumberRequestProtocol43get_number_registered_pgn_request_callbacksEv"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_get_number_registered_pgn_request_callbacks(
        this: *const isobus_ParameterGroupNumberRequestProtocol,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Returns the number of PGN request for repetition rate callbacks that have been registered with this protocol instance\n @returns The number of PGN request for repetition rate callbacks that have been registered with this protocol instance"]
    #[link_name = "\u{1}_ZNK6isobus35ParameterGroupNumberRequestProtocol59get_number_registered_request_for_repetition_rate_callbacksEv"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_get_number_registered_request_for_repetition_rate_callbacks(
        this: *const isobus_ParameterGroupNumberRequestProtocol,
    ) -> usize;
}
impl isobus_ParameterGroupNumberRequestProtocol {
    #[inline]
    pub unsafe fn assign_pgn_request_protocol_to_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> bool {
        isobus_ParameterGroupNumberRequestProtocol_assign_pgn_request_protocol_to_internal_control_function (internalControlFunction)
    }
    #[inline]
    pub unsafe fn deassign_pgn_request_protocol_to_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> bool {
        isobus_ParameterGroupNumberRequestProtocol_deassign_pgn_request_protocol_to_internal_control_function (internalControlFunction)
    }
    #[inline]
    pub unsafe fn get_pgn_request_protocol_by_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> *mut isobus_ParameterGroupNumberRequestProtocol {
        isobus_ParameterGroupNumberRequestProtocol_get_pgn_request_protocol_by_internal_control_function (internalControlFunction)
    }
    #[inline]
    pub unsafe fn request_parameter_group_number(
        pgn: u32,
        source: *mut isobus_InternalControlFunction,
        destination: *mut isobus_ControlFunction,
    ) -> bool {
        isobus_ParameterGroupNumberRequestProtocol_request_parameter_group_number(
            pgn,
            source,
            destination,
        )
    }
    #[inline]
    pub unsafe fn request_repetition_rate(
        pgn: u32,
        repetitionRate_ms: u16,
        source: *mut isobus_InternalControlFunction,
        destination: *mut isobus_ControlFunction,
    ) -> bool {
        isobus_ParameterGroupNumberRequestProtocol_request_repetition_rate(
            pgn,
            repetitionRate_ms,
            source,
            destination,
        )
    }
    #[inline]
    pub unsafe fn register_pgn_request_callback(
        &mut self,
        pgn: u32,
        callback: isobus_PGNRequestCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool {
        isobus_ParameterGroupNumberRequestProtocol_register_pgn_request_callback(
            self,
            pgn,
            callback,
            parentPointer,
        )
    }
    #[inline]
    pub unsafe fn register_request_for_repetition_rate_callback(
        &mut self,
        pgn: u32,
        callback: isobus_PGNRequestForRepetitionRateCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool {
        isobus_ParameterGroupNumberRequestProtocol_register_request_for_repetition_rate_callback(
            self,
            pgn,
            callback,
            parentPointer,
        )
    }
    #[inline]
    pub unsafe fn remove_pgn_request_callback(
        &mut self,
        pgn: u32,
        callback: isobus_PGNRequestCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool {
        isobus_ParameterGroupNumberRequestProtocol_remove_pgn_request_callback(
            self,
            pgn,
            callback,
            parentPointer,
        )
    }
    #[inline]
    pub unsafe fn remove_request_for_repetition_rate_callback(
        &mut self,
        pgn: u32,
        callback: isobus_PGNRequestForRepetitionRateCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> bool {
        isobus_ParameterGroupNumberRequestProtocol_remove_request_for_repetition_rate_callback(
            self,
            pgn,
            callback,
            parentPointer,
        )
    }
    #[inline]
    pub unsafe fn get_number_registered_pgn_request_callbacks(&self) -> usize {
        isobus_ParameterGroupNumberRequestProtocol_get_number_registered_pgn_request_callbacks(self)
    }
    #[inline]
    pub unsafe fn get_number_registered_request_for_repetition_rate_callbacks(&self) -> usize {
        isobus_ParameterGroupNumberRequestProtocol_get_number_registered_request_for_repetition_rate_callbacks (self)
    }
}
extern "C" {
    #[doc = " @brief The protocol's initializer function"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol10initializeENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_initialize(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
extern "C" {
    #[doc = " @brief Updates the protocol cyclically"]
    #[link_name = "\u{1}_ZN6isobus35ParameterGroupNumberRequestProtocol6updateENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_ParameterGroupNumberRequestProtocol_update(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
#[doc = " @class PartneredControlFunction\n\n @brief This reprents any device on the bus you want to talk to.\n @details To communicate with a device on the bus, create one of these objects and tell it\n via the constructor what the identity of that device is using NAME fields like\n manufacturer code, function, and device class. The stack will take care of locating the\n device on the bus that matches that description, and will allow you to talk to it through\n passing this object to the appropriate send function in the network manager."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_PartneredControlFunction {
    pub _base: isobus_ControlFunction,
    #[doc = "< A list of NAME parameters that describe this control function's identity"]
    pub NAMEFilterList: [u64; 3usize],
    #[doc = "< A list of all parameter group number callbacks associated with this control function"]
    pub parameterGroupNumberCallbacks: [u64; 3usize],
    #[doc = "< A way to track if the network manager has processed this CF against existing CFs"]
    pub initialized: bool,
}
extern "C" {
    #[doc = "< A list of all created partnered control functions"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunction28partneredControlFunctionListE"]
    pub static mut isobus_PartneredControlFunction_partneredControlFunctionList: u8;
}
extern "C" {
    #[doc = "< A way for the network manager to know if it needs to parse the partner list to match partners with existing CFs"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunction27anyPartnerNeedsInitializingE"]
    pub static mut isobus_PartneredControlFunction_anyPartnerNeedsInitializing: bool;
}
#[test]
fn bindgen_test_layout_isobus_PartneredControlFunction() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_PartneredControlFunction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_PartneredControlFunction>(),
        80usize,
        concat!("Size of: ", stringify!(isobus_PartneredControlFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_PartneredControlFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_PartneredControlFunction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NAMEFilterList) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_PartneredControlFunction),
            "::",
            stringify!(NAMEFilterList)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).parameterGroupNumberCallbacks) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_PartneredControlFunction),
            "::",
            stringify!(parameterGroupNumberCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_PartneredControlFunction),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " @brief This is how you get notified that this control function has sent you a destination specific message.\n @details Add a callback function here to be notified when this device has sent you a message with the specified PGN.\n You can also get callbacks for any/all PGNs if you pass in `CANLibParameterGroupNumber::Any` as the PGN.\n Optionally you can use the parent pointer to get context inside your callback as to what C++ object the callback is\n destined for. Whatever you pass in `parent` will be passed back to you in the callback. In theory, you could use\n that variable for passing any arbitrary data through the callback also.\n You can add as many callbacks as you want, and can use the same function for multiple PGNs if you want.\n @param[in] parameterGroupNumber The PGN you want to use to communicate, or `CANLibParameterGroupNumber::Any`\n @param[in] callback The function you want to get called when a message is received with parameterGroupNumber from this CF\n @param[in] parent A generic context variable that helps identify what object the callback was destined for"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunction35add_parameter_group_number_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_PartneredControlFunction_add_parameter_group_number_callback(
        this: *mut isobus_PartneredControlFunction,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Removes a callback matching *exactly* the parameters passed in\n @param[in] parameterGroupNumber The PGN associated with the callback being removed\n @param[in] callback The callback function being removed\n @param[in] parent A generic context variable that helps identify what object the callback was destined for"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunction38remove_parameter_group_number_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_PartneredControlFunction_remove_parameter_group_number_callback(
        this: *mut isobus_PartneredControlFunction,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Returns the number of parameter group number callbacks associated with this control function\n @returns The number of parameter group number callbacks associated with this control function"]
    #[link_name = "\u{1}_ZNK6isobus24PartneredControlFunction43get_number_parameter_group_number_callbacksEv"]
    pub fn isobus_PartneredControlFunction_get_number_parameter_group_number_callbacks(
        this: *const isobus_PartneredControlFunction,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Returns the number of NAME filter objects that describe the identity of this control function\n @returns The number of NAME filter objects that describe the identity of this control function"]
    #[link_name = "\u{1}_ZNK6isobus24PartneredControlFunction23get_number_name_filtersEv"]
    pub fn isobus_PartneredControlFunction_get_number_name_filters(
        this: *const isobus_PartneredControlFunction,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Returns the number of NAME filters with a specific NAME parameter component, like manufacturer code\n @param[in] parameter The NAME parameter to check against\n @returns The number of NAME filters with a specific NAME parameter component"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunction43get_number_name_filters_with_parameter_typeENS_4NAME14NAMEParametersE"]
    pub fn isobus_PartneredControlFunction_get_number_name_filters_with_parameter_type(
        this: *mut isobus_PartneredControlFunction,
        parameter: isobus_NAME_NAMEParameters,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Returns a NAME filter by index\n @param[in] index The index of the filter to get\n @param[out] parameter The returned parameter type\n @param[out] filterValue The raw value of the filter associated with the `parameter`\n @returns true if a filter was returned successfully, false if the index was out of range"]
    #[link_name = "\u{1}_ZNK6isobus24PartneredControlFunction25get_name_filter_parameterEjRNS_4NAME14NAMEParametersERj"]
    pub fn isobus_PartneredControlFunction_get_name_filter_parameter(
        this: *const isobus_PartneredControlFunction,
        index: u32,
        parameter: *mut isobus_NAME_NAMEParameters,
        filterValue: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Checks to see if a NAME matches this CF's NAME filters\n @param[in] NAMEToCheck The NAME to check against this control function's filters\n @returns true if this control function matches the NAME that was passed in, false otherwise"]
    #[link_name = "\u{1}_ZNK6isobus24PartneredControlFunction18check_matches_nameENS_4NAMEE"]
    pub fn isobus_PartneredControlFunction_check_matches_name(
        this: *const isobus_PartneredControlFunction,
        NAMEToCheck: isobus_NAME,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Gets a PartneredControlFunction by index\n @param[in] index The index of the PartneredControlFunction to get\n @returns a PartneredControlFunction at the index specified from `partneredControlFunctionList`"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunction30get_partnered_control_functionEj"]
    pub fn isobus_PartneredControlFunction_get_partnered_control_function(
        index: u32,
    ) -> *mut isobus_PartneredControlFunction;
}
extern "C" {
    #[doc = " @brief Returns the number of created partner control functions\n @returns The number of created partner control functions from the static list of all of them"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunction38get_number_partnered_control_functionsEv"]
    pub fn isobus_PartneredControlFunction_get_number_partnered_control_functions() -> u32;
}
extern "C" {
    #[doc = " @brief the constructor for a PartneredControlFunction\n @param[in] CANPort The CAN channel associated with this control function definition\n @param[in] NAMEFilters A list of filters that describe the identity of the CF based on NAME components"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunctionC1EhSt6vectorINS_10NAMEFilterESaIS2_EE"]
    pub fn isobus_PartneredControlFunction_PartneredControlFunction(
        this: *mut isobus_PartneredControlFunction,
        CANPort: u8,
        NAMEFilters: [u64; 3usize],
    );
}
impl isobus_PartneredControlFunction {
    #[inline]
    pub unsafe fn add_parameter_group_number_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_PartneredControlFunction_add_parameter_group_number_callback(
            self,
            parameterGroupNumber,
            callback,
            parent,
        )
    }
    #[inline]
    pub unsafe fn remove_parameter_group_number_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_PartneredControlFunction_remove_parameter_group_number_callback(
            self,
            parameterGroupNumber,
            callback,
            parent,
        )
    }
    #[inline]
    pub unsafe fn get_number_parameter_group_number_callbacks(&self) -> u32 {
        isobus_PartneredControlFunction_get_number_parameter_group_number_callbacks(self)
    }
    #[inline]
    pub unsafe fn get_number_name_filters(&self) -> u32 {
        isobus_PartneredControlFunction_get_number_name_filters(self)
    }
    #[inline]
    pub unsafe fn get_number_name_filters_with_parameter_type(
        &mut self,
        parameter: isobus_NAME_NAMEParameters,
    ) -> u32 {
        isobus_PartneredControlFunction_get_number_name_filters_with_parameter_type(self, parameter)
    }
    #[inline]
    pub unsafe fn get_name_filter_parameter(
        &self,
        index: u32,
        parameter: *mut isobus_NAME_NAMEParameters,
        filterValue: *mut u32,
    ) -> bool {
        isobus_PartneredControlFunction_get_name_filter_parameter(
            self,
            index,
            parameter,
            filterValue,
        )
    }
    #[inline]
    pub unsafe fn check_matches_name(&self, NAMEToCheck: isobus_NAME) -> bool {
        isobus_PartneredControlFunction_check_matches_name(self, NAMEToCheck)
    }
    #[inline]
    pub unsafe fn get_partnered_control_function(
        index: u32,
    ) -> *mut isobus_PartneredControlFunction {
        isobus_PartneredControlFunction_get_partnered_control_function(index)
    }
    #[inline]
    pub unsafe fn get_number_partnered_control_functions() -> u32 {
        isobus_PartneredControlFunction_get_number_partnered_control_functions()
    }
    #[inline]
    pub unsafe fn new(CANPort: u8, NAMEFilters: [u64; 3usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_PartneredControlFunction_PartneredControlFunction(
            __bindgen_tmp.as_mut_ptr(),
            CANPort,
            NAMEFilters,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @brief The destructor for PartneredControlFunction"]
    #[link_name = "\u{1}_ZN6isobus24PartneredControlFunctionD1Ev"]
    pub fn isobus_PartneredControlFunction_PartneredControlFunction_destructor(
        this: *mut isobus_PartneredControlFunction,
    );
}
#[repr(C)]
pub struct isobus_CANStackLogger__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @class CANStackLogger\n\n @brief A base class for a CAN logger, used to get diagnostic info from the CAN stack\n @details The CAN stack prints helpful text that may inform you of issues in either the stack\n or your application. You can override a function in this class to begin consuming this\n logging text."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_CANStackLogger {
    pub vtable_: *const isobus_CANStackLogger__bindgen_vtable,
}
extern "C" {
    #[doc = "< A static pointer to an instance of a logger"]
    #[link_name = "\u{1}_ZN6isobus14CANStackLogger6loggerE"]
    pub static mut isobus_CANStackLogger_logger: *mut isobus_CANStackLogger;
}
#[test]
fn bindgen_test_layout_isobus_CANStackLogger() {
    assert_eq!(
        ::std::mem::size_of::<isobus_CANStackLogger>(),
        8usize,
        concat!("Size of: ", stringify!(isobus_CANStackLogger))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_CANStackLogger>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_CANStackLogger))
    );
}
extern "C" {
    #[doc = " @brief Gets called from the CAN stack to log information. Wraps LogCANLibWarning.\n @param[in] warningText The text to be logged"]
    #[link_name = "\u{1}_ZN6isobus14CANStackLogger13CAN_stack_logERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_CANStackLogger_CAN_stack_log(warningText: *const std_string);
}
extern "C" {
    #[doc = " @brief Assigns a derived logger class to be used as the log sink\n @param[in] logSink A pointer to a derived CANStackLogger class"]
    #[link_name = "\u{1}_ZN6isobus14CANStackLogger25set_can_stack_logger_sinkEPS0_"]
    pub fn isobus_CANStackLogger_set_can_stack_logger_sink(logSink: *mut isobus_CANStackLogger);
}
extern "C" {
    #[doc = " @brief The constructor for a CANStackLogger"]
    #[link_name = "\u{1}_ZN6isobus14CANStackLoggerC1Ev"]
    pub fn isobus_CANStackLogger_CANStackLogger(this: *mut isobus_CANStackLogger);
}
extern "C" {
    #[doc = " @brief The destructor for a CANStackLogger"]
    #[link_name = "\u{1}_ZN6isobus14CANStackLoggerD1Ev"]
    pub fn isobus_CANStackLogger_CANStackLogger_destructor(this: *mut isobus_CANStackLogger);
}
impl isobus_CANStackLogger {
    #[inline]
    pub unsafe fn CAN_stack_log(warningText: *const std_string) {
        isobus_CANStackLogger_CAN_stack_log(warningText)
    }
    #[inline]
    pub unsafe fn set_can_stack_logger_sink(logSink: *mut isobus_CANStackLogger) {
        isobus_CANStackLogger_set_can_stack_logger_sink(logSink)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_CANStackLogger_CANStackLogger(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        isobus_CANStackLogger_CANStackLogger_destructor(self)
    }
}
extern "C" {
    #[doc = " @brief Override this to make a log sink for your application\n @param[in] warningText The information being logged"]
    #[link_name = "\u{1}_ZN6isobus14CANStackLogger16LogCANLibWarningERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_CANStackLogger_LogCANLibWarning(
        this: *mut ::std::os::raw::c_void,
        warningText: *const std_string,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct isobus_ProcessingFlags {
    pub callback: isobus_ProcessingFlags_ProcessFlagsCallback,
    pub maxFlag: u32,
    pub flagBitfield: *mut u8,
    pub parent: *mut ::std::os::raw::c_void,
}
pub type isobus_ProcessingFlags_ProcessFlagsCallback = ::std::option::Option<
    unsafe extern "C" fn(flag: u32, parentPointer: *mut ::std::os::raw::c_void),
>;
#[test]
fn bindgen_test_layout_isobus_ProcessingFlags() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_ProcessingFlags> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_ProcessingFlags>(),
        32usize,
        concat!("Size of: ", stringify!(isobus_ProcessingFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_ProcessingFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_ProcessingFlags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ProcessingFlags),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFlag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ProcessingFlags),
            "::",
            stringify!(maxFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flagBitfield) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ProcessingFlags),
            "::",
            stringify!(flagBitfield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_ProcessingFlags),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6isobus15ProcessingFlags8set_flagEj"]
    pub fn isobus_ProcessingFlags_set_flag(this: *mut isobus_ProcessingFlags, flag: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN6isobus15ProcessingFlags17process_all_flagsEv"]
    pub fn isobus_ProcessingFlags_process_all_flags(this: *mut isobus_ProcessingFlags);
}
extern "C" {
    #[link_name = "\u{1}_ZN6isobus15ProcessingFlagsC1EjPFvjPvES1_"]
    pub fn isobus_ProcessingFlags_ProcessingFlags(
        this: *mut isobus_ProcessingFlags,
        numberOfFlags: u32,
        processingCallback: isobus_ProcessingFlags_ProcessFlagsCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6isobus15ProcessingFlagsD1Ev"]
    pub fn isobus_ProcessingFlags_ProcessingFlags_destructor(this: *mut isobus_ProcessingFlags);
}
impl isobus_ProcessingFlags {
    #[inline]
    pub unsafe fn set_flag(&mut self, flag: u32) {
        isobus_ProcessingFlags_set_flag(self, flag)
    }
    #[inline]
    pub unsafe fn process_all_flags(&mut self) {
        isobus_ProcessingFlags_process_all_flags(self)
    }
    #[inline]
    pub unsafe fn new(
        numberOfFlags: u32,
        processingCallback: isobus_ProcessingFlags_ProcessFlagsCallback,
        parentPointer: *mut ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_ProcessingFlags_ProcessingFlags(
            __bindgen_tmp.as_mut_ptr(),
            numberOfFlags,
            processingCallback,
            parentPointer,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        isobus_ProcessingFlags_ProcessingFlags_destructor(self)
    }
}
#[doc = " @class DiagnosticProtocol\n @brief Manages the DM1, DM2, and DM3 messages for ISO11783 or J1939"]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_DiagnosticProtocol {
    pub _base: isobus_CANLibProtocol,
    #[doc = "< The internal control function that this protocol will send from"]
    pub myControlFunction: [u64; 2usize],
    #[doc = "< Keeps track of all the active DTCs"]
    pub activeDTCList: [u64; 3usize],
    #[doc = "< Keeps track of all the previously active DTCs"]
    pub inactiveDTCList: [u64; 3usize],
    #[doc = "< Maintaining a list of DM22 responses we need to send to allow for retrying in case of Tx failures"]
    pub dm22ResponseQueue: [u64; 3usize],
    #[doc = "< Stores the ECU ID fields so we can transmit them when ECUID's PGN is requested"]
    pub ecuIdentificationFields: [u64; 3usize],
    #[doc = "< Stores the Software ID fields so we can transmit them when the PGN is requested"]
    pub softwareIdentificationFields: [u64; 3usize],
    #[doc = "< An instance of the processing flags to handle retries of some messages"]
    pub txFlags: isobus_ProcessingFlags,
    #[doc = "< The product identification code for sending the product identification message"]
    pub productIdentificationCode: std_string,
    #[doc = "< The product identification brand for sending the product identification message"]
    pub productIdentificationBrand: std_string,
    #[doc = "< The product identification model name for sending the product identification message"]
    pub productIdentificationModel: std_string,
    #[doc = "< A timestamp in milliseconds of the last time a DM1 was sent"]
    pub lastDM1SentTimestamp: u32,
    #[doc = "< Bitfield for tracking the network broadcast states for DM13"]
    pub stopBroadcastNetworkBitfield: u32,
    #[doc = "< A timestamp in milliseconds when we last got a DM13 message"]
    pub lastDM13ReceivedTimestamp: u32,
    #[doc = "< Tells the protocol to operate according to J1939 instead of ISO11783"]
    pub j1939Mode: bool,
}
#[doc = "< The part number of the physical ECU"]
pub const isobus_DiagnosticProtocol_ECUIdentificationFields_PartNumber:
    isobus_DiagnosticProtocol_ECUIdentificationFields = 0;
#[doc = "< The serial number of the physical ECU"]
pub const isobus_DiagnosticProtocol_ECUIdentificationFields_SerialNumber:
    isobus_DiagnosticProtocol_ECUIdentificationFields = 1;
#[doc = "< The location of the ECU within a network"]
pub const isobus_DiagnosticProtocol_ECUIdentificationFields_Location:
    isobus_DiagnosticProtocol_ECUIdentificationFields = 2;
#[doc = "< The type of ECU. One example of a use of the ECU type could be for classifying ECU capabilities, such as I/O."]
pub const isobus_DiagnosticProtocol_ECUIdentificationFields_Type:
    isobus_DiagnosticProtocol_ECUIdentificationFields = 3;
#[doc = "< Manufacturer name string"]
pub const isobus_DiagnosticProtocol_ECUIdentificationFields_ManufacturerName:
    isobus_DiagnosticProtocol_ECUIdentificationFields = 4;
#[doc = "< ISO 11783 only, This parameter is used to associate the hardware version of an ECU connected to the ISO 11783 network to a conformance test report of that hardware"]
pub const isobus_DiagnosticProtocol_ECUIdentificationFields_HardwareID:
    isobus_DiagnosticProtocol_ECUIdentificationFields = 5;
#[doc = "< The number of fields currently defined in the ISO standard"]
pub const isobus_DiagnosticProtocol_ECUIdentificationFields_NumberOfFields:
    isobus_DiagnosticProtocol_ECUIdentificationFields = 6;
#[doc = " @brief Enumerates the different fields in the ECU identification message"]
pub type isobus_DiagnosticProtocol_ECUIdentificationFields = u8;
pub const isobus_DiagnosticProtocol_LampStatus_None: isobus_DiagnosticProtocol_LampStatus = 0;
#[doc = "< A lamp used to relay only emissions-related trouble code information"]
pub const isobus_DiagnosticProtocol_LampStatus_MalfunctionIndicatorLampSolid:
    isobus_DiagnosticProtocol_LampStatus = 1;
#[doc = "< A lamp used to relay only emissions-related trouble code information"]
pub const isobus_DiagnosticProtocol_LampStatus_MalfuctionIndicatorLampSlowFlash:
    isobus_DiagnosticProtocol_LampStatus = 2;
#[doc = "< A lamp used to relay only emissions-related trouble code information"]
pub const isobus_DiagnosticProtocol_LampStatus_MalfunctionIndicatorLampFastFlash:
    isobus_DiagnosticProtocol_LampStatus = 3;
#[doc = "< This lamp is used to relay trouble code information that is of a severe-enough condition that it warrants stopping the vehicle"]
pub const isobus_DiagnosticProtocol_LampStatus_RedStopLampSolid:
    isobus_DiagnosticProtocol_LampStatus = 4;
#[doc = "< This lamp is used to relay trouble code information that is of a severe-enough condition that it warrants stopping the vehicle"]
pub const isobus_DiagnosticProtocol_LampStatus_RedStopLampSlowFlash:
    isobus_DiagnosticProtocol_LampStatus = 5;
#[doc = "< This lamp is used to relay trouble code information that is of a severe-enough condition that it warrants stopping the vehicle"]
pub const isobus_DiagnosticProtocol_LampStatus_RedStopLampFastFlash:
    isobus_DiagnosticProtocol_LampStatus = 6;
#[doc = "< This lamp is used to relay trouble code information that is reporting a problem with the vehicle system but the vehicle need not be immediately stopped."]
pub const isobus_DiagnosticProtocol_LampStatus_AmberWarningLampSolid:
    isobus_DiagnosticProtocol_LampStatus = 7;
#[doc = "< This lamp is used to relay trouble code information that is reporting a problem with the vehicle system but the vehicle need not be immediately stopped."]
pub const isobus_DiagnosticProtocol_LampStatus_AmberWarningLampSlowFlash:
    isobus_DiagnosticProtocol_LampStatus = 8;
#[doc = "< This lamp is used to relay trouble code information that is reporting a problem with the vehicle system but the vehicle need not be immediately stopped."]
pub const isobus_DiagnosticProtocol_LampStatus_AmberWarningLampFastFlash:
    isobus_DiagnosticProtocol_LampStatus = 9;
#[doc = "< This lamp is used to relay trouble code information that is reporting a problem with a vehicle system that is most probably not electronic sub-system related"]
pub const isobus_DiagnosticProtocol_LampStatus_EngineProtectLampSolid:
    isobus_DiagnosticProtocol_LampStatus = 10;
#[doc = "< This lamp is used to relay trouble code information that is reporting a problem with a vehicle system that is most probably not electronic sub-system related"]
pub const isobus_DiagnosticProtocol_LampStatus_EngineProtectLampSlowFlash:
    isobus_DiagnosticProtocol_LampStatus = 11;
#[doc = "< This lamp is used to relay trouble code information that is reporting a problem with a vehicle system that is most probably not electronic sub-system related"]
pub const isobus_DiagnosticProtocol_LampStatus_EngineProtectLampFastFlash:
    isobus_DiagnosticProtocol_LampStatus = 12;
#[doc = " @brief The DTC lamp status as defined in J1939-73. Not used when in ISO11783 mode"]
pub type isobus_DiagnosticProtocol_LampStatus = ::std::os::raw::c_int;
#[doc = "< Condition is above normal as determined by the predefined most severe level limits for that particular measure of the condition"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_DataValidAboveNormalMostSevere:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 0;
#[doc = "< Condition is below normal as determined by the predefined most severe level limits for that particular measure of the condition"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_DataValidBelowNormalMostSevere:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 1;
#[doc = "< Erratic or intermittent data include all measurements that change at a rate not considered possible in real - world conditions"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_DataErratic:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 2;
#[doc = "< A voltage signal, data or otherwise, is above the predefined limits that bound the range"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_VoltageAboveNormal:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 3;
#[doc = "< A voltage signal, data or otherwise, is below the predefined limits that bound the range"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_VoltageBelowNormal:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 4;
#[doc = "< A current signal, data or otherwise, is below the predefined limits that bound the range"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_CurrentBelowNormal:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 5;
#[doc = "< A current signal, data or otherwise, is above the predefined limits that bound the range"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_CurrentAboveNormal:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 6;
#[doc = "< Any fault that is detected as the result of an improper mechanical adjustment, an improper response or action of a mechanical system"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_MechanicalSystemNotResponding:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 7;
#[doc = "< Any frequency or PWM signal that is outside the predefined limits which bound the signal range for frequency or duty cycle"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_AbnormalFrequency:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 8;
#[doc = "< Any failure that is detected when receipt of data through the data network is not at the update rate expected or required"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_AbnotmalUpdateRate:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 9;
#[doc = "< Any data, exclusive of FMI 2, that are considered valid but which are changing at a rate that is outside the predefined limits that bound the rate of change for the system"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_AbnormalRateOfChange:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 10;
#[doc = "< It has been detected that a failure has occurred in a particular subsystem but the exact nature of the fault is not known"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_RootCauseNotKnown:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 11;
#[doc = "< Internal diagnostic procedures have determined that the failure is one which requires the replacement of the ECU"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_BadIntellegentDevice:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 12;
#[doc = "< A failure that can be identified as the result of improper calibration"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_OutOfCalibration:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 13;
#[doc = "< Used when the on-board system can isolate the failure to a small number of choices but not to a single point of failure. See 11783-12 Annex E"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_SpecialInstructions:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 14;
#[doc = "< Condition is above what would be considered normal as determined by the predefined least severe level limits for that particular measure of the condition"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_DataValidAboveNormalLeastSevere:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 15;
#[doc = "< Condition is above what would be considered normal as determined by the predefined moderately severe level limits for that particular measure of the condition"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_DataValidAboveNormalModeratelySevere:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 16;
#[doc = "< Condition is below what would be considered normal as determined by the predefined least severe level limits for that particular measure of the condition"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_DataValidBelowNormalLeastSevere:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 17;
#[doc = "< Condition is below what would be considered normal as determined by the predefined moderately severe level limits for that particular measure of the condition"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_DataValidBelowNormalModeratelySevere:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 18;
#[doc = "< Any failure that is detected when the data received through the network are found replaced by the �error indicator� value 0xFE"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_ReceivedNetworkDataInError:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 19;
#[doc = "< The condition that is identified by the SPN exists when no applicable FMI exists (any other error)"]
pub const isobus_DiagnosticProtocol_FailureModeIdentifier_ConditionExists:
    isobus_DiagnosticProtocol_FailureModeIdentifier = 31;
#[doc = " @brief FMI as defined in ISO11783-12 Annex E"]
pub type isobus_DiagnosticProtocol_FailureModeIdentifier = ::std::os::raw::c_int;
#[doc = "< A flag to manage sending the DM1 message"]
pub const isobus_DiagnosticProtocol_TransmitFlags_DM1: isobus_DiagnosticProtocol_TransmitFlags = 0;
#[doc = "< A flag to manage sending the DM2 message"]
pub const isobus_DiagnosticProtocol_TransmitFlags_DM2: isobus_DiagnosticProtocol_TransmitFlags = 1;
#[doc = "< A flag to manage sending the Diagnostic protocol ID message"]
pub const isobus_DiagnosticProtocol_TransmitFlags_DiagnosticProtocolID:
    isobus_DiagnosticProtocol_TransmitFlags = 2;
#[doc = "< A flag to manage sending the product identification message"]
pub const isobus_DiagnosticProtocol_TransmitFlags_ProductIdentification:
    isobus_DiagnosticProtocol_TransmitFlags = 3;
#[doc = "< Process queued up DM22 responses"]
pub const isobus_DiagnosticProtocol_TransmitFlags_DM22: isobus_DiagnosticProtocol_TransmitFlags = 4;
#[doc = "< The number of flags in the enum"]
pub const isobus_DiagnosticProtocol_TransmitFlags_NumberOfFlags:
    isobus_DiagnosticProtocol_TransmitFlags = 5;
#[doc = " @brief A set of transmit flags to manage sending DM1, DM2, and protocol ID"]
pub type isobus_DiagnosticProtocol_TransmitFlags = ::std::os::raw::c_int;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network1PrimaryVehicleNetwork:
    isobus_DiagnosticProtocol_Network = 0;
pub const isobus_DiagnosticProtocol_Network_SAEJ1922Network: isobus_DiagnosticProtocol_Network = 1;
pub const isobus_DiagnosticProtocol_Network_SAEJ1587Network: isobus_DiagnosticProtocol_Network = 2;
pub const isobus_DiagnosticProtocol_Network_CurrentDataLink: isobus_DiagnosticProtocol_Network = 3;
pub const isobus_DiagnosticProtocol_Network_OtherManufacturerSpecifiedPort:
    isobus_DiagnosticProtocol_Network = 4;
pub const isobus_DiagnosticProtocol_Network_SAEJ1850Network: isobus_DiagnosticProtocol_Network = 5;
pub const isobus_DiagnosticProtocol_Network_ISO9141Network: isobus_DiagnosticProtocol_Network = 6;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network2: isobus_DiagnosticProtocol_Network = 7;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network4: isobus_DiagnosticProtocol_Network = 8;
pub const isobus_DiagnosticProtocol_Network_ProprietaryNetwork2: isobus_DiagnosticProtocol_Network =
    9;
pub const isobus_DiagnosticProtocol_Network_ProprietaryNetwork1: isobus_DiagnosticProtocol_Network =
    10;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network3: isobus_DiagnosticProtocol_Network =
    11;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network5: isobus_DiagnosticProtocol_Network =
    25;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network6: isobus_DiagnosticProtocol_Network =
    26;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network7: isobus_DiagnosticProtocol_Network =
    27;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network8: isobus_DiagnosticProtocol_Network =
    28;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network11: isobus_DiagnosticProtocol_Network =
    29;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network10: isobus_DiagnosticProtocol_Network =
    30;
pub const isobus_DiagnosticProtocol_Network_SAEJ1939Network9: isobus_DiagnosticProtocol_Network =
    31;
pub const isobus_DiagnosticProtocol_Network_Reserved: isobus_DiagnosticProtocol_Network = 32;
#[doc = " @brief Enumerates the different networks in the DM13"]
pub type isobus_DiagnosticProtocol_Network = u8;
#[doc = "< Stop broadcast"]
pub const isobus_DiagnosticProtocol_StopStartCommand_StopBroadcast:
    isobus_DiagnosticProtocol_StopStartCommand = 0;
#[doc = "< Start broadcast"]
pub const isobus_DiagnosticProtocol_StopStartCommand_StartBroadcast:
    isobus_DiagnosticProtocol_StopStartCommand = 1;
#[doc = "< SAE Reserved"]
pub const isobus_DiagnosticProtocol_StopStartCommand_Reserved:
    isobus_DiagnosticProtocol_StopStartCommand = 2;
#[doc = "< Don’t Care/take no action (leave as is)"]
pub const isobus_DiagnosticProtocol_StopStartCommand_DontCareNoAction:
    isobus_DiagnosticProtocol_StopStartCommand = 3;
#[doc = " @brief Enumerates the commands in the DM13"]
pub type isobus_DiagnosticProtocol_StopStartCommand = u8;
#[doc = "< Indefinite suspension of all broadcasts"]
pub const isobus_DiagnosticProtocol_SuspendSignalState_IndefiniteSuspension:
    isobus_DiagnosticProtocol_SuspendSignalState = 0;
#[doc = "< Indefinite suspension of some messages"]
pub const isobus_DiagnosticProtocol_SuspendSignalState_PartialIndefiniteSuspension:
    isobus_DiagnosticProtocol_SuspendSignalState = 1;
#[doc = "< Temporary suspension of all broadcasts"]
pub const isobus_DiagnosticProtocol_SuspendSignalState_TemporarySuspension:
    isobus_DiagnosticProtocol_SuspendSignalState = 2;
#[doc = "< Temporary suspension of some messages"]
pub const isobus_DiagnosticProtocol_SuspendSignalState_PartialTemporarySuspension:
    isobus_DiagnosticProtocol_SuspendSignalState = 3;
#[doc = "< Resuming normal broadcast pattern"]
pub const isobus_DiagnosticProtocol_SuspendSignalState_Resuming:
    isobus_DiagnosticProtocol_SuspendSignalState = 4;
pub const isobus_DiagnosticProtocol_SuspendSignalState_NotAvailable:
    isobus_DiagnosticProtocol_SuspendSignalState = 15;
#[doc = " @brief Enumerates the different suspend signals for DM13"]
pub type isobus_DiagnosticProtocol_SuspendSignalState = u8;
#[doc = " @class DiagnosticTroubleCode\n @brief A storage class for describing a complete DTC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_DiagnosticProtocol_DiagnosticTroubleCode {
    #[doc = "< This 19-bit number is used to identify the item for which diagnostics are being reported"]
    pub suspectParameterNumber: u32,
    #[doc = "< The FMI defines the type of failure detected in the sub-system identified by an SPN"]
    pub failureModeIdentifier: u8,
    #[doc = "< The J1939 lamp state for this DTC"]
    pub lampState: isobus_DiagnosticProtocol_LampStatus,
    #[doc = "< Number of times the DTC has been active (0 to 126 with 127 being not available)"]
    pub occuranceCount: u8,
}
#[test]
fn bindgen_test_layout_isobus_DiagnosticProtocol_DiagnosticTroubleCode() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_DiagnosticProtocol_DiagnosticTroubleCode> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_DiagnosticProtocol_DiagnosticTroubleCode>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(isobus_DiagnosticProtocol_DiagnosticTroubleCode)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_DiagnosticProtocol_DiagnosticTroubleCode>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_DiagnosticProtocol_DiagnosticTroubleCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suspectParameterNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DiagnosticTroubleCode),
            "::",
            stringify!(suspectParameterNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failureModeIdentifier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DiagnosticTroubleCode),
            "::",
            stringify!(failureModeIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lampState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DiagnosticTroubleCode),
            "::",
            stringify!(lampState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).occuranceCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DiagnosticTroubleCode),
            "::",
            stringify!(occuranceCount)
        )
    );
}
extern "C" {
    #[doc = "  @brief Returns the occurance count, which will be kept track of by the protocol"]
    #[link_name = "\u{1}_ZNK6isobus18DiagnosticProtocol21DiagnosticTroubleCode20get_occurrance_countEv"]
    pub fn isobus_DiagnosticProtocol_DiagnosticTroubleCode_get_occurrance_count(
        this: *const isobus_DiagnosticProtocol_DiagnosticTroubleCode,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Constructor for a DTC, sets default values at construction time\n @param[in] internalControlFunction The internal control function to use for sending messages"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol21DiagnosticTroubleCodeC1Ev"]
    pub fn isobus_DiagnosticProtocol_DiagnosticTroubleCode_DiagnosticTroubleCode(
        this: *mut isobus_DiagnosticProtocol_DiagnosticTroubleCode,
    );
}
extern "C" {
    #[doc = " @brief Constructor for a DTC, sets all values explicitly\n @param[in] spn The suspect parameter number\n @param[in] fmi The failure mode indicator\n @param[in] lamp The J1939 lamp status. Set to `None` if you don't care about J1939"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol21DiagnosticTroubleCodeC1EjNS0_21FailureModeIdentifierENS0_10LampStatusE"]
    pub fn isobus_DiagnosticProtocol_DiagnosticTroubleCode_DiagnosticTroubleCode1(
        this: *mut isobus_DiagnosticProtocol_DiagnosticTroubleCode,
        spn: u32,
        fmi: isobus_DiagnosticProtocol_FailureModeIdentifier,
        lamp: isobus_DiagnosticProtocol_LampStatus,
    );
}
impl isobus_DiagnosticProtocol_DiagnosticTroubleCode {
    #[inline]
    pub unsafe fn get_occurrance_count(&self) -> u8 {
        isobus_DiagnosticProtocol_DiagnosticTroubleCode_get_occurrance_count(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_DiagnosticProtocol_DiagnosticTroubleCode_DiagnosticTroubleCode(
            __bindgen_tmp.as_mut_ptr(),
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        spn: u32,
        fmi: isobus_DiagnosticProtocol_FailureModeIdentifier,
        lamp: isobus_DiagnosticProtocol_LampStatus,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_DiagnosticProtocol_DiagnosticTroubleCode_DiagnosticTroubleCode1(
            __bindgen_tmp.as_mut_ptr(),
            spn,
            fmi,
            lamp,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = "< The \"MIL\""]
pub const isobus_DiagnosticProtocol_Lamps_MalfunctionIndicatorLamp:
    isobus_DiagnosticProtocol_Lamps = 0;
#[doc = "< The \"RSL\""]
pub const isobus_DiagnosticProtocol_Lamps_RedStopLamp: isobus_DiagnosticProtocol_Lamps = 1;
#[doc = "< The \"AWL\""]
pub const isobus_DiagnosticProtocol_Lamps_AmberWarningLamp: isobus_DiagnosticProtocol_Lamps = 2;
#[doc = "< The engine protect lamp"]
pub const isobus_DiagnosticProtocol_Lamps_ProtectLamp: isobus_DiagnosticProtocol_Lamps = 3;
#[doc = " @brief Lists the different lamps in J1939-73"]
pub type isobus_DiagnosticProtocol_Lamps = ::std::os::raw::c_int;
#[doc = "< Solid / no flash"]
pub const isobus_DiagnosticProtocol_FlashState_Solid: isobus_DiagnosticProtocol_FlashState = 0;
#[doc = "< Slow flash"]
pub const isobus_DiagnosticProtocol_FlashState_Slow: isobus_DiagnosticProtocol_FlashState = 1;
#[doc = "< Fast flash"]
pub const isobus_DiagnosticProtocol_FlashState_Fast: isobus_DiagnosticProtocol_FlashState = 2;
#[doc = " @brief Enumerates lamp flash states in J1939"]
pub type isobus_DiagnosticProtocol_FlashState = ::std::os::raw::c_int;
#[doc = "< Clear a previously active DTC"]
pub const isobus_DiagnosticProtocol_DM22ControlByte_RequestToClearPreviouslyActiveDTC:
    isobus_DiagnosticProtocol_DM22ControlByte = 1;
#[doc = "< ACK for clearing a previously active DTC"]
pub const isobus_DiagnosticProtocol_DM22ControlByte_PositiveAcknowledgeOfPreviouslyActiveDTCClear : isobus_DiagnosticProtocol_DM22ControlByte = 2 ;
#[doc = "< NACK for clearing a previously active DTC"]
pub const isobus_DiagnosticProtocol_DM22ControlByte_NegativeAcknowledgeOfPreviouslyActiveDTCClear : isobus_DiagnosticProtocol_DM22ControlByte = 3 ;
#[doc = "< Clear an active DTC"]
pub const isobus_DiagnosticProtocol_DM22ControlByte_RequestToClearActiveDTC:
    isobus_DiagnosticProtocol_DM22ControlByte = 17;
#[doc = "< ACK clearing an active DTC"]
pub const isobus_DiagnosticProtocol_DM22ControlByte_PositiveAcknowledgeOfActiveDTCClear:
    isobus_DiagnosticProtocol_DM22ControlByte = 18;
#[doc = "< NACK clearing an active DTC"]
pub const isobus_DiagnosticProtocol_DM22ControlByte_NegativeAcknowledgeOfActiveDTCClear:
    isobus_DiagnosticProtocol_DM22ControlByte = 19;
#[doc = " @brief The DM22 multiplexor bytes. All bytes not given a value here are reserved by SAE"]
pub type isobus_DiagnosticProtocol_DM22ControlByte = u8;
#[doc = "< General negative acknowledge"]
pub const isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator_General:
    isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator = 0;
#[doc = "< Security denied access"]
pub const isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator_AccessDenied:
    isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator = 1;
#[doc = "< The DTC is unknown or does not exist"]
pub const isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator_UnknownOrDoesNotExist:
    isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator = 2;
#[doc = "< The DTC in in the active list but it was requested to clear from inactive list"]
pub const isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator_DTCUNoLongerPreviouslyActive : isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator = 3 ;
#[doc = "< DTC is inactive, not active, but active was requested to be cleared"]
pub const isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator_DTCNoLongerActive:
    isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator = 4;
#[doc = " @brief The negative acknowledge (NACK) reasons for a DM22 message"]
pub type isobus_DiagnosticProtocol_DM22NegativeAcknowledgeIndicator = u8;
#[doc = " @brief A structure to hold data about DM22 responses we need to send"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_DiagnosticProtocol_DM22Data {
    #[doc = "< Destination for the DM22 message"]
    pub destination: *mut isobus_ControlFunction,
    #[doc = "< SPN of the DTC for the DM22"]
    pub suspectParameterNumber: u32,
    #[doc = "< FMI of the DTC for the DM22"]
    pub failureModeIdentifier: u8,
    #[doc = "< The NACK reason, if applicable"]
    pub nackIndicator: u8,
    #[doc = "< true if the DM22 was for an active DTC, false for previously active"]
    pub clearActive: bool,
    #[doc = "< true if we are sending a NACK instead of PACK. Determines if we use nackIndicator"]
    pub nack: bool,
}
#[test]
fn bindgen_test_layout_isobus_DiagnosticProtocol_DM22Data() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_DiagnosticProtocol_DM22Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_DiagnosticProtocol_DM22Data>(),
        16usize,
        concat!("Size of: ", stringify!(isobus_DiagnosticProtocol_DM22Data))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_DiagnosticProtocol_DM22Data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_DiagnosticProtocol_DM22Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DM22Data),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suspectParameterNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DM22Data),
            "::",
            stringify!(suspectParameterNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failureModeIdentifier) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DM22Data),
            "::",
            stringify!(failureModeIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nackIndicator) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DM22Data),
            "::",
            stringify!(nackIndicator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clearActive) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DM22Data),
            "::",
            stringify!(clearActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nack) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol_DM22Data),
            "::",
            stringify!(nack)
        )
    );
}
#[doc = "< You are techically allowed to send more than this under limited circumstances, but a hard limit saves 4 RAM bytes per DTC and has BAM benefits"]
pub const isobus_DiagnosticProtocol_DM_MAX_FREQUENCY_MS: u32 = 1000;
#[doc = "< Defined in 5.7.13.13 SPN 1236"]
pub const isobus_DiagnosticProtocol_DM13_HOLD_SIGNAL_TRANSMIT_INTERVAL_MS: u32 = 5000;
#[doc = "< The timout in 5.7.13 after which nodes shall revert back to the normal broadcast state"]
pub const isobus_DiagnosticProtocol_DM13_TIMEOUT_MS: u32 = 6000;
#[doc = "< DM 1 and 2 are limited to the BAM message max, becuase ETP does not allow global destinations"]
pub const isobus_DiagnosticProtocol_MAX_PAYLOAD_SIZE_BYTES: u16 = 1785;
#[doc = "< The number of payload bytes per DTC that gets encoded into the messages"]
pub const isobus_DiagnosticProtocol_DM_PAYLOAD_BYTES_PER_DTC: u8 = 4;
#[doc = "< The max string length allowed in the fields of product ID, as defined in ISO 11783-12"]
pub const isobus_DiagnosticProtocol_PRODUCT_IDENTIFICATION_MAX_STRING_LENGTH: u8 = 50;
#[doc = "< The number of networks in DM13 that are set aside for J1939"]
pub const isobus_DiagnosticProtocol_DM13_NUMBER_OF_J1939_NETWORKS: u8 = 11;
#[doc = "< Used to mask the network SPN values"]
pub const isobus_DiagnosticProtocol_DM13_NETWORK_BITMASK: u8 = 3;
#[doc = "< Number of bits for the network SPNs"]
pub const isobus_DiagnosticProtocol_DM13_BITS_PER_NETWORK: u8 = 2;
extern "C" {
    #[doc = " @brief Lists the J1939 networks by index rather than by definition in J1939-73 5.7.13"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol20J1939NetworkIndiciesE"]
    pub static isobus_DiagnosticProtocol_J1939NetworkIndicies:
        [isobus_DiagnosticProtocol_Network; 11usize];
}
extern "C" {
    #[doc = "< List of all diagnostic protocol instances (one per ICF)"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol22diagnosticProtocolListB5cxx11E"]
    pub static mut isobus_DiagnosticProtocol_diagnosticProtocolList: u8;
}
#[test]
fn bindgen_test_layout_isobus_DiagnosticProtocol() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_DiagnosticProtocol> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_DiagnosticProtocol>(),
        296usize,
        concat!("Size of: ", stringify!(isobus_DiagnosticProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_DiagnosticProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_DiagnosticProtocol))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).myControlFunction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(myControlFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activeDTCList) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(activeDTCList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inactiveDTCList) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(inactiveDTCList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dm22ResponseQueue) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(dm22ResponseQueue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecuIdentificationFields) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(ecuIdentificationFields)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).softwareIdentificationFields) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(softwareIdentificationFields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txFlags) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(txFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).productIdentificationCode) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(productIdentificationCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).productIdentificationBrand) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(productIdentificationBrand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).productIdentificationModel) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(productIdentificationModel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastDM1SentTimestamp) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(lastDM1SentTimestamp)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).stopBroadcastNetworkBitfield) as usize - ptr as usize
        },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(stopBroadcastNetworkBitfield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastDM13ReceivedTimestamp) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(lastDM13ReceivedTimestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).j1939Mode) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_DiagnosticProtocol),
            "::",
            stringify!(j1939Mode)
        )
    );
}
extern "C" {
    #[doc = " @brief Used to tell the CAN stack that diagnostic messages should be sent from the specified internal control function\n @details This will allocate an instance of this protocol\n @note Assigning the diagnostic protocol to an ICF will automatically create an instance of the PGN request protocol if needed\n as this protocol uses that protocol to abstract away PGN request implementation details. That protocol instance will\n only be deleted if you call deassign_diagnostic_protocol_to_internal_control_function and the DP PGNs were the only registered PGNs in\n the protocol OR if you manually deassign the PGN request protocol.\n Most people will not need to worry about this detail.\n @returns `true` If the protocol instance was created OK with the passed in ICF"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol55assign_diagnostic_protocol_to_internal_control_functionESt10shared_ptrINS_23InternalControlFunctionEE"]
    pub fn isobus_DiagnosticProtocol_assign_diagnostic_protocol_to_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Used to tell the CAN stack that diagnostic messages should no longer be sent from the specified internal control function\n @details This will delete an instance of this protocol and may delete an associated but unused instance of the PGN request protocol.\n @returns `true` If the protocol instance was deleted OK according to the passed in ICF"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol57deassign_diagnostic_protocol_to_internal_control_functionESt10shared_ptrINS_23InternalControlFunctionEE"]
    pub fn isobus_DiagnosticProtocol_deassign_diagnostic_protocol_to_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Retuns the diagnostic protocol assigned to an internal control function, if any\n @param internalControlFunction The internal control function to search against\n @returns The protocol object associated to the passed in ICF, or `nullptr` if none found that match the passed in ICF"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol52get_diagnostic_protocol_by_internal_control_functionESt10shared_ptrINS_23InternalControlFunctionEE"]
    pub fn isobus_DiagnosticProtocol_get_diagnostic_protocol_by_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> *mut isobus_DiagnosticProtocol;
}
extern "C" {
    #[doc = " @brief Parses out the DM13 J1939 network states from a CAN message\n @param[in] message The message to parse from\n @param[in] networkStates The returned network state bitfield based on the message contents\n @returns `true` if the message was parsed, `false` if the message was invalid"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol26parse_j1939_network_statesEPNS_10CANMessageERj"]
    pub fn isobus_DiagnosticProtocol_parse_j1939_network_states(
        message: *mut isobus_CANMessage,
        networkStates: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Enables the protocol to run in J1939 mode instead of ISO11783 mode\n @details See ISO11783-12 and J1939-73 for a complete explanation of the differences\n @param[in] value The desired mode. `true` for J1939 mode, `false` for ISO11783 mode"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol14set_j1939_modeEb"]
    pub fn isobus_DiagnosticProtocol_set_j1939_mode(
        this: *mut isobus_DiagnosticProtocol,
        value: bool,
    );
}
extern "C" {
    #[doc = " @brief Returns `true` if the protocol is in J1939 mode instead of ISO11783 mode, `false` if using ISO11783 mode\n @returns `true` if the protocol is in J1939 mode instead of ISO11783 mode, `false` if using ISO11783 mode"]
    #[link_name = "\u{1}_ZNK6isobus18DiagnosticProtocol14get_j1939_modeEv"]
    pub fn isobus_DiagnosticProtocol_get_j1939_mode(this: *const isobus_DiagnosticProtocol)
        -> bool;
}
extern "C" {
    #[doc = " @brief Clears the list of active DTCs and makes them all inactive"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol37clear_active_diagnostic_trouble_codesEv"]
    pub fn isobus_DiagnosticProtocol_clear_active_diagnostic_trouble_codes(
        this: *mut isobus_DiagnosticProtocol,
    );
}
extern "C" {
    #[doc = " @brief Clears the list of inactive DTCs and clears occurance counts"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol39clear_inactive_diagnostic_trouble_codesEv"]
    pub fn isobus_DiagnosticProtocol_clear_inactive_diagnostic_trouble_codes(
        this: *mut isobus_DiagnosticProtocol,
    );
}
extern "C" {
    #[doc = " @brief Clears all previously configured software ID fields set with set_software_id_field"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol24clear_software_id_fieldsEv"]
    pub fn isobus_DiagnosticProtocol_clear_software_id_fields(this: *mut isobus_DiagnosticProtocol);
}
extern "C" {
    #[doc = " @brief Returns if broadcasts are suspended for the specified CAN channel (requested by DM13)\n @param[in] canChannelIndex The CAN channel to check for suspended broadcasts\n @returns `true` if broadcasts should are suspended for the specified channel"]
    #[link_name = "\u{1}_ZNK6isobus18DiagnosticProtocol38get_are_broadcasts_stopped_for_channelEh"]
    pub fn isobus_DiagnosticProtocol_get_are_broadcasts_stopped_for_channel(
        this: *const isobus_DiagnosticProtocol,
        canChannelIndex: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sets one of the ECU identification strings for the ECU ID message\n @details See ECUIdentificationFields for a brief description of the fields\n @note The fields in this message are optional and separated by an ASCII �*�. It is not necessary to include parametric\n data for all fields. Any additional ECU identification fields defined in the future will be appended at the end.\n @attention Do not include the \"*\" character in your field values\n @param[in] field The field to set\n @param[in] value The string value associated with the ECU ID field"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol16set_ecu_id_fieldENS0_23ECUIdentificationFieldsENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_DiagnosticProtocol_set_ecu_id_field(
        this: *mut isobus_DiagnosticProtocol,
        field: isobus_DiagnosticProtocol_ECUIdentificationFields,
        value: std_string,
    );
}
extern "C" {
    #[doc = " @brief Adds a DTC to the active list, or removes one from the active list\n @details When you call this function with a DTC and `true`, it will be added to the DM1 message.\n When you call it with a DTC and `false` it will be moved to the inactive list.\n If you get `false` as a return value, either the DTC was already in the target state or the data was not valid\n @param[in] dtc A diagnostic trouble code whose state should be altered\n @param[in] active Sets if the DTC is currently active or not\n @returns True if the DTC was added/removed from the list, false if DTC was not valid or target state is invalid"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol34set_diagnostic_trouble_code_activeERKNS0_21DiagnosticTroubleCodeEb"]
    pub fn isobus_DiagnosticProtocol_set_diagnostic_trouble_code_active(
        this: *mut isobus_DiagnosticProtocol,
        dtc: *const isobus_DiagnosticProtocol_DiagnosticTroubleCode,
        active: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if a DTC is active\n @param[in] dtc A diagnostic trouble code whose state should be altered\n @returns `true` if the DTC was in the active list"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol34get_diagnostic_trouble_code_activeERKNS0_21DiagnosticTroubleCodeE"]
    pub fn isobus_DiagnosticProtocol_get_diagnostic_trouble_code_active(
        this: *mut isobus_DiagnosticProtocol,
        dtc: *const isobus_DiagnosticProtocol_DiagnosticTroubleCode,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the product ID code used in the diagnostic protocol \"Product Identification\" message (PGN 0xFC8D)\n @details The product identification code, as assigned by the manufacturer, corresponds with the number on the\n type plate of a product. For vehicles, this number can be the same as the VIN. For stand-alone systems, such as VTs,\n this number can be the same as the ECU ID number. The combination of the product identification code and brand shall\n make the product globally unique.\n @param value The ascii product identification code, up to 50 characters long\n @returns true if the value was set, false if the string is too long"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol31set_product_identification_codeENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_DiagnosticProtocol_set_product_identification_code(
        this: *mut isobus_DiagnosticProtocol,
        value: std_string,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the product identification brand used in the diagnostic protocol \"Product Identification\" message (PGN 0xFC8D)\n @details The product identification brand specifies the brand of a product. The combination of the product ID code and brand\n shall make the product unique in the world.\n @param value The ascii product brand, up to 50 characters long\n @returns true if the value was set, false if the string is too long"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol32set_product_identification_brandENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_DiagnosticProtocol_set_product_identification_brand(
        this: *mut isobus_DiagnosticProtocol,
        value: std_string,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the product identification model used in the diagnostic protocol \"Product Identification\" message (PGN 0xFC8D)\n @details The product identification model specifies a unique product within a brand.\n @param value The ascii model string, up to 50 characters\n @returns true if the value was set, false if the string is too long"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol32set_product_identification_modelENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_DiagnosticProtocol_set_product_identification_model(
        this: *mut isobus_DiagnosticProtocol,
        value: std_string,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Adds an ascii string to this internal control function's software ID\n @details Use this to identify the software version of your application.\n Seperate fields will be transmitted with a `*` delimeter.\n For example, if your main application's version is 1.00, and you have a bootloader\n that is version 2.00, you could set field `0` to be \"App v1.00\" and\n field `1` to be \"Bootloader v2.00\", and it will be transmitted on request as:\n \"App v1.00*Bootloader v2.00*\" in accordance with ISO 11783-12\n You can remove a field by setting it to \"\"\n @param[in] index The field index to set\n @param[in] value The software ID string to add"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol21set_software_id_fieldEjNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_DiagnosticProtocol_set_software_id_field(
        this: *mut isobus_DiagnosticProtocol,
        index: u32,
        value: std_string,
    );
}
extern "C" {
    #[doc = " @brief Informs the network that you are going to suspend broadcasts\n @param[in] canChannelIndex The CAN channel you will suspend broadcasts on. Will be converted to the proper message `Network` by the stack\n @param[in] sourceControlFunction The internal control function to send the DM13 from\n @param[in] suspendTime_seconds If you know the time for which broadcasts will be suspended, put it here, otherwise 0xFFFF\n @returns `true` if the message was sent, otherwise `false`"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol18suspend_broadcastsEhPNS_23InternalControlFunctionEt"]
    pub fn isobus_DiagnosticProtocol_suspend_broadcasts(
        this: *mut isobus_DiagnosticProtocol,
        canChannelIndex: u8,
        sourceControlFunction: *mut isobus_InternalControlFunction,
        suspendTime_seconds: u16,
    ) -> bool;
}
impl isobus_DiagnosticProtocol {
    #[inline]
    pub unsafe fn assign_diagnostic_protocol_to_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> bool {
        isobus_DiagnosticProtocol_assign_diagnostic_protocol_to_internal_control_function(
            internalControlFunction,
        )
    }
    #[inline]
    pub unsafe fn deassign_diagnostic_protocol_to_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> bool {
        isobus_DiagnosticProtocol_deassign_diagnostic_protocol_to_internal_control_function(
            internalControlFunction,
        )
    }
    #[inline]
    pub unsafe fn get_diagnostic_protocol_by_internal_control_function(
        internalControlFunction: [u64; 2usize],
    ) -> *mut isobus_DiagnosticProtocol {
        isobus_DiagnosticProtocol_get_diagnostic_protocol_by_internal_control_function(
            internalControlFunction,
        )
    }
    #[inline]
    pub unsafe fn parse_j1939_network_states(
        message: *mut isobus_CANMessage,
        networkStates: *mut u32,
    ) -> bool {
        isobus_DiagnosticProtocol_parse_j1939_network_states(message, networkStates)
    }
    #[inline]
    pub unsafe fn set_j1939_mode(&mut self, value: bool) {
        isobus_DiagnosticProtocol_set_j1939_mode(self, value)
    }
    #[inline]
    pub unsafe fn get_j1939_mode(&self) -> bool {
        isobus_DiagnosticProtocol_get_j1939_mode(self)
    }
    #[inline]
    pub unsafe fn clear_active_diagnostic_trouble_codes(&mut self) {
        isobus_DiagnosticProtocol_clear_active_diagnostic_trouble_codes(self)
    }
    #[inline]
    pub unsafe fn clear_inactive_diagnostic_trouble_codes(&mut self) {
        isobus_DiagnosticProtocol_clear_inactive_diagnostic_trouble_codes(self)
    }
    #[inline]
    pub unsafe fn clear_software_id_fields(&mut self) {
        isobus_DiagnosticProtocol_clear_software_id_fields(self)
    }
    #[inline]
    pub unsafe fn get_are_broadcasts_stopped_for_channel(&self, canChannelIndex: u8) -> bool {
        isobus_DiagnosticProtocol_get_are_broadcasts_stopped_for_channel(self, canChannelIndex)
    }
    #[inline]
    pub unsafe fn set_ecu_id_field(
        &mut self,
        field: isobus_DiagnosticProtocol_ECUIdentificationFields,
        value: std_string,
    ) {
        isobus_DiagnosticProtocol_set_ecu_id_field(self, field, value)
    }
    #[inline]
    pub unsafe fn set_diagnostic_trouble_code_active(
        &mut self,
        dtc: *const isobus_DiagnosticProtocol_DiagnosticTroubleCode,
        active: bool,
    ) -> bool {
        isobus_DiagnosticProtocol_set_diagnostic_trouble_code_active(self, dtc, active)
    }
    #[inline]
    pub unsafe fn get_diagnostic_trouble_code_active(
        &mut self,
        dtc: *const isobus_DiagnosticProtocol_DiagnosticTroubleCode,
    ) -> bool {
        isobus_DiagnosticProtocol_get_diagnostic_trouble_code_active(self, dtc)
    }
    #[inline]
    pub unsafe fn set_product_identification_code(&mut self, value: std_string) -> bool {
        isobus_DiagnosticProtocol_set_product_identification_code(self, value)
    }
    #[inline]
    pub unsafe fn set_product_identification_brand(&mut self, value: std_string) -> bool {
        isobus_DiagnosticProtocol_set_product_identification_brand(self, value)
    }
    #[inline]
    pub unsafe fn set_product_identification_model(&mut self, value: std_string) -> bool {
        isobus_DiagnosticProtocol_set_product_identification_model(self, value)
    }
    #[inline]
    pub unsafe fn set_software_id_field(&mut self, index: u32, value: std_string) {
        isobus_DiagnosticProtocol_set_software_id_field(self, index, value)
    }
    #[inline]
    pub unsafe fn suspend_broadcasts(
        &mut self,
        canChannelIndex: u8,
        sourceControlFunction: *mut isobus_InternalControlFunction,
        suspendTime_seconds: u16,
    ) -> bool {
        isobus_DiagnosticProtocol_suspend_broadcasts(
            self,
            canChannelIndex,
            sourceControlFunction,
            suspendTime_seconds,
        )
    }
}
extern "C" {
    #[doc = " @brief The protocol's initializer function"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol10initializeENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_DiagnosticProtocol_initialize(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
extern "C" {
    #[doc = " @brief Updates the protocol cyclically"]
    #[link_name = "\u{1}_ZN6isobus18DiagnosticProtocol6updateENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_DiagnosticProtocol_update(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
#[doc = " @class VirtualTerminalClient\n\n @brief An client interface for interacting with a virtual terminal (VT) server\n @details This class is the main interface for working with a VT. To use it,\n you must instantiate it with a source and partner control function, and set and one or more\n object pools to this class to be uploaded to the VT server. Once this setup is done, call\n the initialize function to start running the internal state machine. The stack will take care\n of uploading the object pool, and then you will be able to interact with the pool using the\n provided \"send\" functions from your application."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_VirtualTerminalClient {
    #[doc = "< The partner control function this client will send to"]
    pub partnerControlFunction: [u64; 2usize],
    #[doc = "< The internal control function the client uses to send from"]
    pub myControlFunction: [u64; 2usize],
    #[doc = "< A retry mechanism for internal Tx messages"]
    pub txFlags: isobus_ProcessingFlags,
    #[doc = "< The timestamp of the last VT status message"]
    pub lastVTStatusTimestamp_ms: u32,
    #[doc = "< The active working set data mask object ID"]
    pub activeWorkingSetDataMaskObjectID: u16,
    #[doc = "< The active working set's softkey mask object ID"]
    pub activeWorkingSetSoftkeyMaskObjectID: u16,
    #[doc = "< The active working set master address"]
    pub activeWorkingSetMasterAddress: u8,
    #[doc = "< The VT server's busy codes"]
    pub busyCodesBitfield: u8,
    #[doc = "< The VT server's current command function code"]
    pub currentCommandFunctionCode: u8,
    #[doc = "< The VT server's supported max version"]
    pub connectedVTVersion: u8,
    #[doc = "< The size of a soft key X dimension as reported by the VT server"]
    pub softKeyXAxisPixels: u8,
    #[doc = "< The size of a soft key Y dimension as reported by the VT server"]
    pub softKeyYAxisPixels: u8,
    #[doc = "< The number of virtual softkeys per softkey mask as reported by the VT server"]
    pub numberVirtualSoftkeysPerSoftkeyMask: u8,
    #[doc = "< The number of physical softkeys supported by the VT server"]
    pub numberPhysicalSoftkeys: u8,
    #[doc = "< The small font sizes supported by the VT server"]
    pub smallFontSizesBitfield: u8,
    #[doc = "< The large font sizes supported by the VT server"]
    pub largeFontSizesBitfield: u8,
    #[doc = "< The text font capabilities supported by the VT server"]
    pub fontStylesBitfield: u8,
    #[doc = "< The graphics mode reported by the VT server"]
    pub supportedGraphicsMode: isobus_VirtualTerminalClient_GraphicMode,
    #[doc = "< The x pixel dimension as reported by the VT server"]
    pub xPixels: u16,
    #[doc = "< The y pixel dimension as reported by the VT server"]
    pub yPixels: u16,
    #[doc = "< The reported hardware features from the VT server"]
    pub hardwareFeaturesBitfield: u8,
    #[doc = "< The current client state machine state"]
    pub state: isobus_VirtualTerminalClient_StateMachineState,
    #[doc = "< The current upload state of the object pool being processed"]
    pub currentObjectPoolState: isobus_VirtualTerminalClient_CurrentObjectPoolUploadState,
    #[doc = "< Timestamp from the last state machine update"]
    pub stateMachineTimestamp_ms: u32,
    #[doc = "< The timestamp from the last time we sent the maintenance message"]
    pub lastWorkingSetMaintenanceTimestamp_ms: u32,
    #[doc = "< A container to hold all object pools that have been assigned to the interface"]
    pub objectPools: [u64; 3usize],
    #[doc = "< The worker thread that updates this interface"]
    pub workerThread: *mut std_thread,
    #[doc = "< Stores the client initialization state"]
    pub initialized: bool,
    #[doc = "< Used internally to enable and disable cyclic sending of the maintenance message"]
    pub sendWorkingSetMaintenenace: bool,
    #[doc = "< Used to determine if the client should exit and join the worker thread"]
    pub shouldTerminate: bool,
    #[doc = "< A list of all button event callbacks"]
    pub buttonEventCallbacks: [u64; 3usize],
    #[doc = "< A list of all soft key event callbacks"]
    pub softKeyEventCallbacks: [u64; 3usize],
    #[doc = "< A list of all pointing event callbacks"]
    pub pointingEventCallbacks: [u64; 3usize],
    #[doc = "< A list of all select input object callbacks"]
    pub selectInputObjectCallbacks: [u64; 3usize],
    #[doc = "< A list of all ESC event callbacks"]
    pub escMessageCallbacks: [u64; 3usize],
    #[doc = "< A list of all change numeric value callbacks"]
    pub changeNumericValueCallbacks: [u64; 3usize],
    #[doc = "< A list of all change active mask callbacks"]
    pub changeActiveMaskCallbacks: [u64; 3usize],
    #[doc = "< A list of all change soft key mask callbacks"]
    pub changeSoftKeyMaskCallbacks: [u64; 3usize],
    #[doc = "< A list of all change string value callbacks"]
    pub changeStringValueCallbacks: [u64; 3usize],
    #[doc = "< A list of all user layout hide/show callbacks"]
    pub userLayoutHideShowCallbacks: [u64; 3usize],
    #[doc = "< A list of all control audio signal termination callbacks"]
    pub audioSignalTerminationCallbacks: [u64; 3usize],
    #[doc = "< The callback to use to get pool data"]
    pub objectPoolDataCallback: isobus_DataChunkCallback,
    #[doc = "< Total object pool size aggregate"]
    pub objectPoolSize_bytes: u32,
    #[doc = "< The last object pool index that was processed"]
    pub lastObjectPoolIndex: u32,
}
#[doc = "< Hides the object"]
pub const isobus_VirtualTerminalClient_HideShowObjectCommand_HideObject:
    isobus_VirtualTerminalClient_HideShowObjectCommand = 0;
#[doc = "< Shows an object"]
pub const isobus_VirtualTerminalClient_HideShowObjectCommand_ShowObject:
    isobus_VirtualTerminalClient_HideShowObjectCommand = 1;
#[doc = " @brief Enumerates the states that can be sent with a hide/show object command"]
pub type isobus_VirtualTerminalClient_HideShowObjectCommand = u8;
#[doc = "< Disables a compatible object"]
pub const isobus_VirtualTerminalClient_EnableDisableObjectCommand_DisableObject:
    isobus_VirtualTerminalClient_EnableDisableObjectCommand = 0;
#[doc = "< Enables a compatible object"]
pub const isobus_VirtualTerminalClient_EnableDisableObjectCommand_EnableObject:
    isobus_VirtualTerminalClient_EnableDisableObjectCommand = 1;
#[doc = " @brief Enumerates the states that can be sent with an enable/disable object command"]
pub type isobus_VirtualTerminalClient_EnableDisableObjectCommand = u8;
#[doc = "< Activates an object for data input"]
pub const isobus_VirtualTerminalClient_SelectInputObjectOptions_ActivateObjectForDataInput:
    isobus_VirtualTerminalClient_SelectInputObjectOptions = 0;
#[doc = "< Focuses the object (usually this draws a temporary box around it)"]
pub const isobus_VirtualTerminalClient_SelectInputObjectOptions_SetFocusToObject:
    isobus_VirtualTerminalClient_SelectInputObjectOptions = 255;
#[doc = " @brief Enumerates the states that can be sent with a select input object options command"]
pub type isobus_VirtualTerminalClient_SelectInputObjectOptions = u8;
#[doc = "< Client or server supports VT version 2 or lower"]
pub const isobus_VirtualTerminalClient_VTVersion_Version2OrOlder:
    isobus_VirtualTerminalClient_VTVersion = 0;
#[doc = "< Client or server supports all of VT version 3"]
pub const isobus_VirtualTerminalClient_VTVersion_Version3: isobus_VirtualTerminalClient_VTVersion =
    1;
#[doc = "< Client or server supports all of VT version 4"]
pub const isobus_VirtualTerminalClient_VTVersion_Version4: isobus_VirtualTerminalClient_VTVersion =
    2;
#[doc = "< Client or server supports all of VT version 5"]
pub const isobus_VirtualTerminalClient_VTVersion_Version5: isobus_VirtualTerminalClient_VTVersion =
    3;
#[doc = "< Client or server supports all of VT version 6"]
pub const isobus_VirtualTerminalClient_VTVersion_Version6: isobus_VirtualTerminalClient_VTVersion =
    4;
#[doc = "< Reserved value, not to be used"]
pub const isobus_VirtualTerminalClient_VTVersion_ReservedOrUnknown:
    isobus_VirtualTerminalClient_VTVersion = 5;
#[doc = " @brief The different VT versions that a client or server might support"]
pub type isobus_VirtualTerminalClient_VTVersion = ::std::os::raw::c_int;
#[doc = "< Draws the line from top left to bottom right of the enclosing virtual rectangle"]
pub const isobus_VirtualTerminalClient_LineDirection_TopLeftToBottomRightOfEnclosingVirtualRectangle : isobus_VirtualTerminalClient_LineDirection = 0 ;
#[doc = "< Draws the line from bottom left to top right of the enclosing virtual rectangle"]
pub const isobus_VirtualTerminalClient_LineDirection_BottomLeftToTopRightOfEnclosingVirtualRectangle : isobus_VirtualTerminalClient_LineDirection = 1 ;
#[doc = " @brief Enumerates the different line directions that can be used when changing an endpoint of an object"]
pub type isobus_VirtualTerminalClient_LineDirection = u8;
#[doc = "< 6x8 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size6x8: isobus_VirtualTerminalClient_FontSize = 0;
#[doc = "< 8x8 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size8x8: isobus_VirtualTerminalClient_FontSize = 1;
#[doc = "< 8x12 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size8x12: isobus_VirtualTerminalClient_FontSize = 2;
#[doc = "< 12x16 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size12x16: isobus_VirtualTerminalClient_FontSize =
    3;
#[doc = "< 16x16 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size16x16: isobus_VirtualTerminalClient_FontSize =
    4;
#[doc = "< 16x24 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size16x24: isobus_VirtualTerminalClient_FontSize =
    5;
#[doc = "< 24x32 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size24x32: isobus_VirtualTerminalClient_FontSize =
    6;
#[doc = "< 32x32 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size32x32: isobus_VirtualTerminalClient_FontSize =
    7;
#[doc = "< 32x48 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size32x48: isobus_VirtualTerminalClient_FontSize =
    8;
#[doc = "< 48x64 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size48x64: isobus_VirtualTerminalClient_FontSize =
    9;
#[doc = "< 64x64 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size64x64: isobus_VirtualTerminalClient_FontSize =
    10;
#[doc = "< 64x96 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size64x96: isobus_VirtualTerminalClient_FontSize =
    11;
#[doc = "< 96x128 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size96x128: isobus_VirtualTerminalClient_FontSize =
    12;
#[doc = "< 128x128 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size128x128: isobus_VirtualTerminalClient_FontSize =
    13;
#[doc = "< 128x192 Font size"]
pub const isobus_VirtualTerminalClient_FontSize_Size128x192: isobus_VirtualTerminalClient_FontSize =
    14;
#[doc = " @brief Enumerates the different font sizes"]
pub type isobus_VirtualTerminalClient_FontSize = u8;
#[doc = "< Bold font style"]
pub const isobus_VirtualTerminalClient_FontStyleBits_Bold:
    isobus_VirtualTerminalClient_FontStyleBits = 0;
#[doc = "< Crossed-out font style (strikethrough)"]
pub const isobus_VirtualTerminalClient_FontStyleBits_CrossedOut:
    isobus_VirtualTerminalClient_FontStyleBits = 1;
#[doc = "< Underlined font style"]
pub const isobus_VirtualTerminalClient_FontStyleBits_Underlined:
    isobus_VirtualTerminalClient_FontStyleBits = 2;
#[doc = "< Italic font style"]
pub const isobus_VirtualTerminalClient_FontStyleBits_Italic:
    isobus_VirtualTerminalClient_FontStyleBits = 3;
#[doc = "< Inverted font style (upside down)"]
pub const isobus_VirtualTerminalClient_FontStyleBits_Inverted:
    isobus_VirtualTerminalClient_FontStyleBits = 4;
#[doc = "< Flashing font style"]
pub const isobus_VirtualTerminalClient_FontStyleBits_Flashing:
    isobus_VirtualTerminalClient_FontStyleBits = 5;
#[doc = "< Flashing between hidden and shown font style"]
pub const isobus_VirtualTerminalClient_FontStyleBits_FlashingHidden:
    isobus_VirtualTerminalClient_FontStyleBits = 6;
#[doc = "< Enables proportional font rendering if supported by the server"]
pub const isobus_VirtualTerminalClient_FontStyleBits_ProportionalFontRendering:
    isobus_VirtualTerminalClient_FontStyleBits = 7;
#[doc = " @brief Enumerates the font style options that can be encoded in a font style bitfield"]
pub type isobus_VirtualTerminalClient_FontStyleBits = u8;
#[doc = "< ISO Latin 1"]
pub const isobus_VirtualTerminalClient_FontType_ISO8859_1: isobus_VirtualTerminalClient_FontType =
    0;
#[doc = "< ISO Latin 9"]
pub const isobus_VirtualTerminalClient_FontType_ISO8859_15: isobus_VirtualTerminalClient_FontType =
    1;
#[doc = "< ISO Latin 2"]
pub const isobus_VirtualTerminalClient_FontType_ISO8859_2: isobus_VirtualTerminalClient_FontType =
    2;
#[doc = "< Reserved"]
pub const isobus_VirtualTerminalClient_FontType_Reserved_1: isobus_VirtualTerminalClient_FontType =
    3;
#[doc = "< ISO Latin 4"]
pub const isobus_VirtualTerminalClient_FontType_ISO8859_4: isobus_VirtualTerminalClient_FontType =
    4;
#[doc = "< Cyrillic"]
pub const isobus_VirtualTerminalClient_FontType_ISO8859_5: isobus_VirtualTerminalClient_FontType =
    5;
#[doc = "< Reserved"]
pub const isobus_VirtualTerminalClient_FontType_Reserved_2: isobus_VirtualTerminalClient_FontType =
    6;
#[doc = "< Greek"]
pub const isobus_VirtualTerminalClient_FontType_ISO8859_7: isobus_VirtualTerminalClient_FontType =
    7;
#[doc = "< Reserved from ISO8859_7 to this value"]
pub const isobus_VirtualTerminalClient_FontType_ReservedEnd: isobus_VirtualTerminalClient_FontType =
    239;
#[doc = "< The beginning of the proprietary range"]
pub const isobus_VirtualTerminalClient_FontType_ProprietaryBegin:
    isobus_VirtualTerminalClient_FontType = 240;
#[doc = "< The end of the proprietary region"]
pub const isobus_VirtualTerminalClient_FontType_ProprietaryEnd:
    isobus_VirtualTerminalClient_FontType = 255;
#[doc = " @brief Enumerates the different font types"]
pub type isobus_VirtualTerminalClient_FontType = u8;
#[doc = "< No fill will be applied"]
pub const isobus_VirtualTerminalClient_FillType_NoFill: isobus_VirtualTerminalClient_FillType = 0;
#[doc = "< Fill with the color of the outline of the shape"]
pub const isobus_VirtualTerminalClient_FillType_FillWithLineColor:
    isobus_VirtualTerminalClient_FillType = 1;
#[doc = "< Fill with the color specified by a fill attribute"]
pub const isobus_VirtualTerminalClient_FillType_FillWithSpecifiedColorInFillColorAttribute:
    isobus_VirtualTerminalClient_FillType = 2;
#[doc = "< Fill with a patter provided by a fill pattern attribute"]
pub const isobus_VirtualTerminalClient_FillType_FillWithPatternGivenByFillPatternAttribute:
    isobus_VirtualTerminalClient_FillType = 3;
#[doc = " @brief Enumerates the different fill types for an object"]
pub type isobus_VirtualTerminalClient_FillType = u8;
#[doc = "< A data mask, used in normal circumstances"]
pub const isobus_VirtualTerminalClient_MaskType_DataMask: isobus_VirtualTerminalClient_MaskType = 1;
#[doc = "< An alarm mask, which has different metadata related to popping up alarms, like priority"]
pub const isobus_VirtualTerminalClient_MaskType_AlarmMask: isobus_VirtualTerminalClient_MaskType =
    2;
#[doc = " @brief The types of object pool masks"]
pub type isobus_VirtualTerminalClient_MaskType = u8;
#[doc = "< Overrides lower priority alarm masks"]
pub const isobus_VirtualTerminalClient_AlarmMaskPriority_High:
    isobus_VirtualTerminalClient_AlarmMaskPriority = 0;
#[doc = "< Overrides low priority alarm masks"]
pub const isobus_VirtualTerminalClient_AlarmMaskPriority_Medium:
    isobus_VirtualTerminalClient_AlarmMaskPriority = 1;
#[doc = "< Overrides data masks"]
pub const isobus_VirtualTerminalClient_AlarmMaskPriority_Low:
    isobus_VirtualTerminalClient_AlarmMaskPriority = 2;
#[doc = " @brief The allowable priorities of an alarm mask"]
pub type isobus_VirtualTerminalClient_AlarmMaskPriority = u8;
#[doc = "< Renders the mask normally"]
pub const isobus_VirtualTerminalClient_MaskLockState_UnlockMask:
    isobus_VirtualTerminalClient_MaskLockState = 0;
#[doc = "< Locks the mask so rendering of it is not updated until it is unlocked or a timeout occurs"]
pub const isobus_VirtualTerminalClient_MaskLockState_LockMask:
    isobus_VirtualTerminalClient_MaskLockState = 1;
#[doc = " @brief Denotes the lock/unlock state of a mask. Used to freeze/unfreeze rendering of a mask."]
pub type isobus_VirtualTerminalClient_MaskLockState = u8;
#[doc = "< Button is released"]
pub const isobus_VirtualTerminalClient_KeyActivationCode_ButtonUnlatchedOrReleased:
    isobus_VirtualTerminalClient_KeyActivationCode = 0;
#[doc = "< Button is pressed"]
pub const isobus_VirtualTerminalClient_KeyActivationCode_ButtonPressedOrLatched:
    isobus_VirtualTerminalClient_KeyActivationCode = 1;
#[doc = "< Button is being held down (sent cyclically)"]
pub const isobus_VirtualTerminalClient_KeyActivationCode_ButtonStillHeld:
    isobus_VirtualTerminalClient_KeyActivationCode = 2;
#[doc = "< Press was aborted (user navigated away from the button and did not release it)"]
pub const isobus_VirtualTerminalClient_KeyActivationCode_ButtonPressAborted:
    isobus_VirtualTerminalClient_KeyActivationCode = 3;
#[doc = " @brief The different key activation codes that a button press can generate"]
pub type isobus_VirtualTerminalClient_KeyActivationCode = u8;
#[doc = "< No error occurred"]
pub const isobus_VirtualTerminalClient_ESCMessageErrorCode_NoError:
    isobus_VirtualTerminalClient_ESCMessageErrorCode = 0;
#[doc = "< No input field is open"]
pub const isobus_VirtualTerminalClient_ESCMessageErrorCode_NoInputFieldOpen:
    isobus_VirtualTerminalClient_ESCMessageErrorCode = 1;
#[doc = "< Error is not one of the above"]
pub const isobus_VirtualTerminalClient_ESCMessageErrorCode_OtherError:
    isobus_VirtualTerminalClient_ESCMessageErrorCode = 5;
#[doc = " @brief Enumerates the errors that can be present in an ESC message"]
pub type isobus_VirtualTerminalClient_ESCMessageErrorCode = u8;
#[doc = "< VT is not connected, and is not trying to connect yet"]
pub const isobus_VirtualTerminalClient_StateMachineState_Disconnected:
    isobus_VirtualTerminalClient_StateMachineState = 0;
#[doc = "< VT client is initialized, waiting for a VT server to come online"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForPartnerVTStatusMessage:
    isobus_VirtualTerminalClient_StateMachineState = 1;
#[doc = "< Client is sending the working state master message"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendWorkingSetMasterMessage:
    isobus_VirtualTerminalClient_StateMachineState = 2;
#[doc = "< Client needs an object pool before connection can continue"]
pub const isobus_VirtualTerminalClient_StateMachineState_ReadyForObjectPool:
    isobus_VirtualTerminalClient_StateMachineState = 3;
#[doc = "< Client is sending the \"get memory\" message to see if VT has enough memory available"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendGetMemory:
    isobus_VirtualTerminalClient_StateMachineState = 4;
#[doc = "< Client is waiting for a response to the \"get memory\" message"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForGetMemoryResponse:
    isobus_VirtualTerminalClient_StateMachineState = 5;
#[doc = "< Client is sending the \"get number of soft keys\" message"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendGetNumberSoftkeys:
    isobus_VirtualTerminalClient_StateMachineState = 6;
#[doc = "< Client is waiting for a response to the \"get number of soft keys\" message"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForGetNumberSoftKeysResponse:
    isobus_VirtualTerminalClient_StateMachineState = 7;
#[doc = "< Client is sending the \"get text font data\" message"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendGetTextFontData:
    isobus_VirtualTerminalClient_StateMachineState = 8;
#[doc = "< Client is waiting for a response to the \"get text font data\" message"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForGetTextFontDataResponse:
    isobus_VirtualTerminalClient_StateMachineState = 9;
#[doc = "< Client is sending the \"get hardware\" message"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendGetHardware:
    isobus_VirtualTerminalClient_StateMachineState = 10;
#[doc = "< Client is waiting for a response to the \"get hardware\" message"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForGetHardwareResponse:
    isobus_VirtualTerminalClient_StateMachineState = 11;
#[doc = "< If a version label was specified, check to see if the VT has that version already"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendGetVersions:
    isobus_VirtualTerminalClient_StateMachineState = 12;
#[doc = "< Client is waiting for a response to the \"get versions\" message"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForGetVersionsResponse:
    isobus_VirtualTerminalClient_StateMachineState = 13;
#[doc = "< Sending the store version command"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendStoreVersion:
    isobus_VirtualTerminalClient_StateMachineState = 14;
#[doc = "< Client is waiting for a response to the store version command"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForStoreVersionResponse:
    isobus_VirtualTerminalClient_StateMachineState = 15;
#[doc = "< Sending the load version command"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendLoadVersion:
    isobus_VirtualTerminalClient_StateMachineState = 16;
#[doc = "< Client is waiting for the VT to respond to the \"Load Version\" command"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForLoadVersionResponse:
    isobus_VirtualTerminalClient_StateMachineState = 17;
#[doc = "< Client is uploading the object pool"]
pub const isobus_VirtualTerminalClient_StateMachineState_UploadObjectPool:
    isobus_VirtualTerminalClient_StateMachineState = 18;
#[doc = "< Client is sending the end of object pool message"]
pub const isobus_VirtualTerminalClient_StateMachineState_SendEndOfObjectPool:
    isobus_VirtualTerminalClient_StateMachineState = 19;
#[doc = "< Client is waiting for the end of object pool response message"]
pub const isobus_VirtualTerminalClient_StateMachineState_WaitForEndOfObjectPoolResponse:
    isobus_VirtualTerminalClient_StateMachineState = 20;
#[doc = "< Client is connected to the VT server and the application layer is in control"]
pub const isobus_VirtualTerminalClient_StateMachineState_Connected:
    isobus_VirtualTerminalClient_StateMachineState = 21;
#[doc = "< Client could not connect to the VT due to an error"]
pub const isobus_VirtualTerminalClient_StateMachineState_Failed:
    isobus_VirtualTerminalClient_StateMachineState = 22;
#[doc = " @brief The internal state machine state of the VT client"]
pub type isobus_VirtualTerminalClient_StateMachineState = u8;
#[doc = "< Reserved"]
pub const isobus_VirtualTerminalClient_MacroEventID_Reserved:
    isobus_VirtualTerminalClient_MacroEventID = 0;
#[doc = "< Event on activation of an object (such as for data input)"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnActivate:
    isobus_VirtualTerminalClient_MacroEventID = 1;
#[doc = "< Event on deactivation of an object"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnDeactivate:
    isobus_VirtualTerminalClient_MacroEventID = 2;
#[doc = "< Event on an object being shown"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnShow:
    isobus_VirtualTerminalClient_MacroEventID = 3;
#[doc = "< Event on an object being hidden"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnHide:
    isobus_VirtualTerminalClient_MacroEventID = 4;
#[doc = "< Event on enable of an object"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnEnable:
    isobus_VirtualTerminalClient_MacroEventID = 5;
#[doc = "< Event on disabling an object"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnDisable:
    isobus_VirtualTerminalClient_MacroEventID = 6;
#[doc = "< Event on changing the active mask"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeActiveMask:
    isobus_VirtualTerminalClient_MacroEventID = 7;
#[doc = "< Event on change of the soft key mask"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeSoftKeyMask:
    isobus_VirtualTerminalClient_MacroEventID = 8;
#[doc = "< Event on change of an attribute value"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeAttribute:
    isobus_VirtualTerminalClient_MacroEventID = 9;
#[doc = "< Event on change of a background color"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeBackgroundColor:
    isobus_VirtualTerminalClient_MacroEventID = 10;
#[doc = "< Event on change of a font attribute"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeFontAttributes:
    isobus_VirtualTerminalClient_MacroEventID = 11;
#[doc = "< Event on change of a line attribute"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeLineAttributes:
    isobus_VirtualTerminalClient_MacroEventID = 12;
#[doc = "< Event on change of a fill attribute"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeFillAttributes:
    isobus_VirtualTerminalClient_MacroEventID = 13;
#[doc = "< Event on change of a child objects location"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeChildLocation:
    isobus_VirtualTerminalClient_MacroEventID = 14;
#[doc = "< Event on change of an object size"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeSize:
    isobus_VirtualTerminalClient_MacroEventID = 15;
#[doc = "< Event on change of an object value (like via `change numeric value`)"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeValue:
    isobus_VirtualTerminalClient_MacroEventID = 16;
#[doc = "< Event on change of a mask's priority"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangePriority:
    isobus_VirtualTerminalClient_MacroEventID = 17;
#[doc = "< Event on change of an object endpoint"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeEndPoint:
    isobus_VirtualTerminalClient_MacroEventID = 18;
#[doc = "< Event when an input field is selected"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnInputFieldSelection:
    isobus_VirtualTerminalClient_MacroEventID = 19;
#[doc = "< Event on deselection of an input field"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnInputFieldDeselection:
    isobus_VirtualTerminalClient_MacroEventID = 20;
#[doc = "< Event on ESC (escape)"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnESC:
    isobus_VirtualTerminalClient_MacroEventID = 21;
#[doc = "< Event on entry of a value"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnEntryOfValue:
    isobus_VirtualTerminalClient_MacroEventID = 22;
#[doc = "< Event on entry of a *new* value"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnEntryOfNewValue:
    isobus_VirtualTerminalClient_MacroEventID = 23;
#[doc = "< Event on the press of a key"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnKeyPress:
    isobus_VirtualTerminalClient_MacroEventID = 24;
#[doc = "< Event on the release of a key"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnKeyRelease:
    isobus_VirtualTerminalClient_MacroEventID = 25;
#[doc = "< Event on changing a child object's position"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnChangeChildPosition:
    isobus_VirtualTerminalClient_MacroEventID = 26;
#[doc = "< Event on a pointing event press"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnPointingEventPress:
    isobus_VirtualTerminalClient_MacroEventID = 27;
#[doc = "< Event on a pointing event release"]
pub const isobus_VirtualTerminalClient_MacroEventID_OnPointingEventRelease:
    isobus_VirtualTerminalClient_MacroEventID = 28;
#[doc = "< Beginning of the reserved range"]
pub const isobus_VirtualTerminalClient_MacroEventID_ReservedBegin:
    isobus_VirtualTerminalClient_MacroEventID = 29;
#[doc = "< End of the reserved range"]
pub const isobus_VirtualTerminalClient_MacroEventID_ReservedEnd:
    isobus_VirtualTerminalClient_MacroEventID = 254;
#[doc = "< Use extended macro reference"]
pub const isobus_VirtualTerminalClient_MacroEventID_UseExtendedMacroReference:
    isobus_VirtualTerminalClient_MacroEventID = 255;
#[doc = " @brief Enumerates the different events that can be associated with a macro"]
pub type isobus_VirtualTerminalClient_MacroEventID = u8;
#[doc = "< Monochromatic graphics mode (1 bit)"]
pub const isobus_VirtualTerminalClient_GraphicMode_Monochrome:
    isobus_VirtualTerminalClient_GraphicMode = 0;
#[doc = "< 16 Color mode (4 bit)"]
pub const isobus_VirtualTerminalClient_GraphicMode_SixteenColour:
    isobus_VirtualTerminalClient_GraphicMode = 1;
#[doc = "< 256 Color mode (8 bit)"]
pub const isobus_VirtualTerminalClient_GraphicMode_TwoHundredFiftySixColor:
    isobus_VirtualTerminalClient_GraphicMode = 2;
#[doc = " @brief Enumerates the various VT server graphics modes"]
pub type isobus_VirtualTerminalClient_GraphicMode = u8;
#[doc = " @brief A typedef for a generic key event for convenience"]
pub type isobus_VirtualTerminalClient_VTKeyEventCallback = ::std::option::Option<
    unsafe extern "C" fn(
        keyEvent: isobus_VirtualTerminalClient_KeyActivationCode,
        keyNumber: u8,
        objectID: u16,
        parentObjectID: u16,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic pointing event, for convenience"]
pub type isobus_VirtualTerminalClient_VTPointingEventCallback = ::std::option::Option<
    unsafe extern "C" fn(
        keyEvent: isobus_VirtualTerminalClient_KeyActivationCode,
        xPosition: u16,
        yPosition: u16,
        parentMaskObjectID: u16,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic VT input object selection callback for convenience"]
pub type isobus_VirtualTerminalClient_VTSelectInputObjectCallback = ::std::option::Option<
    unsafe extern "C" fn(
        objectID: u16,
        objectSelected: bool,
        objectOpenForInput: bool,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic VT ESC message callback for convenience"]
pub type isobus_VirtualTerminalClient_VTESCMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        objectID: u16,
        errorCode: isobus_VirtualTerminalClient_ESCMessageErrorCode,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic VT change numeric value callback for convenience"]
pub type isobus_VirtualTerminalClient_VTChangeNumericValueCallback = ::std::option::Option<
    unsafe extern "C" fn(
        objectID: u16,
        value: u32,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic VT change active mask callback for convenience"]
pub type isobus_VirtualTerminalClient_VTChangeActiveMaskCallback = ::std::option::Option<
    unsafe extern "C" fn(
        maskObjectID: u16,
        errorObjectID: u16,
        parentObjectID: u16,
        missingObjects: bool,
        maskOrChildHasErrors: bool,
        anyOtherEror: bool,
        poolDeleted: bool,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic VT change soft key mask callback for convenience"]
pub type isobus_VirtualTerminalClient_VTChangeSoftKeyMaskCallback = ::std::option::Option<
    unsafe extern "C" fn(
        dataOrAlarmMaskObjectID: u16,
        softKeyMaskObjectID: u16,
        missingObjects: bool,
        maskOrChildHasErrors: bool,
        anyOtherEror: bool,
        poolDeleted: bool,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic VT change string value callback for convenience"]
pub type isobus_VirtualTerminalClient_VTChangeStringValueCallback = ::std::option::Option<
    unsafe extern "C" fn(
        objectID: u16,
        value: std_string,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic VT on user-layout hide/show callback for convenience"]
pub type isobus_VirtualTerminalClient_VTUserLayoutHideShowCallback = ::std::option::Option<
    unsafe extern "C" fn(
        objectID: u16,
        isHidden: bool,
        parentPointer: *mut isobus_VirtualTerminalClient,
    ),
>;
#[doc = " @brief A typedef for a generic VT control audio signal termination callback for convenience"]
pub type isobus_VirtualTerminalClient_VTAudioSignalTerminationCallback = ::std::option::Option<
    unsafe extern "C" fn(isTerminated: bool, parentPointer: *mut isobus_VirtualTerminalClient),
>;
pub const isobus_VirtualTerminalClient_Function_SoftKeyActivationMessage:
    isobus_VirtualTerminalClient_Function = 0;
pub const isobus_VirtualTerminalClient_Function_ButtonActivationMessage:
    isobus_VirtualTerminalClient_Function = 1;
pub const isobus_VirtualTerminalClient_Function_PointingEventMessage:
    isobus_VirtualTerminalClient_Function = 2;
pub const isobus_VirtualTerminalClient_Function_VTSelectInputObjectMessage:
    isobus_VirtualTerminalClient_Function = 3;
pub const isobus_VirtualTerminalClient_Function_VTESCMessage:
    isobus_VirtualTerminalClient_Function = 4;
pub const isobus_VirtualTerminalClient_Function_VTChangeNumericValueMessage:
    isobus_VirtualTerminalClient_Function = 5;
pub const isobus_VirtualTerminalClient_Function_VTChangeActiveMaskMessage:
    isobus_VirtualTerminalClient_Function = 6;
pub const isobus_VirtualTerminalClient_Function_VTChangeSoftKeyMaskMessage:
    isobus_VirtualTerminalClient_Function = 7;
pub const isobus_VirtualTerminalClient_Function_VTChangeStringValueMessage:
    isobus_VirtualTerminalClient_Function = 8;
pub const isobus_VirtualTerminalClient_Function_VTOnUserLayoutHideShowMessage:
    isobus_VirtualTerminalClient_Function = 9;
pub const isobus_VirtualTerminalClient_Function_VTControlAudioSignalTerminationMessage:
    isobus_VirtualTerminalClient_Function = 10;
pub const isobus_VirtualTerminalClient_Function_ObjectPoolTransferMessage:
    isobus_VirtualTerminalClient_Function = 17;
pub const isobus_VirtualTerminalClient_Function_EndOfObjectPoolMessage:
    isobus_VirtualTerminalClient_Function = 18;
pub const isobus_VirtualTerminalClient_Function_AuxiliaryAssignmentTypeOneCommand:
    isobus_VirtualTerminalClient_Function = 32;
pub const isobus_VirtualTerminalClient_Function_AuxiliaryInputTypeOneStatus:
    isobus_VirtualTerminalClient_Function = 33;
pub const isobus_VirtualTerminalClient_Function_PreferredAssignmentCommand:
    isobus_VirtualTerminalClient_Function = 34;
pub const isobus_VirtualTerminalClient_Function_AuxiliaryInputTypeTwoMaintenanceMessage:
    isobus_VirtualTerminalClient_Function = 35;
pub const isobus_VirtualTerminalClient_Function_AuxiliaryAssignmentTypeTwoCommand:
    isobus_VirtualTerminalClient_Function = 36;
pub const isobus_VirtualTerminalClient_Function_AuxiliaryInputStatusTypeTwoEnableCommand:
    isobus_VirtualTerminalClient_Function = 37;
pub const isobus_VirtualTerminalClient_Function_AuxiliaryInputTypeTwoStatusMessage:
    isobus_VirtualTerminalClient_Function = 38;
pub const isobus_VirtualTerminalClient_Function_AuxiliaryCapabilitiesRequest:
    isobus_VirtualTerminalClient_Function = 39;
pub const isobus_VirtualTerminalClient_Function_SelectActiveWorkingSet:
    isobus_VirtualTerminalClient_Function = 144;
pub const isobus_VirtualTerminalClient_Function_ESCCommand: isobus_VirtualTerminalClient_Function =
    146;
pub const isobus_VirtualTerminalClient_Function_HideShowObjectCommand:
    isobus_VirtualTerminalClient_Function = 160;
pub const isobus_VirtualTerminalClient_Function_EnableDisableObjectCommand:
    isobus_VirtualTerminalClient_Function = 161;
pub const isobus_VirtualTerminalClient_Function_SelectInputObjectCommand:
    isobus_VirtualTerminalClient_Function = 162;
pub const isobus_VirtualTerminalClient_Function_ControlAudioSignalCommand:
    isobus_VirtualTerminalClient_Function = 163;
pub const isobus_VirtualTerminalClient_Function_SetAudioVolumeCommand:
    isobus_VirtualTerminalClient_Function = 164;
pub const isobus_VirtualTerminalClient_Function_ChangeChildLocationCommand:
    isobus_VirtualTerminalClient_Function = 165;
pub const isobus_VirtualTerminalClient_Function_ChangeSizeCommand:
    isobus_VirtualTerminalClient_Function = 166;
pub const isobus_VirtualTerminalClient_Function_ChangeBackgroundColourCommand:
    isobus_VirtualTerminalClient_Function = 167;
pub const isobus_VirtualTerminalClient_Function_ChangeNumericValueCommand:
    isobus_VirtualTerminalClient_Function = 168;
pub const isobus_VirtualTerminalClient_Function_ChangeEndPointCommand:
    isobus_VirtualTerminalClient_Function = 169;
pub const isobus_VirtualTerminalClient_Function_ChangeFontAttributesCommand:
    isobus_VirtualTerminalClient_Function = 170;
pub const isobus_VirtualTerminalClient_Function_ChangeLineAttributesCommand:
    isobus_VirtualTerminalClient_Function = 171;
pub const isobus_VirtualTerminalClient_Function_ChangeFillAttributesCommand:
    isobus_VirtualTerminalClient_Function = 172;
pub const isobus_VirtualTerminalClient_Function_ChangeActiveMaskCommand:
    isobus_VirtualTerminalClient_Function = 173;
pub const isobus_VirtualTerminalClient_Function_ChangeSoftKeyMaskCommand:
    isobus_VirtualTerminalClient_Function = 174;
pub const isobus_VirtualTerminalClient_Function_ChangeAttributeCommand:
    isobus_VirtualTerminalClient_Function = 175;
pub const isobus_VirtualTerminalClient_Function_ChangePriorityCommand:
    isobus_VirtualTerminalClient_Function = 176;
pub const isobus_VirtualTerminalClient_Function_ChangeListItemCommand:
    isobus_VirtualTerminalClient_Function = 177;
pub const isobus_VirtualTerminalClient_Function_DeleteObjectPoolCommand:
    isobus_VirtualTerminalClient_Function = 178;
pub const isobus_VirtualTerminalClient_Function_ChangeStringValueCommand:
    isobus_VirtualTerminalClient_Function = 179;
pub const isobus_VirtualTerminalClient_Function_ChangeChildPositionCommand:
    isobus_VirtualTerminalClient_Function = 180;
pub const isobus_VirtualTerminalClient_Function_ChangeObjectLabelCommand:
    isobus_VirtualTerminalClient_Function = 181;
pub const isobus_VirtualTerminalClient_Function_ChangePolygonPointCommand:
    isobus_VirtualTerminalClient_Function = 182;
pub const isobus_VirtualTerminalClient_Function_ChangePolygonScaleCommand:
    isobus_VirtualTerminalClient_Function = 183;
pub const isobus_VirtualTerminalClient_Function_GraphicsContextCommand:
    isobus_VirtualTerminalClient_Function = 184;
pub const isobus_VirtualTerminalClient_Function_GetAttributeValueMessage:
    isobus_VirtualTerminalClient_Function = 185;
pub const isobus_VirtualTerminalClient_Function_SelectColourMapCommand:
    isobus_VirtualTerminalClient_Function = 186;
pub const isobus_VirtualTerminalClient_Function_IdentifyVTMessage:
    isobus_VirtualTerminalClient_Function = 187;
pub const isobus_VirtualTerminalClient_Function_ExecuteExtendedMacroCommand:
    isobus_VirtualTerminalClient_Function = 188;
pub const isobus_VirtualTerminalClient_Function_LockUnlockMaskCommand:
    isobus_VirtualTerminalClient_Function = 189;
pub const isobus_VirtualTerminalClient_Function_ExecuteMacroCommand:
    isobus_VirtualTerminalClient_Function = 190;
pub const isobus_VirtualTerminalClient_Function_GetMemoryMessage:
    isobus_VirtualTerminalClient_Function = 192;
pub const isobus_VirtualTerminalClient_Function_GetSupportedWidecharsMessage:
    isobus_VirtualTerminalClient_Function = 193;
pub const isobus_VirtualTerminalClient_Function_GetNumberOfSoftKeysMessage:
    isobus_VirtualTerminalClient_Function = 194;
pub const isobus_VirtualTerminalClient_Function_GetTextFontDataMessage:
    isobus_VirtualTerminalClient_Function = 195;
pub const isobus_VirtualTerminalClient_Function_GetWindowMaskDataMessage:
    isobus_VirtualTerminalClient_Function = 196;
pub const isobus_VirtualTerminalClient_Function_GetSupportedObjectsMessage:
    isobus_VirtualTerminalClient_Function = 197;
pub const isobus_VirtualTerminalClient_Function_GetHardwareMessage:
    isobus_VirtualTerminalClient_Function = 199;
pub const isobus_VirtualTerminalClient_Function_StoreVersionCommand:
    isobus_VirtualTerminalClient_Function = 208;
pub const isobus_VirtualTerminalClient_Function_LoadVersionCommand:
    isobus_VirtualTerminalClient_Function = 209;
pub const isobus_VirtualTerminalClient_Function_DeleteVersionCommand:
    isobus_VirtualTerminalClient_Function = 210;
pub const isobus_VirtualTerminalClient_Function_ExtendedGetVersionsMessage:
    isobus_VirtualTerminalClient_Function = 211;
pub const isobus_VirtualTerminalClient_Function_ExtendedStoreVersionCommand:
    isobus_VirtualTerminalClient_Function = 212;
pub const isobus_VirtualTerminalClient_Function_ExtendedLoadVersionCommand:
    isobus_VirtualTerminalClient_Function = 213;
pub const isobus_VirtualTerminalClient_Function_ExtendedDeleteVersionCommand:
    isobus_VirtualTerminalClient_Function = 214;
pub const isobus_VirtualTerminalClient_Function_GetVersionsMessage:
    isobus_VirtualTerminalClient_Function = 223;
pub const isobus_VirtualTerminalClient_Function_GetVersionsResponse:
    isobus_VirtualTerminalClient_Function = 224;
pub const isobus_VirtualTerminalClient_Function_UnsupportedVTFunctionMessage:
    isobus_VirtualTerminalClient_Function = 253;
pub const isobus_VirtualTerminalClient_Function_VTStatusMessage:
    isobus_VirtualTerminalClient_Function = 254;
pub const isobus_VirtualTerminalClient_Function_WorkingSetMaintenanceMessage:
    isobus_VirtualTerminalClient_Function = 255;
#[doc = " @brief Enumerates the multiplexor byte values for VT commands"]
pub type isobus_VirtualTerminalClient_Function = u8;
#[doc = "< Sets the graphics cursor x/y attributes"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_SetGraphicsCursor:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 0;
#[doc = "< Moves the cursor relative to current location"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_MoveGraphicsCursor:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 1;
#[doc = "< Sets the foreground color"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_SetForegroundColor:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 2;
#[doc = "< Sets the background color"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_SetBackgroundColor:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 3;
#[doc = "< Sets the line attribute object ID"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_SetLineAttributesObjectID:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 4;
#[doc = "< Sets the fill attribute object ID"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_SetFillAttributesObjectID:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 5;
#[doc = "< Sets the font attribute object ID"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_SetFontAttributesObjectID:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 6;
#[doc = "< Erases a rectangle"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_EraseRectangle:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 7;
#[doc = "< Draws a point"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_DrawPoint:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 8;
#[doc = "< Draws a line"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_DrawLine:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 9;
#[doc = "< Draws a rectangle"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_DrawRectangle:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 10;
#[doc = "< Draws a closed ellipse"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_DrawClosedEllipse:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 11;
#[doc = "< Draws polygon"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_DrawPolygon:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 12;
#[doc = "< Draws text"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_DrawText:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 13;
#[doc = "< Pans viewport"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_PanViewport:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 14;
#[doc = "< Zooms the viewport"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_ZoomViewport:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 15;
#[doc = "< Pan and zooms the viewport"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_PanAndZoomViewport:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 16;
#[doc = "< Changes the viewport size"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_ChangeViewportSize:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 17;
#[doc = "< Draws a VT object"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_DrawVTObject:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 18;
#[doc = "< Copies the canvas to picture graphic object"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_CopyCanvasToPictureGraphic:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 19;
#[doc = "< Copies the viewport to picture graphic object"]
pub const isobus_VirtualTerminalClient_GraphicsContextSubCommandID_CopyViewportToPictureGraphic:
    isobus_VirtualTerminalClient_GraphicsContextSubCommandID = 20;
#[doc = " @brief Enumerates the command types for graphics context objects"]
pub type isobus_VirtualTerminalClient_GraphicsContextSubCommandID = u8;
#[doc = "< Flag to send the working set maintenenace message"]
pub const isobus_VirtualTerminalClient_TransmitFlags_SendWorkingSetMaintenance:
    isobus_VirtualTerminalClient_TransmitFlags = 0;
#[doc = "< The number of flags in this enum"]
pub const isobus_VirtualTerminalClient_TransmitFlags_NumberFlags:
    isobus_VirtualTerminalClient_TransmitFlags = 1;
#[doc = " @brief Flags used as a retry mechanism for sending important messages"]
pub type isobus_VirtualTerminalClient_TransmitFlags = u32;
#[doc = "< The object pool upload has not been started"]
pub const isobus_VirtualTerminalClient_CurrentObjectPoolUploadState_Uninitialized:
    isobus_VirtualTerminalClient_CurrentObjectPoolUploadState = 0;
#[doc = "< The object pool upload is in progress"]
pub const isobus_VirtualTerminalClient_CurrentObjectPoolUploadState_InProgress:
    isobus_VirtualTerminalClient_CurrentObjectPoolUploadState = 1;
#[doc = "< The object pool was uploaded"]
pub const isobus_VirtualTerminalClient_CurrentObjectPoolUploadState_Success:
    isobus_VirtualTerminalClient_CurrentObjectPoolUploadState = 2;
#[doc = "< The pool upload has failed"]
pub const isobus_VirtualTerminalClient_CurrentObjectPoolUploadState_Failed:
    isobus_VirtualTerminalClient_CurrentObjectPoolUploadState = 3;
#[doc = " @brief The different states of an object pool upload process"]
pub type isobus_VirtualTerminalClient_CurrentObjectPoolUploadState = u8;
#[doc = " @brief An object for storing information regarding an object pool upload"]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_VirtualTerminalClient_ObjectPoolDataStruct {
    #[doc = "< A pointer to an object pool"]
    pub objectPoolDataPointer: *const u8,
    #[doc = "< A pointer to an object pool (vector format)"]
    pub objectPoolVectorPointer: *const [u64; 3usize],
    #[doc = "< A callback used to get data in chunks as an alternative to loading the whole pool at once"]
    pub dataCallback: isobus_DataChunkCallback,
    #[doc = "< An optional version label that will be used to load/store the pool to the VT. 7 character max!"]
    pub versionLabel: std_string,
    #[doc = "< The size of the object pool"]
    pub objectPoolSize: u32,
    #[doc = "< The version of the object pool. Must be the same for all pools!"]
    pub version: isobus_VirtualTerminalClient_VTVersion,
    #[doc = "< Determines if the client will use callbacks to get the data in chunks."]
    pub useDataCallback: bool,
    #[doc = "< The upload state of this pool"]
    pub uploaded: bool,
}
#[test]
fn bindgen_test_layout_isobus_VirtualTerminalClient_ObjectPoolDataStruct() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_VirtualTerminalClient_ObjectPoolDataStruct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_VirtualTerminalClient_ObjectPoolDataStruct>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_VirtualTerminalClient_ObjectPoolDataStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectPoolDataPointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct),
            "::",
            stringify!(objectPoolDataPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectPoolVectorPointer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct),
            "::",
            stringify!(objectPoolVectorPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataCallback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct),
            "::",
            stringify!(dataCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionLabel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct),
            "::",
            stringify!(versionLabel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectPoolSize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct),
            "::",
            stringify!(objectPoolSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useDataCallback) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct),
            "::",
            stringify!(useDataCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uploaded) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient_ObjectPoolDataStruct),
            "::",
            stringify!(uploaded)
        )
    );
}
#[doc = "< The NULL Object ID, usually drawn as blank space"]
pub const isobus_VirtualTerminalClient_NULL_OBJECT_ID: u16 = 65535;
#[doc = "< The max allowable time between VT status messages before its considered offline"]
pub const isobus_VirtualTerminalClient_VT_STATUS_TIMEOUT_MS: u32 = 3000;
#[doc = "< The frequency at which we send the working set maintenance message"]
pub const isobus_VirtualTerminalClient_WORKING_SET_MAINTENANCE_TIMEOUT_MS: u32 = 1000;
#[test]
fn bindgen_test_layout_isobus_VirtualTerminalClient() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_VirtualTerminalClient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_VirtualTerminalClient>(),
        424usize,
        concat!("Size of: ", stringify!(isobus_VirtualTerminalClient))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_VirtualTerminalClient>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_VirtualTerminalClient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partnerControlFunction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(partnerControlFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).myControlFunction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(myControlFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txFlags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(txFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastVTStatusTimestamp_ms) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(lastVTStatusTimestamp_ms)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).activeWorkingSetDataMaskObjectID) as usize - ptr as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(activeWorkingSetDataMaskObjectID)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).activeWorkingSetSoftkeyMaskObjectID) as usize - ptr as usize
        },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(activeWorkingSetSoftkeyMaskObjectID)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).activeWorkingSetMasterAddress) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(activeWorkingSetMasterAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busyCodesBitfield) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(busyCodesBitfield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentCommandFunctionCode) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(currentCommandFunctionCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connectedVTVersion) as usize - ptr as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(connectedVTVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).softKeyXAxisPixels) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(softKeyXAxisPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).softKeyYAxisPixels) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(softKeyYAxisPixels)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).numberVirtualSoftkeysPerSoftkeyMask) as usize - ptr as usize
        },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(numberVirtualSoftkeysPerSoftkeyMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numberPhysicalSoftkeys) as usize - ptr as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(numberPhysicalSoftkeys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smallFontSizesBitfield) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(smallFontSizesBitfield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).largeFontSizesBitfield) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(largeFontSizesBitfield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fontStylesBitfield) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(fontStylesBitfield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supportedGraphicsMode) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(supportedGraphicsMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xPixels) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(xPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yPixels) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(yPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardwareFeaturesBitfield) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(hardwareFeaturesBitfield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentObjectPoolState) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(currentObjectPoolState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateMachineTimestamp_ms) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(stateMachineTimestamp_ms)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lastWorkingSetMaintenanceTimestamp_ms) as usize
                - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(lastWorkingSetMaintenanceTimestamp_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectPools) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(objectPools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workerThread) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(workerThread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendWorkingSetMaintenenace) as usize - ptr as usize },
        137usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(sendWorkingSetMaintenenace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shouldTerminate) as usize - ptr as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(shouldTerminate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttonEventCallbacks) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(buttonEventCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).softKeyEventCallbacks) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(softKeyEventCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointingEventCallbacks) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(pointingEventCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selectInputObjectCallbacks) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(selectInputObjectCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).escMessageCallbacks) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(escMessageCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeNumericValueCallbacks) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(changeNumericValueCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeActiveMaskCallbacks) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(changeActiveMaskCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeSoftKeyMaskCallbacks) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(changeSoftKeyMaskCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeStringValueCallbacks) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(changeStringValueCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userLayoutHideShowCallbacks) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(userLayoutHideShowCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).audioSignalTerminationCallbacks) as usize - ptr as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(audioSignalTerminationCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectPoolDataCallback) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(objectPoolDataCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectPoolSize_bytes) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(objectPoolSize_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastObjectPoolIndex) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_VirtualTerminalClient),
            "::",
            stringify!(lastObjectPoolIndex)
        )
    );
}
extern "C" {
    #[doc = " @brief This function starts the state machine. Call this once you have supplied 1 or more object pool and are ready to connect.\n @param[in] spawnThread The client will start a thread to manage itself if this parameter is true. Otherwise you must update it cyclically."]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient10initializeEb"]
    pub fn isobus_VirtualTerminalClient_initialize(
        this: *mut isobus_VirtualTerminalClient,
        spawnThread: bool,
    );
}
extern "C" {
    #[doc = " @brief Returns if the client has been initialized\n @returns true if the client has been initialized"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient18get_is_initializedEv"]
    pub fn isobus_VirtualTerminalClient_get_is_initialized(
        this: *mut isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Terminates the client and joins the worker thread if applicable"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient9terminateEv"]
    pub fn isobus_VirtualTerminalClient_terminate(this: *mut isobus_VirtualTerminalClient);
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when a softkey is pressed or released\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient35register_vt_soft_key_event_callbackEPFvNS0_17KeyActivationCodeEhttPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_soft_key_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTKeyEventCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a callback for when a softkey is pressed or released\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient33remove_vt_soft_key_event_callbackEPFvNS0_17KeyActivationCodeEhttPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_soft_key_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTKeyEventCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when a button is pressed or released\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient33register_vt_button_event_callbackEPFvNS0_17KeyActivationCodeEhttPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_button_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTKeyEventCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a callback when a button is pressed or released\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient31remove_vt_button_event_callbackEPFvNS0_17KeyActivationCodeEhttPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_button_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTKeyEventCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when a pointing event is \"pressed or released\"\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient35register_vt_pointing_event_callbackEPFvNS0_17KeyActivationCodeEtttPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_pointing_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTPointingEventCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a callback when a pointing event is \"pressed or released\"\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient33remove_vt_pointing_event_callbackEPFvNS0_17KeyActivationCodeEtttPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_pointing_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTPointingEventCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when an input object event is triggered\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient46register_vt_select_input_object_event_callbackEPFvtbbPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_select_input_object_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTSelectInputObjectCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove an input object event callback\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient47remove_vt_selection_input_object_event_callbackEPFvtbbPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_selection_input_object_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTSelectInputObjectCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when an ESC message is received, e.g. an open object input is closed\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient38register_vt_esc_message_event_callbackEPFvtNS0_19ESCMessageErrorCodeEPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_esc_message_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTESCMessageCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove an ESC message callback\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient36remove_vt_esc_message_event_callbackEPFvtNS0_19ESCMessageErrorCodeEPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_esc_message_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTESCMessageCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when a numeric value is changed in an input object\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient47register_vt_change_numeric_value_event_callbackEPFvtjPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_change_numeric_value_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTChangeNumericValueCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a numeric value change callback\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient45remove_vt_change_numeric_value_event_callbackEPFvtjPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_change_numeric_value_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTChangeNumericValueCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when the active mask is changed\n @details The VT sends this whenever there are missing object references or errors in the mask.\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient45register_vt_change_active_mask_event_callbackEPFvtttbbbbPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_change_active_mask_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTChangeActiveMaskCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a callback when the active mask is changed\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient43remove_vt_change_active_mask_event_callbackEPFvtttbbbbPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_change_active_mask_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTChangeActiveMaskCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when the soft key mask is changed\n @details The VT sends this whenever there are missing object references or errors in the mask.\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient47register_vt_change_soft_key_mask_event_callbackEPFvttbbbbPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_change_soft_key_mask_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTChangeSoftKeyMaskCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a callback when the soft key mask is changed\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient45remove_vt_change_soft_key_mask_event_callbackEPFvttbbbbPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_change_soft_key_mask_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTChangeSoftKeyMaskCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when a string value is changed\n @details The object could be either the input string object or the referenced string variable object.\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient46register_vt_change_string_value_event_callbackEPFvtNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_change_string_value_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTChangeStringValueCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a callback when a string value is changed\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient44remove_vt_change_string_value_event_callbackEPFvtNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_change_string_value_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTChangeStringValueCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when a user-layout object is hidden or shown\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient48register_vt_user_layout_hide_show_event_callbackEPFvtbPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_user_layout_hide_show_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTUserLayoutHideShowCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a callback when a user-layout object is hidden or shown\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient40remove_vt_user_layout_hide_show_callbackEPFvtbPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_user_layout_hide_show_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTUserLayoutHideShowCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to register for a callback when an audio signal is terminated\n @param[in] value The callback to register"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient59register_vt_control_audio_signal_termination_event_callbackEPFvbPS0_E"]
    pub fn isobus_VirtualTerminalClient_register_vt_control_audio_signal_termination_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTAudioSignalTerminationCallback,
    );
}
extern "C" {
    #[doc = " @brief Allows you to remove a callback when an audio signal is terminated\n @param[in] value The callback to remove"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient57remove_vt_control_audio_signal_termination_event_callbackEPFvbPS0_E"]
    pub fn isobus_VirtualTerminalClient_remove_vt_control_audio_signal_termination_event_callback(
        this: *mut isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTAudioSignalTerminationCallback,
    );
}
extern "C" {
    #[doc = " @brief Sends a hide/show object command\n @details This command is used to hide or show a Container object.\n This pertains to the visibility of the object as well as its\n remembered state.If the object cannot be displayed due to references to missing\n objects, the VT generates an error in the response.\n @param[in] objectID The ID of the target object\n @param[in] command The target hide/show state of the object\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient21send_hide_show_objectEtNS0_21HideShowObjectCommandE"]
    pub fn isobus_VirtualTerminalClient_send_hide_show_object(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        command: isobus_VirtualTerminalClient_HideShowObjectCommand,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends an enable/disable object command\n @details This command is used to enable or disable an input field object\n or a Button object and pertains to the accessibility of an input field\n object or Button object.This command is also used to enable or disable an Animation object.\n It is allowed to enable already enabled objects and to disable already disabled objects.\n @param[in] objectID The ID of the target object\n @param[in] command The target enable/disable state of the object\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient26send_enable_disable_objectEtNS0_26EnableDisableObjectCommandE"]
    pub fn isobus_VirtualTerminalClient_send_enable_disable_object(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        command: isobus_VirtualTerminalClient_EnableDisableObjectCommand,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends a select input object command\n @details This command is used to force the selection of an input field, Button, or Key object.\n @param[in] objectID The ID of the target object\n @param[in] option The method by which the object will be selected\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_select_input_objectEtNS0_24SelectInputObjectOptionsE"]
    pub fn isobus_VirtualTerminalClient_send_select_input_object(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        option: isobus_VirtualTerminalClient_SelectInputObjectOptions,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the ESC message (Escape)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient8send_ESCEv"]
    pub fn isobus_VirtualTerminalClient_send_ESC(this: *mut isobus_VirtualTerminalClient) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the control audio signal command\n @details This command may be used to control the audio on the VT.\n When received this message shall terminate any audio in process from\n the originating ECU and replace the previous command with the new command.\n @param[in] activations Number of times to activate the signal\n @param[in] frequency_hz The audio frequency to command in Hz\n @param[in] duration_ms Duration of the signal activation\n @param[in] offTimeDuration_ms The amount of silent time in the signal\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient25send_control_audio_signalEhttt"]
    pub fn isobus_VirtualTerminalClient_send_control_audio_signal(
        this: *mut isobus_VirtualTerminalClient,
        activations: u8,
        frequency_hz: u16,
        duration_ms: u16,
        offTimeDuration_ms: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the set audio volume command\n @details This command applies to subsequent Control Audio Signal commands.\n VTs that are not able to modify the volume of the currently playing tone shall set\n the Audio device is busy bit in the response.This command should not affect in any way\n the volume settings of other Working Sets and shall not affect the volume of Alarm Masks.\n @param[in] volume_percent The volume percentage to set the VT server to\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient21send_set_audio_volumeEh"]
    pub fn isobus_VirtualTerminalClient_send_set_audio_volume(
        this: *mut isobus_VirtualTerminalClient,
        volume_percent: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change child location command\n @details The Change Child Location command is used to change the position of an object. The new position is set\n relative to the object's current position. Since the object can be included in many\n parent objects, the parent Object ID is also included. If a parent object includes\n the child object multiple times, then each instance will be moved.\n The position attributes given in the message have an offset of -127, so\n a value of 255 results in a +128 px move.\n Positive values indicate a position change down or to the right. Negative values\n indicate a position change up or to the left.\n @param[in] objectID The ID of the target object\n @param[in] parentObjectID The ID of the object's parent object\n @param[in] relativeXPositionChange The amount to change the X position by (px)\n @param[in] relativeYPositionChange The amount to change the Y position by (px)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient26send_change_child_locationEtthh"]
    pub fn isobus_VirtualTerminalClient_send_change_child_location(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        parentObjectID: u16,
        relativeXPositionChange: u8,
        relativeYPositionChange: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change child position command\n @details The new position is set relative to the parent object's position.\n Since the object can be included in many parent objects, the parent Object ID\n is also included.If a parent object includes the child object multiples times,\n then each instance will be moved to the same location(the designer may want to\n use Change Child Location command to move all instances in a relative motion).\n When the object is moved, the parent object shall be refreshed.\n The position attributes given in the message are signed integer.\n Positive values indicate a position below(Y) or to the right of(X) the top left\n corner of the parent object.Negative values indicate a position above(Y) or to the\n left of(X) the top left corner of the parent object.\n @param[in] objectID The ID of the target object\n @param[in] parentObjectID The ID of the object's parent object\n @param[in] xPosition The new X position of the object (px)\n @param[in] yPosition The new Y position of the object (px)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient26send_change_child_positionEtttt"]
    pub fn isobus_VirtualTerminalClient_send_change_child_position(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        parentObjectID: u16,
        xPosition: u16,
        yPosition: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change size command\n @details A value of 0 for width or height or both\n means that the object size is 0 and the object is not drawn.\n @param[in] objectID The ID of the target object\n @param[in] newWidth The new width of the object\n @param[in] newHeight The new height of the object\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_change_size_commandEttt"]
    pub fn isobus_VirtualTerminalClient_send_change_size_command(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        newWidth: u16,
        newHeight: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change background color command\n @param[in] objectID The ID of the target object\n @param[in] color The new background color of the object\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient29send_change_background_colourEth"]
    pub fn isobus_VirtualTerminalClient_send_change_background_colour(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        color: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change numeric value command\n @details The size of the object shall not be changed by this command. Only the object indicated in the\n command is to be changed, variables referenced by the object are not changed.\n @param[in] objectID The ID of the target object\n @param[in] value The new numeric value of the object\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient25send_change_numeric_valueEtj"]
    pub fn isobus_VirtualTerminalClient_send_change_numeric_value(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        value: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change string value command\n @details The size of the object shall not be changed by this command. Only the object indicated in the\n command is to be changed, variables referenced by the object are not changed.\n The transferred string is allowed to be smaller than the length of the value attribute of the target object and in\n this case the VT shall pad the value attribute with space characters.\n @param[in] objectID The ID of the target object\n @param[in] stringLength The length of the string to be sent\n @param[in] value The string to be sent\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_change_string_valueEttPKc"]
    pub fn isobus_VirtualTerminalClient_send_change_string_value(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        stringLength: u16,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change string value command (with a c++ string instead of buffer + length)\n @details The size of the object shall not be changed by this command. Only the object indicated in the\n command is to be changed, variables referenced by the object are not changed.\n The transferred string is allowed to be smaller than the length of the value attribute of the target object and in\n this case the VT shall pad the value attribute with space characters.\n @param[in] objectID The ID of the target object\n @param[in] value The string to be sent\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_change_string_valueEtRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_VirtualTerminalClient_send_change_string_value1(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        value: *const std_string,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change endpoint command, which changes the end of an output line\n @param[in] objectID The ID of the target object\n @param[in] width_px The width to change the output line to\n @param[in] height_px The height to change the output line to\n @param[in] direction The line direction (refer to output line object attributes)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient20send_change_endpointEtttNS0_13LineDirectionE"]
    pub fn isobus_VirtualTerminalClient_send_change_endpoint(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        width_px: u16,
        height_px: u16,
        direction: isobus_VirtualTerminalClient_LineDirection,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change font attributes command\n @details This command is used to change the Font Attributes in a Font Attributes object.\n @param[in] objectID The ID of the target object\n @param[in] color See the standard VT colour palette for more details\n @param[in] size Font size\n @param[in] type Font Type\n @param[in] styleBitfield The font style encoded as a bitfield\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient27send_change_font_attributesEthNS0_8FontSizeEhh"]
    pub fn isobus_VirtualTerminalClient_send_change_font_attributes(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        color: u8,
        size: isobus_VirtualTerminalClient_FontSize,
        type_: u8,
        styleBitfield: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change line attributes command\n @details This command is used to change the Line Attributes in a Line Attributes object.\n @param[in] objectID The ID of the target object\n @param[in] color See the standard VT colour palette for more details\n @param[in] width The line width\n @param[in] lineArtBitmask The line art, encoded as a bitfield (See ISO11783-6 for details)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient27send_change_line_attributesEthht"]
    pub fn isobus_VirtualTerminalClient_send_change_line_attributes(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        color: u8,
        width: u8,
        lineArtBitmask: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change fill attributes command\n @details This command is used to change the Fill Attributes in a Fill Attributes object.\n @param[in] objectID The ID of the target object\n @param[in] fillType The fill type\n @param[in] color See the standard VT colour palette for more details\n @param[in] fillPatternObjectID Object ID to a fill pattern or NULL_OBJECT_ID\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient27send_change_fill_attributesEtNS0_8FillTypeEht"]
    pub fn isobus_VirtualTerminalClient_send_change_fill_attributes(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        fillType: isobus_VirtualTerminalClient_FillType,
        color: u8,
        fillPatternObjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change active mask command\n @details This command is used to change the active mask of a Working Set\n to either a Data Mask object or an Alarm Mask object.\n @param[in] workingSetObjectID The ID of the working set\n @param[in] newActiveMaskObjectID The object ID of the new active mask\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient23send_change_active_maskEtt"]
    pub fn isobus_VirtualTerminalClient_send_change_active_mask(
        this: *mut isobus_VirtualTerminalClient,
        workingSetObjectID: u16,
        newActiveMaskObjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change softkey mask command\n @details This command is used to change the Soft Key Mask associated with a\n Data Mask object or an Alarm Mask object.\n @param[in] type The mask type, alarm or data\n @param[in] dataOrAlarmMaskObjectID The object ID of the target mask\n @param[in] newSoftKeyMaskObjectID The object ID of the new softkey mask\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_change_softkey_maskENS0_8MaskTypeEtt"]
    pub fn isobus_VirtualTerminalClient_send_change_softkey_mask(
        this: *mut isobus_VirtualTerminalClient,
        type_: isobus_VirtualTerminalClient_MaskType,
        dataOrAlarmMaskObjectID: u16,
        newSoftKeyMaskObjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change attribute command\n @details This command is used to change any attribute with an assigned Attribute ID.\n This message cannot be used to change strings.\n @param[in] objectID The ID of the target object\n @param[in] attributeID The attribute ID of the attribute being changed\n @param[in] value The new attribute value\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient21send_change_attributeEthj"]
    pub fn isobus_VirtualTerminalClient_send_change_attribute(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        attributeID: u8,
        value: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change priority command\n @details This command is used to change the priority of an Alarm Mask.\n This command causes the VT to evaluate the priority of all active masks and\n may cause a change to a different mask if the Alarm Mask being changed\n should either become the active Working Set and mask,\n or should no longer be the active Working Set and mask.\n @param[in] alarmMaskObjectID The object ID of the target alarm mask\n @param[in] priority The new priority for the mask\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient20send_change_priorityEtNS0_17AlarmMaskPriorityE"]
    pub fn isobus_VirtualTerminalClient_send_change_priority(
        this: *mut isobus_VirtualTerminalClient,
        alarmMaskObjectID: u16,
        priority: isobus_VirtualTerminalClient_AlarmMaskPriority,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change list item command\n @details This command is used to change a list item in an Input List object,\n Output List object, animation object, or external object definition object.\n NULL_OBJECT_ID will result in the list item being removed, but will not change the index\n order of the other list items.\n @param[in] objectID The object ID of the list\n @param[in] listIndex The index in the list to edit\n @param[in] newObjectID The new object ID for the specified list index, or NULL_OBJECT_ID.\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient21send_change_list_itemEtht"]
    pub fn isobus_VirtualTerminalClient_send_change_list_item(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        listIndex: u8,
        newObjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the lock unlock mask command\n @details This command is used by a Working Set to disallow or allow\n screen refreshes at the VT for the visible Data Mask or User Layout Data Mask\n owned by the requesting Working Set.\n This message would be used when a series of changes need to be synchronized or made visually atomic.\n The mask may be unlocked if a a timeout occurs based on the timeout attribute of this message, or by\n several other methods outlined in ISO11783-6, such as \"proprietary reasons\".\n @param[in] state The target lock/unlock state\n @param[in] objectID The object ID of the target mask\n @param[in] timeout_ms The max time to lock the mask, or 0 for no timeout. Does not apply to unlock commands.\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient21send_lock_unlock_maskENS0_13MaskLockStateEtt"]
    pub fn isobus_VirtualTerminalClient_send_lock_unlock_mask(
        this: *mut isobus_VirtualTerminalClient,
        state: isobus_VirtualTerminalClient_MaskLockState,
        objectID: u16,
        timeout_ms: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the execute macro command\n @details This command is used to execute a Macro.\n @param[in] objectID The ID of the target object\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient18send_execute_macroEt"]
    pub fn isobus_VirtualTerminalClient_send_execute_macro(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change object label command\n @details This command is used by an ECU to change a label of an object.\n @param[in] objectID The ID of the target object\n @param[in] labelStringObjectID The label's object ID\n @param[in] fontType The font type or NULL_OBJECT_ID\n @param[in] graphicalDesignatorObjectID Object ID of an object to be used as a graphic representation of the object label or NULL_OBJECT_ID\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_change_object_labelEttht"]
    pub fn isobus_VirtualTerminalClient_send_change_object_label(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        labelStringObjectID: u16,
        fontType: u8,
        graphicalDesignatorObjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends change polygon point command\n @details This command is used by a Working Set to modify a point in an Output Polygon object.\n @param[in] objectID The ID of the target object\n @param[in] pointIndex The index of the point in the polygon to edit\n @param[in] newXValue The new X axis value (px)\n @param[in] newYValue The new Y axis value (px)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient25send_change_polygon_pointEthtt"]
    pub fn isobus_VirtualTerminalClient_send_change_polygon_point(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        pointIndex: u8,
        newXValue: u16,
        newYValue: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change polygon scale command\n @details This command is used by a Working Set to change the scale of a complete Output Polygon object. This\n message causes the value of the polygon points to be changed.\n @param[in] objectID The ID of the target object\n @param[in] widthAttribute New width attribute\n @param[in] heightAttribute New height attribute\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient25send_change_polygon_scaleEttt"]
    pub fn isobus_VirtualTerminalClient_send_change_polygon_scale(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        widthAttribute: u16,
        heightAttribute: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the select color map or palette command\n @param[in] objectID The object to select\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient32send_select_color_map_or_paletteEt"]
    pub fn isobus_VirtualTerminalClient_send_select_color_map_or_palette(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the execute extended macro command\n @details Executes an extended macro\n @param[in] objectID The object ID of the extended macro to execute\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient27send_execute_extended_macroEt"]
    pub fn isobus_VirtualTerminalClient_send_execute_extended_macro(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the select active working set command\n @param[in] NAMEofWorkingSetMasterForDesiredWorkingSet The NAME of the target working set master\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient30send_select_active_working_setEy"]
    pub fn isobus_VirtualTerminalClient_send_select_active_working_set(
        this: *mut isobus_VirtualTerminalClient,
        NAMEofWorkingSetMasterForDesiredWorkingSet: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the set graphics cursor command\n @details This command sets the graphics cursor X/Y attributes of the object.\n @param[in] objectID The ID of the target object\n @param[in] xPosition The new X position (px)\n @param[in] yPosition The new Y position (px)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_set_graphics_cursorEtss"]
    pub fn isobus_VirtualTerminalClient_send_set_graphics_cursor(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        xPosition: i16,
        yPosition: i16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the move graphics cursor command\n @details This command alters the graphics cursor x/y attributes of the object\n by moving it relative to its current position.\n @param[in] objectID The ID of the target object\n @param[in] xOffset The new relative X offset of the cursor\n @param[in] yOffset The new relative Y offset of the cursor\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient25send_move_graphics_cursorEtss"]
    pub fn isobus_VirtualTerminalClient_send_move_graphics_cursor(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        xOffset: i16,
        yOffset: i16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the set foreground color command\n @details This command modifies the foreground colour\n attribute.The graphics cursor is not moved.\n @param[in] objectID The ID of the target object\n @param[in] color See standard color palette, 0-255\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient26send_set_foreground_colourEth"]
    pub fn isobus_VirtualTerminalClient_send_set_foreground_colour(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        color: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the set background color command\n @details This command modifies the background colour\n attribute.The graphics cursor is not moved.\n @param[in] objectID The ID of the target object\n @param[in] color See standard color palette, 0-255\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient26send_set_background_colourEth"]
    pub fn isobus_VirtualTerminalClient_send_set_background_colour(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        color: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the set line attributes object id\n @details This command modifies the Output Line object\n attribute. All drawing commands that follow use the new attribute value.\n For line suppression, set the Object ID to NULL.\n The graphics cursor is not moved.\n @param[in] objectID The ID of the target object\n @param[in] lineAttributeobjectID The object ID of the line attribute\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient34send_set_line_attributes_object_idEtt"]
    pub fn isobus_VirtualTerminalClient_send_set_line_attributes_object_id(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        lineAttributeobjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the fill attributes object id\n @details This command modifies the fill object attribute. All\n drawing commands that follow use the new attribute value.\n For no filling, set the Object ID to NULL. The\n graphics cursor is not moved.\n @param[in] objectID The ID of the target object\n @param[in] fillAttributeobjectID The object ID of the fill attribute\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient34send_set_fill_attributes_object_idEtt"]
    pub fn isobus_VirtualTerminalClient_send_set_fill_attributes_object_id(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        fillAttributeobjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the set fill attributes object ID command\n @details This command modifies the font object attribute. All\n drawing commands that follow use the new attribute value.\n If text is not being used, the object can be set to NULL.\n The graphics cursor is not moved.\n @param[in] objectID The ID of the target object\n @param[in] fontAttributesObjectID The object ID of the font attribute\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient34send_set_font_attributes_object_idEtt"]
    pub fn isobus_VirtualTerminalClient_send_set_font_attributes_object_id(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        fontAttributesObjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the erase rectangle command\n @details Fills the rectangle at the graphics cursor using the\n current background colour.For this command, the Fill Attributes Object is\n not used regardless of the state of Options bit 1 The graphics cursor is\n moved to the bottom right pixel inside of the rectangle.\n @param[in] objectID The ID of the target object\n @param[in] width The width of the rectangle\n @param[in] height The height of the rectangle\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient20send_erase_rectangleEttt"]
    pub fn isobus_VirtualTerminalClient_send_erase_rectangle(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        width: u16,
        height: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the draw point command\n @details Sets the pixel to the foreground colour. The graphics\n cursor is moved to the defined point.\n @param[in] objectID The ID of the target object\n @param[in] xOffset The pixel X offset relative to the cursor\n @param[in] yOffset The pixel Y offset relative to the cursor\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient15send_draw_pointEtss"]
    pub fn isobus_VirtualTerminalClient_send_draw_point(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        xOffset: i16,
        yOffset: i16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the draw line command\n @details Draws a line from the graphics cursor to the specified\n end pixel using the foreground colour. The Output Line\n Object drawing rules apply with respect to the end\n pixel location and Line Attributes.The graphics cursor\n is moved to the specified end pixel.\n @param[in] objectID The ID of the target object\n @param[in] xOffset The pixel X offset relative to the cursor\n @param[in] yOffset The pixel Y offset relative to the cursor\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient14send_draw_lineEtss"]
    pub fn isobus_VirtualTerminalClient_send_draw_line(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        xOffset: i16,
        yOffset: i16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the draw rectangle command\n @details Draws a rectangle at the graphics cursor. The\n Rectangle Object drawing rules apply.If a Line\n Attributes object is currently defined, the border is\n drawn. If a fill attribute object is currently defined,\n the rectangle is filled.The graphics cursor is moved to the\n bottom right pixel inside of the rectangle.\n @param[in] objectID The ID of the target object\n @param[in] width The width of the rectangle (px)\n @param[in] height The height of the rectangle (px)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient19send_draw_rectangleEttt"]
    pub fn isobus_VirtualTerminalClient_send_draw_rectangle(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        width: u16,
        height: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the draw closed ellipse message\n @details Draws a closed ellipse bounded by the rectangle\n defined by the current graphics cursor location and the\n width and height given.The Output Ellipse object\n drawing rules apply.If a Line Attributes object is currently defined,\n the border is drawn.If a fill attribute object is currently defined,\n the ellipse is filled. The graphics cursor is moved to the bottom right pixel\n inside of the bounding rectangle.\n @param[in] objectID The ID of the target object\n @param[in] width The width of the ellipse (px)\n @param[in] height The height of the ellipse (px)\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_draw_closed_ellipseEttt"]
    pub fn isobus_VirtualTerminalClient_send_draw_closed_ellipse(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        width: u16,
        height: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the draw polygon command\n @details Draws a polygon from the graphics cursor to the first\n point, then to the second point and so on. The polygon\n is closed if the last point has the offset 0,0. This is\n because offset 0,0 gives the coordinates of the original\n graphics cursor which was used as the first point in the\n polygon. If the data does not close the polygon, no\n automatic closing is performed and filling is ignored.\n Foreground colour is used for the border colour. The\n Output Polygon object drawing rules apply. If a Line\n Attributes object is currently defined, the border is\n drawn. If a fill object is currently defined and the\n polygon is closed, the polygon is filled. The graphics\n cursor is moved to the last point in the list.\n @param[in] objectID The ID of the target object\n @param[in] numberOfPoints Number of points in the polygon\n @param[in] listOfXOffsetsRelativeToCursor A list of X offsets for the points, relative to the cursor\n @param[in] listOfYOffsetsRelativeToCursor A list of Y offsets for the points, relative to the cursor\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient17send_draw_polygonEthPsS1_"]
    pub fn isobus_VirtualTerminalClient_send_draw_polygon(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        numberOfPoints: u8,
        listOfXOffsetsRelativeToCursor: *mut i16,
        listOfYOffsetsRelativeToCursor: *mut i16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the draw text command\n @details Draws the given text using the Font Attributes object.\n Any flashing bits in the Font style of the Font Attributes\n object are ignored If opaque, the background colour\n attribute is used.The graphics cursor is moved to the\n bottom right corner of the extent of the text.\n @param[in] objectID The ID of the target object\n @param[in] transparent Denotes if the text background is transparent\n @param[in] textLength String length\n @param[in] value A buffer to the text to draw with length `textLength`\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient14send_draw_textEtbhPKc"]
    pub fn isobus_VirtualTerminalClient_send_draw_text(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        transparent: bool,
        textLength: u8,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the pan viewport command\n @details This command modifies the viewport X and Y\n attributes and forces a redraw of the object.This\n allows �panning� of the underlying object contents.\n The graphics cursor is not moved.\n @param[in] objectID The ID of the target object\n @param[in] xAttribute The viewport X attribute\n @param[in] yAttribute The viewport Y attribute\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient17send_pan_viewportEtss"]
    pub fn isobus_VirtualTerminalClient_send_pan_viewport(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        xAttribute: i16,
        yAttribute: i16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the zoom viewport command\n @details This command allows magnification of the viewport\n contents. See section on zooming for meaning of the\n zoom value. The graphics cursor is not moved.\n @param[in] objectID The ID of the target object\n @param[in] zoom Zoom value, -32.0 to 32.0\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient18send_zoom_viewportEtf"]
    pub fn isobus_VirtualTerminalClient_send_zoom_viewport(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        zoom: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the pan and zoom viewport command\n @details This command allows both panning and zooming at the same time.\n @param[in] objectID The ID of the target object\n @param[in] xAttribute The viewport X attribute\n @param[in] yAttribute The viewport Y attribute\n @param[in] zoom Zoom value, -32.0 to 32.0\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient26send_pan_and_zoom_viewportEtssf"]
    pub fn isobus_VirtualTerminalClient_send_pan_and_zoom_viewport(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        xAttribute: i16,
        yAttribute: i16,
        zoom: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the change viewport size command\n @details This command changes the size of the viewport and\n can be compared to the normal Change Size\n command.The graphics cursor is not moved.\n @param[in] objectID The ID of the target object\n @param[in] width The width of the viewport\n @param[in] height The height of the viewport\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient25send_change_viewport_sizeEttt"]
    pub fn isobus_VirtualTerminalClient_send_change_viewport_size(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        width: u16,
        height: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the draw VT object command\n @details his command draws the VT Object specified by the Object ID\n at the current graphics cursor location.\n @param[in] graphicsContextObjectID The ID of the target graphics context object\n @param[in] VTObjectID The object ID to draw\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient19send_draw_vt_objectEtt"]
    pub fn isobus_VirtualTerminalClient_send_draw_vt_object(
        this: *mut isobus_VirtualTerminalClient,
        graphicsContextObjectID: u16,
        VTObjectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the copy canvas to picture graphic command\n @details This command copies the current canvas of the\n Graphics Context Object into the Picture Graphic object specified.\n @param[in] graphicsContextObjectID The ID of the target graphics context object\n @param[in] objectID The picture graphic's object ID to copy to\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient35send_copy_canvas_to_picture_graphicEtt"]
    pub fn isobus_VirtualTerminalClient_send_copy_canvas_to_picture_graphic(
        this: *mut isobus_VirtualTerminalClient,
        graphicsContextObjectID: u16,
        objectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the copy viewport to picture graphic command\n @details This command copies the current Viewport of the GCO into the\n specified picture graphic.\n @param[in] graphicsContextObjectID The ID of the target graphics context object\n @param[in] objectID The picture graphic's object ID to copy to\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient37send_copy_viewport_to_picture_graphicEtt"]
    pub fn isobus_VirtualTerminalClient_send_copy_viewport_to_picture_graphic(
        this: *mut isobus_VirtualTerminalClient,
        graphicsContextObjectID: u16,
        objectID: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends the get attribute value message\n @param[in] objectID The object ID to query\n @param[in] attributeID The attribute object to query\n @returns true if the message was sent successfully"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient24send_get_attribute_valueEth"]
    pub fn isobus_VirtualTerminalClient_send_get_attribute_value(
        this: *mut isobus_VirtualTerminalClient,
        objectID: u16,
        attributeID: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the number of X axis pixels in a softkey\n @returns The number of X axis pixels in a softkey"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient25get_softkey_x_axis_pixelsEv"]
    pub fn isobus_VirtualTerminalClient_get_softkey_x_axis_pixels(
        this: *const isobus_VirtualTerminalClient,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Returns the number of Y axis pixels in a softkey\n @returns The number of Y axis pixels in a softkey"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient25get_softkey_y_axis_pixelsEv"]
    pub fn isobus_VirtualTerminalClient_get_softkey_y_axis_pixels(
        this: *const isobus_VirtualTerminalClient,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Returns the number of virtual softkeys reported by the VT server\n @returns The number of virtual softkeys reported by the VT server"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient27get_number_virtual_softkeysEv"]
    pub fn isobus_VirtualTerminalClient_get_number_virtual_softkeys(
        this: *const isobus_VirtualTerminalClient,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Returns the number of physical softkeys reported by the VT server\n @returns The number of physical softkeys reported by the VT server"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient28get_number_physical_softkeysEv"]
    pub fn isobus_VirtualTerminalClient_get_number_physical_softkeys(
        this: *const isobus_VirtualTerminalClient,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Returns if the selected font is supported\n @param[in] value The font to check against\n @returns true if the font is supported by the VT server"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient23get_font_size_supportedENS0_8FontSizeE"]
    pub fn isobus_VirtualTerminalClient_get_font_size_supported(
        this: *const isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_FontSize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if the selected font style is supported\n @param[in] value The font style to check against\n @returns true if the font style is supported by the VT server"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient24get_font_style_supportedENS0_13FontStyleBitsE"]
    pub fn isobus_VirtualTerminalClient_get_font_style_supported(
        this: *const isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_FontStyleBits,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the graphics mode supported by the VT server\n @returns The graphics mode supported by the VT server"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient16get_graphic_modeEv"]
    pub fn isobus_VirtualTerminalClient_get_graphic_mode(
        this: *const isobus_VirtualTerminalClient,
    ) -> isobus_VirtualTerminalClient_GraphicMode;
}
extern "C" {
    #[doc = " @brief Returns if the VT server supports a touchscreen with pointing message\n @returns true if the VT server supports a touchscreen with pointing message"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient45get_support_touchscreen_with_pointing_messageEv"]
    pub fn isobus_VirtualTerminalClient_get_support_touchscreen_with_pointing_message(
        this: *const isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if the VT server supports a pointing device with pointing message\n @returns true if the VT server supports a pointing device with pointing message"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient49get_support_pointing_device_with_pointing_messageEv"]
    pub fn isobus_VirtualTerminalClient_get_support_pointing_device_with_pointing_message(
        this: *const isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if the VT server supports multiple frequency audio output\n @returns true if the VT server supports multiple frequency audio output"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient35get_multiple_frequency_audio_outputEv"]
    pub fn isobus_VirtualTerminalClient_get_multiple_frequency_audio_output(
        this: *const isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if the VT server supports adjustable volume output\n @returns true if the VT server supports adjustable volume output"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient32get_has_adjustable_volume_outputEv"]
    pub fn isobus_VirtualTerminalClient_get_has_adjustable_volume_output(
        this: *const isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if the VT server supports simultaneous activation of physical keys\n @returns true if the VT server supports simultaneous activation of physical keys"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient49get_support_simultaneous_activation_physical_keysEv"]
    pub fn isobus_VirtualTerminalClient_get_support_simultaneous_activation_physical_keys(
        this: *const isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if the VT server supports simultaneous activation of buttons and softkeys\n @returns true if the VT server supports simultaneous activation of buttons and softkeys"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient56get_support_simultaneous_activation_buttons_and_softkeysEv"]
    pub fn isobus_VirtualTerminalClient_get_support_simultaneous_activation_buttons_and_softkeys(
        this: *const isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if the VT supports the drag operation\n @returns true if the VT supports the drag operation"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient26get_support_drag_operationEv"]
    pub fn isobus_VirtualTerminalClient_get_support_drag_operation(
        this: *const isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns if the VT supports the intermediate coordinates during a drag operation\n @returns true if the VT supports the intermediate coordinates during a drag operation"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient59get_support_intermediate_coordinates_during_drag_operationsEv"]
    pub fn isobus_VirtualTerminalClient_get_support_intermediate_coordinates_during_drag_operations(
        this: *const isobus_VirtualTerminalClient,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the number of x pixels in the data mask area\n @returns the number of x pixels in the data mask area"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient19get_number_x_pixelsEv"]
    pub fn isobus_VirtualTerminalClient_get_number_x_pixels(
        this: *const isobus_VirtualTerminalClient,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Returns the number of y pixels in the data mask area\n @returns the number of y pixels in the data mask area"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient19get_number_y_pixelsEv"]
    pub fn isobus_VirtualTerminalClient_get_number_y_pixels(
        this: *const isobus_VirtualTerminalClient,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Returns the VT version supported supported by the VT server\n @returns The VT version supported supported by the VT server"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient24get_connected_vt_versionEv"]
    pub fn isobus_VirtualTerminalClient_get_connected_vt_version(
        this: *const isobus_VirtualTerminalClient,
    ) -> isobus_VirtualTerminalClient_VTVersion;
}
extern "C" {
    #[doc = " @brief Returns if the VT version is supported by the VT server\n @param[in] value The VT version to check against\n @returns true if the VT version is supported by the VT server"]
    #[link_name = "\u{1}_ZNK6isobus21VirtualTerminalClient24get_vt_version_supportedENS0_9VTVersionE"]
    pub fn isobus_VirtualTerminalClient_get_vt_version_supported(
        this: *const isobus_VirtualTerminalClient,
        value: isobus_VirtualTerminalClient_VTVersion,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Assigns an object pool to the client using a buffer and size.\n @details This is good for small pools or pools where you have all the data in memory.\n @param[in] poolIndex The index of the pool you are assigning\n @param[in] poolSupportedVTVersion The VT version of the object pool\n @param[in] pool A pointer to the object pool. Must remain valid until client is connected!\n @param[in] size The object pool size\n @param[in] version An optional version string. The stack will automatically store/load your pool from the VT if this is provided."]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient15set_object_poolEhNS0_9VTVersionEPKhjNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_VirtualTerminalClient_set_object_pool(
        this: *mut isobus_VirtualTerminalClient,
        poolIndex: u8,
        poolSupportedVTVersion: isobus_VirtualTerminalClient_VTVersion,
        pool: *const u8,
        size: u32,
        version: std_string,
    );
}
extern "C" {
    #[doc = " @brief Assigns an object pool to the client using a vector.\n @details This is good for small pools or pools where you have all the data in memory.\n @param[in] poolIndex The index of the pool you are assigning\n @param[in] poolSupportedVTVersion The VT version of the object pool\n @param[in] pool A pointer to the object pool. Must remain valid until client is connected!\n @param[in] version An optional version string. The stack will automatically store/load your pool from the VT if this is provided."]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient15set_object_poolEhNS0_9VTVersionEPKSt6vectorIhSaIhEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn isobus_VirtualTerminalClient_set_object_pool1(
        this: *mut isobus_VirtualTerminalClient,
        poolIndex: u8,
        poolSupportedVTVersion: isobus_VirtualTerminalClient_VTVersion,
        pool: *const [u64; 3usize],
        version: std_string,
    );
}
extern "C" {
    #[doc = " @brief Assigns an object pool to the client where the client will get data in chunks during upload.\n @details This is probably better for huge pools if you are RAM constrained, or if your\n pool is stored on some external device that you need to get data from in pages.\n This is also the best way to load from IOP files, as you can read the data in piece by piece.\n @param[in] poolIndex The index of the pool you are assigning\n @param[in] poolSupportedVTVersion The VT version of the object pool\n @param[in] poolTotalSize The object pool size\n @param[in] value The data callback that will be used to get object pool data to upload."]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient40register_object_pool_data_chunk_callbackEhNS0_9VTVersionEjPFbjjjPhPvE"]
    pub fn isobus_VirtualTerminalClient_register_object_pool_data_chunk_callback(
        this: *mut isobus_VirtualTerminalClient,
        poolIndex: u8,
        poolSupportedVTVersion: isobus_VirtualTerminalClient_VTVersion,
        poolTotalSize: u32,
        value: isobus_DataChunkCallback,
    );
}
extern "C" {
    #[doc = " @brief Periodic Update Function (worker thread may call this)\n @details This class can spawn a thread, or you can supply your own to run this function.\n To configure that behavior, see the initialize function."]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClient6updateEv"]
    pub fn isobus_VirtualTerminalClient_update(this: *mut isobus_VirtualTerminalClient);
}
extern "C" {
    #[doc = " @brief The constructor for a VirtualTerminalClient\n @param[in] partner The VT server control function\n @param[in] clientSource The internal control function to communicate from"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClientC1ESt10shared_ptrINS_24PartneredControlFunctionEES1_INS_23InternalControlFunctionEE"]
    pub fn isobus_VirtualTerminalClient_VirtualTerminalClient(
        this: *mut isobus_VirtualTerminalClient,
        partner: [u64; 2usize],
        clientSource: [u64; 2usize],
    );
}
extern "C" {
    #[doc = " @brief The destructor for the VirtualTerminalClient"]
    #[link_name = "\u{1}_ZN6isobus21VirtualTerminalClientD1Ev"]
    pub fn isobus_VirtualTerminalClient_VirtualTerminalClient_destructor(
        this: *mut isobus_VirtualTerminalClient,
    );
}
impl isobus_VirtualTerminalClient {
    #[inline]
    pub unsafe fn initialize(&mut self, spawnThread: bool) {
        isobus_VirtualTerminalClient_initialize(self, spawnThread)
    }
    #[inline]
    pub unsafe fn get_is_initialized(&mut self) -> bool {
        isobus_VirtualTerminalClient_get_is_initialized(self)
    }
    #[inline]
    pub unsafe fn terminate(&mut self) {
        isobus_VirtualTerminalClient_terminate(self)
    }
    #[inline]
    pub unsafe fn register_vt_soft_key_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTKeyEventCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_soft_key_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_soft_key_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTKeyEventCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_soft_key_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_button_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTKeyEventCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_button_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_button_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTKeyEventCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_button_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_pointing_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTPointingEventCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_pointing_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_pointing_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTPointingEventCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_pointing_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_select_input_object_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTSelectInputObjectCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_select_input_object_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_selection_input_object_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTSelectInputObjectCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_selection_input_object_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_esc_message_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTESCMessageCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_esc_message_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_esc_message_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTESCMessageCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_esc_message_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_change_numeric_value_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTChangeNumericValueCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_change_numeric_value_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_change_numeric_value_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTChangeNumericValueCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_change_numeric_value_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_change_active_mask_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTChangeActiveMaskCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_change_active_mask_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_change_active_mask_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTChangeActiveMaskCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_change_active_mask_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_change_soft_key_mask_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTChangeSoftKeyMaskCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_change_soft_key_mask_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_change_soft_key_mask_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTChangeSoftKeyMaskCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_change_soft_key_mask_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_change_string_value_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTChangeStringValueCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_change_string_value_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_change_string_value_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTChangeStringValueCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_change_string_value_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_user_layout_hide_show_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTUserLayoutHideShowCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_user_layout_hide_show_event_callback(self, value)
    }
    #[inline]
    pub unsafe fn remove_vt_user_layout_hide_show_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTUserLayoutHideShowCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_user_layout_hide_show_callback(self, value)
    }
    #[inline]
    pub unsafe fn register_vt_control_audio_signal_termination_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTAudioSignalTerminationCallback,
    ) {
        isobus_VirtualTerminalClient_register_vt_control_audio_signal_termination_event_callback(
            self, value,
        )
    }
    #[inline]
    pub unsafe fn remove_vt_control_audio_signal_termination_event_callback(
        &mut self,
        value: isobus_VirtualTerminalClient_VTAudioSignalTerminationCallback,
    ) {
        isobus_VirtualTerminalClient_remove_vt_control_audio_signal_termination_event_callback(
            self, value,
        )
    }
    #[inline]
    pub unsafe fn send_hide_show_object(
        &mut self,
        objectID: u16,
        command: isobus_VirtualTerminalClient_HideShowObjectCommand,
    ) -> bool {
        isobus_VirtualTerminalClient_send_hide_show_object(self, objectID, command)
    }
    #[inline]
    pub unsafe fn send_enable_disable_object(
        &mut self,
        objectID: u16,
        command: isobus_VirtualTerminalClient_EnableDisableObjectCommand,
    ) -> bool {
        isobus_VirtualTerminalClient_send_enable_disable_object(self, objectID, command)
    }
    #[inline]
    pub unsafe fn send_select_input_object(
        &mut self,
        objectID: u16,
        option: isobus_VirtualTerminalClient_SelectInputObjectOptions,
    ) -> bool {
        isobus_VirtualTerminalClient_send_select_input_object(self, objectID, option)
    }
    #[inline]
    pub unsafe fn send_ESC(&mut self) -> bool {
        isobus_VirtualTerminalClient_send_ESC(self)
    }
    #[inline]
    pub unsafe fn send_control_audio_signal(
        &mut self,
        activations: u8,
        frequency_hz: u16,
        duration_ms: u16,
        offTimeDuration_ms: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_control_audio_signal(
            self,
            activations,
            frequency_hz,
            duration_ms,
            offTimeDuration_ms,
        )
    }
    #[inline]
    pub unsafe fn send_set_audio_volume(&mut self, volume_percent: u8) -> bool {
        isobus_VirtualTerminalClient_send_set_audio_volume(self, volume_percent)
    }
    #[inline]
    pub unsafe fn send_change_child_location(
        &mut self,
        objectID: u16,
        parentObjectID: u16,
        relativeXPositionChange: u8,
        relativeYPositionChange: u8,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_child_location(
            self,
            objectID,
            parentObjectID,
            relativeXPositionChange,
            relativeYPositionChange,
        )
    }
    #[inline]
    pub unsafe fn send_change_child_position(
        &mut self,
        objectID: u16,
        parentObjectID: u16,
        xPosition: u16,
        yPosition: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_child_position(
            self,
            objectID,
            parentObjectID,
            xPosition,
            yPosition,
        )
    }
    #[inline]
    pub unsafe fn send_change_size_command(
        &mut self,
        objectID: u16,
        newWidth: u16,
        newHeight: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_size_command(self, objectID, newWidth, newHeight)
    }
    #[inline]
    pub unsafe fn send_change_background_colour(&mut self, objectID: u16, color: u8) -> bool {
        isobus_VirtualTerminalClient_send_change_background_colour(self, objectID, color)
    }
    #[inline]
    pub unsafe fn send_change_numeric_value(&mut self, objectID: u16, value: u32) -> bool {
        isobus_VirtualTerminalClient_send_change_numeric_value(self, objectID, value)
    }
    #[inline]
    pub unsafe fn send_change_string_value(
        &mut self,
        objectID: u16,
        stringLength: u16,
        value: *const ::std::os::raw::c_char,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_string_value(self, objectID, stringLength, value)
    }
    #[inline]
    pub unsafe fn send_change_string_value1(
        &mut self,
        objectID: u16,
        value: *const std_string,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_string_value1(self, objectID, value)
    }
    #[inline]
    pub unsafe fn send_change_endpoint(
        &mut self,
        objectID: u16,
        width_px: u16,
        height_px: u16,
        direction: isobus_VirtualTerminalClient_LineDirection,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_endpoint(
            self, objectID, width_px, height_px, direction,
        )
    }
    #[inline]
    pub unsafe fn send_change_font_attributes(
        &mut self,
        objectID: u16,
        color: u8,
        size: isobus_VirtualTerminalClient_FontSize,
        type_: u8,
        styleBitfield: u8,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_font_attributes(
            self,
            objectID,
            color,
            size,
            type_,
            styleBitfield,
        )
    }
    #[inline]
    pub unsafe fn send_change_line_attributes(
        &mut self,
        objectID: u16,
        color: u8,
        width: u8,
        lineArtBitmask: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_line_attributes(
            self,
            objectID,
            color,
            width,
            lineArtBitmask,
        )
    }
    #[inline]
    pub unsafe fn send_change_fill_attributes(
        &mut self,
        objectID: u16,
        fillType: isobus_VirtualTerminalClient_FillType,
        color: u8,
        fillPatternObjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_fill_attributes(
            self,
            objectID,
            fillType,
            color,
            fillPatternObjectID,
        )
    }
    #[inline]
    pub unsafe fn send_change_active_mask(
        &mut self,
        workingSetObjectID: u16,
        newActiveMaskObjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_active_mask(
            self,
            workingSetObjectID,
            newActiveMaskObjectID,
        )
    }
    #[inline]
    pub unsafe fn send_change_softkey_mask(
        &mut self,
        type_: isobus_VirtualTerminalClient_MaskType,
        dataOrAlarmMaskObjectID: u16,
        newSoftKeyMaskObjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_softkey_mask(
            self,
            type_,
            dataOrAlarmMaskObjectID,
            newSoftKeyMaskObjectID,
        )
    }
    #[inline]
    pub unsafe fn send_change_attribute(
        &mut self,
        objectID: u16,
        attributeID: u8,
        value: u32,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_attribute(self, objectID, attributeID, value)
    }
    #[inline]
    pub unsafe fn send_change_priority(
        &mut self,
        alarmMaskObjectID: u16,
        priority: isobus_VirtualTerminalClient_AlarmMaskPriority,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_priority(self, alarmMaskObjectID, priority)
    }
    #[inline]
    pub unsafe fn send_change_list_item(
        &mut self,
        objectID: u16,
        listIndex: u8,
        newObjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_list_item(self, objectID, listIndex, newObjectID)
    }
    #[inline]
    pub unsafe fn send_lock_unlock_mask(
        &mut self,
        state: isobus_VirtualTerminalClient_MaskLockState,
        objectID: u16,
        timeout_ms: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_lock_unlock_mask(self, state, objectID, timeout_ms)
    }
    #[inline]
    pub unsafe fn send_execute_macro(&mut self, objectID: u16) -> bool {
        isobus_VirtualTerminalClient_send_execute_macro(self, objectID)
    }
    #[inline]
    pub unsafe fn send_change_object_label(
        &mut self,
        objectID: u16,
        labelStringObjectID: u16,
        fontType: u8,
        graphicalDesignatorObjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_object_label(
            self,
            objectID,
            labelStringObjectID,
            fontType,
            graphicalDesignatorObjectID,
        )
    }
    #[inline]
    pub unsafe fn send_change_polygon_point(
        &mut self,
        objectID: u16,
        pointIndex: u8,
        newXValue: u16,
        newYValue: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_polygon_point(
            self, objectID, pointIndex, newXValue, newYValue,
        )
    }
    #[inline]
    pub unsafe fn send_change_polygon_scale(
        &mut self,
        objectID: u16,
        widthAttribute: u16,
        heightAttribute: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_polygon_scale(
            self,
            objectID,
            widthAttribute,
            heightAttribute,
        )
    }
    #[inline]
    pub unsafe fn send_select_color_map_or_palette(&mut self, objectID: u16) -> bool {
        isobus_VirtualTerminalClient_send_select_color_map_or_palette(self, objectID)
    }
    #[inline]
    pub unsafe fn send_execute_extended_macro(&mut self, objectID: u16) -> bool {
        isobus_VirtualTerminalClient_send_execute_extended_macro(self, objectID)
    }
    #[inline]
    pub unsafe fn send_select_active_working_set(
        &mut self,
        NAMEofWorkingSetMasterForDesiredWorkingSet: u64,
    ) -> bool {
        isobus_VirtualTerminalClient_send_select_active_working_set(
            self,
            NAMEofWorkingSetMasterForDesiredWorkingSet,
        )
    }
    #[inline]
    pub unsafe fn send_set_graphics_cursor(
        &mut self,
        objectID: u16,
        xPosition: i16,
        yPosition: i16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_set_graphics_cursor(self, objectID, xPosition, yPosition)
    }
    #[inline]
    pub unsafe fn send_move_graphics_cursor(
        &mut self,
        objectID: u16,
        xOffset: i16,
        yOffset: i16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_move_graphics_cursor(self, objectID, xOffset, yOffset)
    }
    #[inline]
    pub unsafe fn send_set_foreground_colour(&mut self, objectID: u16, color: u8) -> bool {
        isobus_VirtualTerminalClient_send_set_foreground_colour(self, objectID, color)
    }
    #[inline]
    pub unsafe fn send_set_background_colour(&mut self, objectID: u16, color: u8) -> bool {
        isobus_VirtualTerminalClient_send_set_background_colour(self, objectID, color)
    }
    #[inline]
    pub unsafe fn send_set_line_attributes_object_id(
        &mut self,
        objectID: u16,
        lineAttributeobjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_set_line_attributes_object_id(
            self,
            objectID,
            lineAttributeobjectID,
        )
    }
    #[inline]
    pub unsafe fn send_set_fill_attributes_object_id(
        &mut self,
        objectID: u16,
        fillAttributeobjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_set_fill_attributes_object_id(
            self,
            objectID,
            fillAttributeobjectID,
        )
    }
    #[inline]
    pub unsafe fn send_set_font_attributes_object_id(
        &mut self,
        objectID: u16,
        fontAttributesObjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_set_font_attributes_object_id(
            self,
            objectID,
            fontAttributesObjectID,
        )
    }
    #[inline]
    pub unsafe fn send_erase_rectangle(&mut self, objectID: u16, width: u16, height: u16) -> bool {
        isobus_VirtualTerminalClient_send_erase_rectangle(self, objectID, width, height)
    }
    #[inline]
    pub unsafe fn send_draw_point(&mut self, objectID: u16, xOffset: i16, yOffset: i16) -> bool {
        isobus_VirtualTerminalClient_send_draw_point(self, objectID, xOffset, yOffset)
    }
    #[inline]
    pub unsafe fn send_draw_line(&mut self, objectID: u16, xOffset: i16, yOffset: i16) -> bool {
        isobus_VirtualTerminalClient_send_draw_line(self, objectID, xOffset, yOffset)
    }
    #[inline]
    pub unsafe fn send_draw_rectangle(&mut self, objectID: u16, width: u16, height: u16) -> bool {
        isobus_VirtualTerminalClient_send_draw_rectangle(self, objectID, width, height)
    }
    #[inline]
    pub unsafe fn send_draw_closed_ellipse(
        &mut self,
        objectID: u16,
        width: u16,
        height: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_draw_closed_ellipse(self, objectID, width, height)
    }
    #[inline]
    pub unsafe fn send_draw_polygon(
        &mut self,
        objectID: u16,
        numberOfPoints: u8,
        listOfXOffsetsRelativeToCursor: *mut i16,
        listOfYOffsetsRelativeToCursor: *mut i16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_draw_polygon(
            self,
            objectID,
            numberOfPoints,
            listOfXOffsetsRelativeToCursor,
            listOfYOffsetsRelativeToCursor,
        )
    }
    #[inline]
    pub unsafe fn send_draw_text(
        &mut self,
        objectID: u16,
        transparent: bool,
        textLength: u8,
        value: *const ::std::os::raw::c_char,
    ) -> bool {
        isobus_VirtualTerminalClient_send_draw_text(self, objectID, transparent, textLength, value)
    }
    #[inline]
    pub unsafe fn send_pan_viewport(
        &mut self,
        objectID: u16,
        xAttribute: i16,
        yAttribute: i16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_pan_viewport(self, objectID, xAttribute, yAttribute)
    }
    #[inline]
    pub unsafe fn send_zoom_viewport(&mut self, objectID: u16, zoom: f32) -> bool {
        isobus_VirtualTerminalClient_send_zoom_viewport(self, objectID, zoom)
    }
    #[inline]
    pub unsafe fn send_pan_and_zoom_viewport(
        &mut self,
        objectID: u16,
        xAttribute: i16,
        yAttribute: i16,
        zoom: f32,
    ) -> bool {
        isobus_VirtualTerminalClient_send_pan_and_zoom_viewport(
            self, objectID, xAttribute, yAttribute, zoom,
        )
    }
    #[inline]
    pub unsafe fn send_change_viewport_size(
        &mut self,
        objectID: u16,
        width: u16,
        height: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_change_viewport_size(self, objectID, width, height)
    }
    #[inline]
    pub unsafe fn send_draw_vt_object(
        &mut self,
        graphicsContextObjectID: u16,
        VTObjectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_draw_vt_object(self, graphicsContextObjectID, VTObjectID)
    }
    #[inline]
    pub unsafe fn send_copy_canvas_to_picture_graphic(
        &mut self,
        graphicsContextObjectID: u16,
        objectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_copy_canvas_to_picture_graphic(
            self,
            graphicsContextObjectID,
            objectID,
        )
    }
    #[inline]
    pub unsafe fn send_copy_viewport_to_picture_graphic(
        &mut self,
        graphicsContextObjectID: u16,
        objectID: u16,
    ) -> bool {
        isobus_VirtualTerminalClient_send_copy_viewport_to_picture_graphic(
            self,
            graphicsContextObjectID,
            objectID,
        )
    }
    #[inline]
    pub unsafe fn send_get_attribute_value(&mut self, objectID: u16, attributeID: u8) -> bool {
        isobus_VirtualTerminalClient_send_get_attribute_value(self, objectID, attributeID)
    }
    #[inline]
    pub unsafe fn get_softkey_x_axis_pixels(&self) -> u8 {
        isobus_VirtualTerminalClient_get_softkey_x_axis_pixels(self)
    }
    #[inline]
    pub unsafe fn get_softkey_y_axis_pixels(&self) -> u8 {
        isobus_VirtualTerminalClient_get_softkey_y_axis_pixels(self)
    }
    #[inline]
    pub unsafe fn get_number_virtual_softkeys(&self) -> u8 {
        isobus_VirtualTerminalClient_get_number_virtual_softkeys(self)
    }
    #[inline]
    pub unsafe fn get_number_physical_softkeys(&self) -> u8 {
        isobus_VirtualTerminalClient_get_number_physical_softkeys(self)
    }
    #[inline]
    pub unsafe fn get_font_size_supported(
        &self,
        value: isobus_VirtualTerminalClient_FontSize,
    ) -> bool {
        isobus_VirtualTerminalClient_get_font_size_supported(self, value)
    }
    #[inline]
    pub unsafe fn get_font_style_supported(
        &self,
        value: isobus_VirtualTerminalClient_FontStyleBits,
    ) -> bool {
        isobus_VirtualTerminalClient_get_font_style_supported(self, value)
    }
    #[inline]
    pub unsafe fn get_graphic_mode(&self) -> isobus_VirtualTerminalClient_GraphicMode {
        isobus_VirtualTerminalClient_get_graphic_mode(self)
    }
    #[inline]
    pub unsafe fn get_support_touchscreen_with_pointing_message(&self) -> bool {
        isobus_VirtualTerminalClient_get_support_touchscreen_with_pointing_message(self)
    }
    #[inline]
    pub unsafe fn get_support_pointing_device_with_pointing_message(&self) -> bool {
        isobus_VirtualTerminalClient_get_support_pointing_device_with_pointing_message(self)
    }
    #[inline]
    pub unsafe fn get_multiple_frequency_audio_output(&self) -> bool {
        isobus_VirtualTerminalClient_get_multiple_frequency_audio_output(self)
    }
    #[inline]
    pub unsafe fn get_has_adjustable_volume_output(&self) -> bool {
        isobus_VirtualTerminalClient_get_has_adjustable_volume_output(self)
    }
    #[inline]
    pub unsafe fn get_support_simultaneous_activation_physical_keys(&self) -> bool {
        isobus_VirtualTerminalClient_get_support_simultaneous_activation_physical_keys(self)
    }
    #[inline]
    pub unsafe fn get_support_simultaneous_activation_buttons_and_softkeys(&self) -> bool {
        isobus_VirtualTerminalClient_get_support_simultaneous_activation_buttons_and_softkeys(self)
    }
    #[inline]
    pub unsafe fn get_support_drag_operation(&self) -> bool {
        isobus_VirtualTerminalClient_get_support_drag_operation(self)
    }
    #[inline]
    pub unsafe fn get_support_intermediate_coordinates_during_drag_operations(&self) -> bool {
        isobus_VirtualTerminalClient_get_support_intermediate_coordinates_during_drag_operations(
            self,
        )
    }
    #[inline]
    pub unsafe fn get_number_x_pixels(&self) -> u16 {
        isobus_VirtualTerminalClient_get_number_x_pixels(self)
    }
    #[inline]
    pub unsafe fn get_number_y_pixels(&self) -> u16 {
        isobus_VirtualTerminalClient_get_number_y_pixels(self)
    }
    #[inline]
    pub unsafe fn get_connected_vt_version(&self) -> isobus_VirtualTerminalClient_VTVersion {
        isobus_VirtualTerminalClient_get_connected_vt_version(self)
    }
    #[inline]
    pub unsafe fn get_vt_version_supported(
        &self,
        value: isobus_VirtualTerminalClient_VTVersion,
    ) -> bool {
        isobus_VirtualTerminalClient_get_vt_version_supported(self, value)
    }
    #[inline]
    pub unsafe fn set_object_pool(
        &mut self,
        poolIndex: u8,
        poolSupportedVTVersion: isobus_VirtualTerminalClient_VTVersion,
        pool: *const u8,
        size: u32,
        version: std_string,
    ) {
        isobus_VirtualTerminalClient_set_object_pool(
            self,
            poolIndex,
            poolSupportedVTVersion,
            pool,
            size,
            version,
        )
    }
    #[inline]
    pub unsafe fn set_object_pool1(
        &mut self,
        poolIndex: u8,
        poolSupportedVTVersion: isobus_VirtualTerminalClient_VTVersion,
        pool: *const [u64; 3usize],
        version: std_string,
    ) {
        isobus_VirtualTerminalClient_set_object_pool1(
            self,
            poolIndex,
            poolSupportedVTVersion,
            pool,
            version,
        )
    }
    #[inline]
    pub unsafe fn register_object_pool_data_chunk_callback(
        &mut self,
        poolIndex: u8,
        poolSupportedVTVersion: isobus_VirtualTerminalClient_VTVersion,
        poolTotalSize: u32,
        value: isobus_DataChunkCallback,
    ) {
        isobus_VirtualTerminalClient_register_object_pool_data_chunk_callback(
            self,
            poolIndex,
            poolSupportedVTVersion,
            poolTotalSize,
            value,
        )
    }
    #[inline]
    pub unsafe fn update(&mut self) {
        isobus_VirtualTerminalClient_update(self)
    }
    #[inline]
    pub unsafe fn new(partner: [u64; 2usize], clientSource: [u64; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        isobus_VirtualTerminalClient_VirtualTerminalClient(
            __bindgen_tmp.as_mut_ptr(),
            partner,
            clientSource,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        isobus_VirtualTerminalClient_VirtualTerminalClient_destructor(self)
    }
}
#[doc = " @brief A protocol that handles the NMEA 2000 fast packet protocol."]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_FastPacketProtocol {
    pub _base: isobus_CANLibProtocol,
    #[doc = "< A list of all active TP sessions"]
    pub activeSessions: [u64; 3usize],
    #[doc = "< Used to keep track of sequence numbers for future sessions"]
    pub sessionHistory: [u64; 3usize],
    #[doc = "< A list of all parameter group number callbacks that will be parsed as fast packet messages"]
    pub parameterGroupNumberCallbacks: [u64; 3usize],
    #[doc = "< A mutex to lock the sessions list in case someone starts a Tx while the stack is processing sessions"]
    pub sessionMutex: std_mutex,
}
#[doc = " @brief An object for tracking fast packet session state"]
#[repr(C)]
#[derive(Debug)]
pub struct isobus_FastPacketProtocol_FastPacketProtocolSession {
    #[doc = "< A CAN message is used in the session to represent and store data like PGN"]
    pub sessionMessage: isobus_CANLibManagedMessage,
    #[doc = "< A callback that is to be called when the session is completed"]
    pub sessionCompleteCallback: isobus_TransmitCompleteCallback,
    #[doc = "< A callback that might be used to get chunks of data to send"]
    pub frameChunkCallback: isobus_DataChunkCallback,
    #[doc = "< A generic context variable that helps identify what object callbacks are destined for. Can be nullptr"]
    pub parent: *mut ::std::os::raw::c_void,
    #[doc = "< A timestamp used to track session timeouts"]
    pub timestamp_ms: u32,
    #[doc = "< The last processed sequence number for this set of packets"]
    pub lastPacketNumber: u16,
    #[doc = "< The total number of packets to receive or send in this session"]
    pub packetCount: u8,
    #[doc = "< The total processed packet count for the whole session so far"]
    pub processedPacketsThisSession: u8,
    #[doc = "< The sequence number for this PGN"]
    pub sequenceNumber: u8,
    #[doc = "< Represents Tx or Rx session"]
    pub sessionDirection: isobus_FastPacketProtocol_FastPacketProtocolSession_Direction,
}
#[doc = "< We are transmitting a message"]
pub const isobus_FastPacketProtocol_FastPacketProtocolSession_Direction_Transmit:
    isobus_FastPacketProtocol_FastPacketProtocolSession_Direction = 0;
#[doc = "< We are receving a message"]
pub const isobus_FastPacketProtocol_FastPacketProtocolSession_Direction_Receive:
    isobus_FastPacketProtocol_FastPacketProtocolSession_Direction = 1;
#[doc = " @brief Enumerates the possible session directions, Rx or Tx"]
pub type isobus_FastPacketProtocol_FastPacketProtocolSession_Direction = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_isobus_FastPacketProtocol_FastPacketProtocolSession() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_FastPacketProtocol_FastPacketProtocolSession> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_FastPacketProtocol_FastPacketProtocolSession>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_FastPacketProtocol_FastPacketProtocolSession>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionMessage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(sessionMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionCompleteCallback) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(sessionCompleteCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameChunkCallback) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(frameChunkCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_ms) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(timestamp_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastPacketNumber) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(lastPacketNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetCount) as usize - ptr as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(packetCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processedPacketsThisSession) as usize - ptr as usize },
        103usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(processedPacketsThisSession)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequenceNumber) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(sequenceNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionDirection) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketProtocolSession),
            "::",
            stringify!(sessionDirection)
        )
    );
}
#[doc = " @brief A structure for keeping track of past sessions so we can resume with the right session number"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isobus_FastPacketProtocol_FastPacketHistory {
    #[doc = "< The ISO name of the internal control function used in a session"]
    pub isoName: isobus_NAME,
    #[doc = "< The PGN of the session being saved"]
    pub parameterGroupNumber: u32,
    #[doc = "< The sequence number to use in the next matching session"]
    pub sequenceNumber: u8,
}
#[test]
fn bindgen_test_layout_isobus_FastPacketProtocol_FastPacketHistory() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_FastPacketProtocol_FastPacketHistory> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_FastPacketProtocol_FastPacketHistory>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(isobus_FastPacketProtocol_FastPacketHistory)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_FastPacketProtocol_FastPacketHistory>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(isobus_FastPacketProtocol_FastPacketHistory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isoName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketHistory),
            "::",
            stringify!(isoName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameterGroupNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketHistory),
            "::",
            stringify!(parameterGroupNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequenceNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol_FastPacketHistory),
            "::",
            stringify!(sequenceNumber)
        )
    );
}
extern "C" {
    #[doc = "< Static instance of the protocol"]
    #[link_name = "\u{1}_ZN6isobus18FastPacketProtocol8ProtocolE"]
    pub static mut isobus_FastPacketProtocol_Protocol: isobus_FastPacketProtocol;
}
#[doc = "< Start of PGNs that can be received via Fast Packet"]
pub const isobus_FastPacketProtocol_FP_MIN_PARAMETER_GROUP_NUMBER: u32 = 126976;
#[doc = "< End of PGNs that can be received via Fast Packet"]
pub const isobus_FastPacketProtocol_FP_MAX_PARAMETER_GROUP_NUMBER: u32 = 131071;
#[doc = "< Protocol timeout in milliseconds"]
pub const isobus_FastPacketProtocol_FP_TIMEOUT_MS: u32 = 750;
#[doc = "< Max message length based on there being 5 bits of sequence data"]
pub const isobus_FastPacketProtocol_MAX_PROTOCOL_MESSAGE_LENGTH: u8 = 223;
#[doc = "< Bit mask for masking out the frame counter"]
pub const isobus_FastPacketProtocol_FRAME_COUNTER_BIT_MASK: u8 = 31;
#[doc = "< Bit mask for masking out the sequence number bits"]
pub const isobus_FastPacketProtocol_SEQUENCE_NUMBER_BIT_MASK: u8 = 7;
#[doc = "< The bit offset into the first byte of data to get the seq number"]
pub const isobus_FastPacketProtocol_SEQUENCE_NUMBER_BIT_OFFSET: u8 = 5;
#[doc = "< The number of payload bytes per frame for all but the first message, which has 6"]
pub const isobus_FastPacketProtocol_PROTOCOL_BYTES_PER_FRAME: u8 = 7;
#[test]
fn bindgen_test_layout_isobus_FastPacketProtocol() {
    const UNINIT: ::std::mem::MaybeUninit<isobus_FastPacketProtocol> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isobus_FastPacketProtocol>(),
        96usize,
        concat!("Size of: ", stringify!(isobus_FastPacketProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<isobus_FastPacketProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(isobus_FastPacketProtocol))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activeSessions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol),
            "::",
            stringify!(activeSessions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionHistory) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol),
            "::",
            stringify!(sessionHistory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).parameterGroupNumberCallbacks) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol),
            "::",
            stringify!(parameterGroupNumberCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionMutex) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(isobus_FastPacketProtocol),
            "::",
            stringify!(sessionMutex)
        )
    );
}
extern "C" {
    #[doc = " @brief Similar to add_parameter_group_number_callback but tells the stack to parse those PGNs as Fast Packet\n @param[in] parameterGroupNumber The PGN to parse as fast packet\n @param[in] callback The callback that the stack will call when a matching message is received\n @param[in] parent Generic context variable"]
    #[link_name = "\u{1}_ZN6isobus18FastPacketProtocol37register_multipacket_message_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_FastPacketProtocol_register_multipacket_message_callback(
        this: *mut isobus_FastPacketProtocol,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @param[in] parameterGroupNumber The PGN to parse as fast packet\n @param[in] callback The callback that the stack will call when a matching message is received\n @param[in] parent Generic context variable"]
    #[link_name = "\u{1}_ZN6isobus18FastPacketProtocol35remove_multipacket_message_callbackEjPFvPNS_10CANMessageEPvES3_"]
    pub fn isobus_FastPacketProtocol_remove_multipacket_message_callback(
        this: *mut isobus_FastPacketProtocol,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Used to send CAN messages using fast packet\n @details You have to use this function instead of the network manager\n because otherwise the CAN stack has no way of knowing to send your message\n with FP instead of TP.\n @param[in] parameterGroupNumber The PGN of the message\n @param[in] data The data to be sent\n @param[in] messageLength The length of the data to be sent\n @param[in] source The source control function\n @param[in] destination The destination control function\n @param[in] priority The priority to encode in the IDs of the component CAN messages\n @param[in] txCompleteCallback A callback for when the protocol completes its work\n @param[in] parentPointer A generic context object for the tx complete and chunk callbacks\n @param[in] frameChunkCallback A callback to get some data to send\n @returns true if the message was accepted by the protocol for processing"]
    #[link_name = "\u{1}_ZN6isobus18FastPacketProtocol24send_multipacket_messageEjPKhhPNS_23InternalControlFunctionEPNS_15ControlFunctionENS_13CANIdentifier11CANPriorityEPFvjjS4_S6_bPvES9_PFbjjjPhS9_E"]
    pub fn isobus_FastPacketProtocol_send_multipacket_message(
        this: *mut isobus_FastPacketProtocol,
        parameterGroupNumber: u32,
        data: *const u8,
        messageLength: u8,
        source: *mut isobus_InternalControlFunction,
        destination: *mut isobus_ControlFunction,
        priority: isobus_CANIdentifier_CANPriority,
        txCompleteCallback: isobus_TransmitCompleteCallback,
        parentPointer: *mut ::std::os::raw::c_void,
        frameChunkCallback: isobus_DataChunkCallback,
    ) -> bool;
}
impl isobus_FastPacketProtocol {
    #[inline]
    pub unsafe fn register_multipacket_message_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_FastPacketProtocol_register_multipacket_message_callback(
            self,
            parameterGroupNumber,
            callback,
            parent,
        )
    }
    #[inline]
    pub unsafe fn remove_multipacket_message_callback(
        &mut self,
        parameterGroupNumber: u32,
        callback: isobus_CANLibCallback,
        parent: *mut ::std::os::raw::c_void,
    ) {
        isobus_FastPacketProtocol_remove_multipacket_message_callback(
            self,
            parameterGroupNumber,
            callback,
            parent,
        )
    }
    #[inline]
    pub unsafe fn send_multipacket_message(
        &mut self,
        parameterGroupNumber: u32,
        data: *const u8,
        messageLength: u8,
        source: *mut isobus_InternalControlFunction,
        destination: *mut isobus_ControlFunction,
        priority: isobus_CANIdentifier_CANPriority,
        txCompleteCallback: isobus_TransmitCompleteCallback,
        parentPointer: *mut ::std::os::raw::c_void,
        frameChunkCallback: isobus_DataChunkCallback,
    ) -> bool {
        isobus_FastPacketProtocol_send_multipacket_message(
            self,
            parameterGroupNumber,
            data,
            messageLength,
            source,
            destination,
            priority,
            txCompleteCallback,
            parentPointer,
            frameChunkCallback,
        )
    }
}
extern "C" {
    #[doc = " @brief A generic way to initialize a protocol\n @details The network manager will call a protocol's initialize function\n when it is first updated, if it has yet to be initialized."]
    #[link_name = "\u{1}_ZN6isobus18FastPacketProtocol10initializeENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_FastPacketProtocol_initialize(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
extern "C" {
    #[doc = " @brief This will be called by the network manager on every cyclic update of the stack"]
    #[link_name = "\u{1}_ZN6isobus18FastPacketProtocol6updateENS_11CANLibBadgeINS_17CANNetworkManagerEEE"]
    pub fn isobus_FastPacketProtocol_update(
        this: *mut ::std::os::raw::c_void,
        arg1: isobus_CANLibBadge,
    );
}
pub type clock_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        36usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
}
extern "C" {
    pub static mut _daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _dstbias: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut _timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut _tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_Daylight_savings_bias: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_Timezone: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Index: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buf: *mut ::std::os::raw::c_char,
        _SizeInWords: usize,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buf: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn strftime(
        _Buf: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _strftime_l(
        _Buf: *mut ::std::os::raw::c_char,
        _Max_size: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strdate_s(_Buf: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buf: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buf: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _setsystime(_Tm: *mut tm, _MilliSec: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut u16;
}
extern "C" {
    pub fn _wasctime_s(_Buf: *mut u16, _SizeInWords: usize, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut u16;
}
extern "C" {
    pub fn _wctime32_s(_Buf: *mut u16, _SizeInWords: usize, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buf: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buf: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wstrdate_s(_Buf: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wstrtime_s(_Buf: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut u16;
}
extern "C" {
    pub fn _wctime64_s(_Buf: *mut u16, _SizeInWords: usize, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _wctime(arg1: *const time_t) -> *mut u16;
}
extern "C" {
    pub fn _wctime_s(arg1: *mut u16, arg2: usize, arg3: *const time_t) -> errno_t;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        8usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn mingw_gettimeofday(p: *mut timeval, z: *mut timezone) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timeb32 {
    pub time: __time32_t,
    pub millitm: ::std::os::raw::c_ushort,
    pub timezone: ::std::os::raw::c_short,
    pub dstflag: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout___timeb32() {
    const UNINIT: ::std::mem::MaybeUninit<__timeb32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__timeb32>(),
        12usize,
        concat!("Size of: ", stringify!(__timeb32))
    );
    assert_eq!(
        ::std::mem::align_of::<__timeb32>(),
        4usize,
        concat!("Alignment of ", stringify!(__timeb32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__timeb32),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).millitm) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__timeb32),
            "::",
            stringify!(millitm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timezone) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(__timeb32),
            "::",
            stringify!(timezone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstflag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__timeb32),
            "::",
            stringify!(dstflag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeb {
    pub time: time_t,
    pub millitm: ::std::os::raw::c_ushort,
    pub timezone: ::std::os::raw::c_short,
    pub dstflag: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_timeb() {
    const UNINIT: ::std::mem::MaybeUninit<timeb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeb>(),
        16usize,
        concat!("Size of: ", stringify!(timeb))
    );
    assert_eq!(
        ::std::mem::align_of::<timeb>(),
        8usize,
        concat!("Alignment of ", stringify!(timeb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeb),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).millitm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeb),
            "::",
            stringify!(millitm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timezone) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(timeb),
            "::",
            stringify!(timezone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstflag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(timeb),
            "::",
            stringify!(dstflag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timeb64 {
    pub time: __time64_t,
    pub millitm: ::std::os::raw::c_ushort,
    pub timezone: ::std::os::raw::c_short,
    pub dstflag: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout___timeb64() {
    const UNINIT: ::std::mem::MaybeUninit<__timeb64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__timeb64>(),
        16usize,
        concat!("Size of: ", stringify!(__timeb64))
    );
    assert_eq!(
        ::std::mem::align_of::<__timeb64>(),
        8usize,
        concat!("Alignment of ", stringify!(__timeb64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__timeb64),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).millitm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__timeb64),
            "::",
            stringify!(millitm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timezone) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__timeb64),
            "::",
            stringify!(timezone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstflag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__timeb64),
            "::",
            stringify!(dstflag)
        )
    );
}
extern "C" {
    pub fn _ftime64(_Time: *mut __timeb64);
}
extern "C" {
    pub fn _ftime32(_Time: *mut __timeb32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn ftime(arg1: *mut timeb);
}
extern "C" {
    pub fn _ftime32_s(_Time: *mut __timeb32) -> errno_t;
}
extern "C" {
    pub fn _ftime64_s(_Time: *mut __timeb64) -> errno_t;
}
pub type clockid_t = ::std::os::raw::c_int;
extern "C" {
    pub fn nanosleep(request: *const timespec, remain: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        clock_id: clockid_t,
        flags: ::std::os::raw::c_int,
        request: *const timespec,
        remain: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___cxa_refcounted_exception {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}__cxa_allocate_exception"]
    pub fn __cxxabiv1___cxa_allocate_exception(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}__cxa_free_exception"]
    pub fn __cxxabiv1___cxa_free_exception(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__cxa_init_primary_exception"]
    pub fn __cxxabiv1___cxa_init_primary_exception(
        object: *mut ::std::os::raw::c_void,
        tinfo: *mut std_type_info,
        dest: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> *mut __cxxabiv1___cxa_refcounted_exception;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___class_type_info {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct __cxxabiv1___forced_unwind__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct __cxxabiv1___forced_unwind {
    pub vtable_: *const __cxxabiv1___forced_unwind__bindgen_vtable,
}
#[test]
fn bindgen_test_layout___cxxabiv1___forced_unwind() {
    assert_eq!(
        ::std::mem::size_of::<__cxxabiv1___forced_unwind>(),
        8usize,
        concat!("Size of: ", stringify!(__cxxabiv1___forced_unwind))
    );
    assert_eq!(
        ::std::mem::align_of::<__cxxabiv1___forced_unwind>(),
        8usize,
        concat!("Alignment of ", stringify!(__cxxabiv1___forced_unwind))
    );
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _itow_s(
        _Val: ::std::os::raw::c_int,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow_s(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow_s(
        _Val: ::std::os::raw::c_ulong,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _ReturnSize: *mut usize,
        _DstBuf: *mut u16,
        _DstSizeInWords: usize,
        _VarName: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut u16,
        _BufferSizeInWords: *mut usize,
        _VarName: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow_s(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _PathResult: *mut u16,
        _SizeInWords: usize,
        _Drive: *const u16,
        _Dir: *const u16,
        _Filename: *const u16,
        _Ext: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const u16, _Value: *const u16) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const u16,
        _EnvVar: *const u16,
        _ResultPath: *mut u16,
        _SizeInWords: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const u16,
        _Drive: *mut u16,
        _DriveSizeInWords: usize,
        _Dir: *mut u16,
        _DirSizeInWords: usize,
        _Filename: *mut u16,
        _FilenameSizeInWords: usize,
        _Ext: *mut u16,
        _ExtSizeInWords: usize,
    ) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _ptr: *mut ::std::os::raw::c_char,
    pub _cnt: ::std::os::raw::c_int,
    pub _base: *mut ::std::os::raw::c_char,
    pub _flag: ::std::os::raw::c_int,
    pub _file: ::std::os::raw::c_int,
    pub _charbuf: ::std::os::raw::c_int,
    pub _bufsiz: ::std::os::raw::c_int,
    pub _tmpfname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__iobuf() {
    const UNINIT: ::std::mem::MaybeUninit<_iobuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        48usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._charbuf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_charbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bufsiz) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_bufsiz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._tmpfname) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_tmpfname)
        )
    );
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(index: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn __iob_func() -> *mut FILE;
}
pub type _fsize_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: _fsize_t,
    pub name: [u16; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata32_t() {
    const UNINIT: ::std::mem::MaybeUninit<_wfinddata32_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_wfinddata32_t>(),
        540usize,
        concat!("Size of: ", stringify!(_wfinddata32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wfinddata32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_wfinddata32_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32_t),
            "::",
            stringify!(attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_create) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32_t),
            "::",
            stringify!(time_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_access) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32_t),
            "::",
            stringify!(time_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_write) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32_t),
            "::",
            stringify!(time_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32_t),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata32i64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [u16; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata32i64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_wfinddata32i64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_wfinddata32i64_t>(),
        544usize,
        concat!("Size of: ", stringify!(_wfinddata32i64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wfinddata32i64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wfinddata32i64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32i64_t),
            "::",
            stringify!(attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_create) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32i64_t),
            "::",
            stringify!(time_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_access) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32i64_t),
            "::",
            stringify!(time_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_write) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32i64_t),
            "::",
            stringify!(time_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32i64_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata32i64_t),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata64i32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: _fsize_t,
    pub name: [u16; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata64i32_t() {
    const UNINIT: ::std::mem::MaybeUninit<_wfinddata64i32_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_wfinddata64i32_t>(),
        560usize,
        concat!("Size of: ", stringify!(_wfinddata64i32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wfinddata64i32_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wfinddata64i32_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64i32_t),
            "::",
            stringify!(attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_create) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64i32_t),
            "::",
            stringify!(time_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_access) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64i32_t),
            "::",
            stringify!(time_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64i32_t),
            "::",
            stringify!(time_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64i32_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64i32_t),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [u16; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_wfinddata64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_wfinddata64_t>(),
        560usize,
        concat!("Size of: ", stringify!(_wfinddata64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wfinddata64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wfinddata64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64_t),
            "::",
            stringify!(attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_create) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64_t),
            "::",
            stringify!(time_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_access) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64_t),
            "::",
            stringify!(time_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64_t),
            "::",
            stringify!(time_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_wfinddata64_t),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    pub static mut __imp__pctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut __imp__wctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut __imp__pwctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn iswalpha(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalnum(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswascii(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isleadbyte_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wgetcwd(_DstBuf: *mut u16, _SizeInWords: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wgetdcwd(
        _Drive: ::std::os::raw::c_int,
        _DstBuf: *mut u16,
        _SizeInWords: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _wchdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wmkdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wrmdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _waccess(
        _Filename: *const u16,
        _AccessMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wchmod(_Filename: *const u16, _Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcreat(
        _Filename: *const u16,
        _PermissionMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindfirst32(_Filename: *const u16, _FindData: *mut _wfinddata32_t) -> isize;
}
extern "C" {
    pub fn _wfindnext32(
        _FindHandle: isize,
        _FindData: *mut _wfinddata32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wunlink(_Filename: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wrename(_OldFilename: *const u16, _NewFilename: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wmktemp(_TemplateName: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wfindfirst32i64(_Filename: *const u16, _FindData: *mut _wfinddata32i64_t) -> isize;
}
extern "C" {
    pub fn _wfindfirst64i32(_Filename: *const u16, _FindData: *mut _wfinddata64i32_t) -> isize;
}
extern "C" {
    pub fn _wfindfirst64(_Filename: *const u16, _FindData: *mut _wfinddata64_t) -> isize;
}
extern "C" {
    pub fn _wfindnext32i64(
        _FindHandle: isize,
        _FindData: *mut _wfinddata32i64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindnext64i32(
        _FindHandle: isize,
        _FindData: *mut _wfinddata64i32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindnext64(
        _FindHandle: isize,
        _FindData: *mut _wfinddata64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsopen_s(
        _FileHandle: *mut ::std::os::raw::c_int,
        _Filename: *const u16,
        _OpenFlag: ::std::os::raw::c_int,
        _ShareFlag: ::std::os::raw::c_int,
        _PermissionFlag: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wopen(
        _Filename: *const u16,
        _OpenFlag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsopen(
        _Filename: *const u16,
        _OpenFlag: ::std::os::raw::c_int,
        _ShareFlag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsetlocale(_Category: ::std::os::raw::c_int, _Locale: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wexecl(_Filename: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexecle(_Filename: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexeclp(_Filename: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexeclpe(_Filename: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexecv(_Filename: *const u16, _ArgList: *const *const u16) -> isize;
}
extern "C" {
    pub fn _wexecve(
        _Filename: *const u16,
        _ArgList: *const *const u16,
        _Env: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wexecvp(_Filename: *const u16, _ArgList: *const *const u16) -> isize;
}
extern "C" {
    pub fn _wexecvpe(
        _Filename: *const u16,
        _ArgList: *const *const u16,
        _Env: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnl(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const u16,
        _ArgList: *const u16,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnle(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const u16,
        _ArgList: *const u16,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnlp(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const u16,
        _ArgList: *const u16,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnlpe(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const u16,
        _ArgList: *const u16,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnv(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const u16,
        _ArgList: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnve(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const u16,
        _ArgList: *const *const u16,
        _Env: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnvp(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const u16,
        _ArgList: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnvpe(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const u16,
        _ArgList: *const *const u16,
        _Env: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wsystem(_Command: *const u16) -> ::std::os::raw::c_int;
}
pub type _ino_t = ::std::os::raw::c_ushort;
pub type ino_t = ::std::os::raw::c_ushort;
pub type _dev_t = ::std::os::raw::c_uint;
pub type dev_t = ::std::os::raw::c_uint;
pub type _off_t = ::std::os::raw::c_long;
pub type off32_t = ::std::os::raw::c_long;
pub type _off64_t = ::std::os::raw::c_longlong;
pub type off64_t = ::std::os::raw::c_longlong;
pub type off_t = off32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _stat32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[test]
fn bindgen_test_layout__stat32() {
    const UNINIT: ::std::mem::MaybeUninit<_stat32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_stat32>(),
        36usize,
        concat!("Size of: ", stringify!(_stat32))
    );
    assert_eq!(
        ::std::mem::align_of::<_stat32>(),
        4usize,
        concat!("Alignment of ", stringify!(_stat32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32),
            "::",
            stringify!(st_ctime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: time_t,
    pub st_mtime: time_t,
    pub st_ctime: time_t,
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        48usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _stat32i64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[test]
fn bindgen_test_layout__stat32i64() {
    const UNINIT: ::std::mem::MaybeUninit<_stat32i64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_stat32i64>(),
        48usize,
        concat!("Size of: ", stringify!(_stat32i64))
    );
    assert_eq!(
        ::std::mem::align_of::<_stat32i64>(),
        8usize,
        concat!("Alignment of ", stringify!(_stat32i64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat32i64),
            "::",
            stringify!(st_ctime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _stat64i32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[test]
fn bindgen_test_layout__stat64i32() {
    const UNINIT: ::std::mem::MaybeUninit<_stat64i32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_stat64i32>(),
        48usize,
        concat!("Size of: ", stringify!(_stat64i32))
    );
    assert_eq!(
        ::std::mem::align_of::<_stat64i32>(),
        8usize,
        concat!("Alignment of ", stringify!(_stat64i32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64i32),
            "::",
            stringify!(st_ctime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _stat64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[test]
fn bindgen_test_layout__stat64() {
    const UNINIT: ::std::mem::MaybeUninit<_stat64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_stat64>(),
        56usize,
        concat!("Size of: ", stringify!(_stat64))
    );
    assert_eq!(
        ::std::mem::align_of::<_stat64>(),
        8usize,
        concat!("Alignment of ", stringify!(_stat64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_stat64),
            "::",
            stringify!(st_ctime)
        )
    );
}
extern "C" {
    pub fn _wstat32(_Name: *const u16, _Stat: *mut _stat32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat32i64(_Name: *const u16, _Stat: *mut _stat32i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat64i32(_Name: *const u16, _Stat: *mut _stat64i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat64(_Name: *const u16, _Stat: *mut _stat64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cgetws(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _getwch() -> wint_t;
}
extern "C" {
    pub fn _getwche() -> wint_t;
}
extern "C" {
    pub fn _putwch(_WCh: u16) -> wint_t;
}
extern "C" {
    pub fn _ungetwch(_WCh: wint_t) -> wint_t;
}
extern "C" {
    pub fn _cputws(_String: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwscanf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwscanf_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf_p(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf_p(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf_p_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf_p_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_swscanf(_Src: *const u16, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vswscanf(
        _Str: *const u16,
        Format: *const u16,
        argp: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_wscanf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vwscanf(Format: *const u16, argp: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_fwscanf(_File: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vfwscanf(
        fp: *mut FILE,
        Format: *const u16,
        argp: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_fwprintf(_File: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_wprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vfwprintf(
        _File: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vwprintf(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_snwprintf(
        s: *mut u16,
        n: usize,
        format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vsnwprintf(
        arg1: *mut u16,
        arg2: usize,
        arg3: *const u16,
        arg4: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_swprintf(arg1: *mut u16, arg2: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vswprintf(
        arg1: *mut u16,
        arg2: *const u16,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_swscanf(_Src: *const u16, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_wscanf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_fwscanf(_File: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_fwprintf(_File: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_wprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_vfwprintf(
        _File: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_vwprintf(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_swprintf(arg1: *mut u16, arg2: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_vswprintf(arg1: *mut u16, arg2: *const u16, arg3: va_list)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfsopen(
        _Filename: *const u16,
        _Mode: *const u16,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Ch: u16, _File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Ch: u16) -> wint_t;
}
extern "C" {
    pub fn getwc(_File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn putwc(_Ch: u16, _File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Ch: u16) -> wint_t;
}
extern "C" {
    pub fn ungetwc(_Ch: wint_t, _File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Dst: *mut u16,
        _SizeInWords: ::std::os::raw::c_int,
        _File: *mut FILE,
    ) -> *mut u16;
}
extern "C" {
    pub fn fputws(_Str: *const u16, _File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _putws(_Str: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_l(
        arg1: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_c(
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_c(
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf(
        _Dest: *mut u16,
        _Count: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf(
        _Dest: *mut u16,
        _Count: usize,
        _Format: *const u16,
        _Args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_p(_File: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_p(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_p(
        _File: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_p(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_p(
        _DstBuf: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_p(
        _DstBuf: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_p(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_p(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_p_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_p_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_l(
        _File: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_p_l(
        _File: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_l(
        _File: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_p_l(
        _File: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_c_l(
        _DstBuf: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_p_l(
        _DstBuf: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_c_l(
        _DstBuf: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_p_l(
        _DstBuf: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_p_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_p_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf_l(
        _DstBuf: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf_l(
        _DstBuf: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf(_Dest: *mut u16, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf(
        _Dest: *mut u16,
        _Format: *const u16,
        _Args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swprintf_l(
        _Dest: *mut u16,
        _Format: *const u16,
        _Plocinfo: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_l(
        _Dest: *mut u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vswprintf_l(
        _Dest: *mut u16,
        _Format: *const u16,
        _Plocinfo: _locale_t,
        _Args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const u16, _FilePrefix: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _vscwprintf(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwscanf_l(
        _File: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swscanf_l(
        _Src: *const u16,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf(
        _Src: *const u16,
        _MaxCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf_l(
        _Src: *const u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wscanf_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_Filename: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen(_Filename: *const u16, _Mode: *const u16, _OldFile: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrMsg: *const u16);
}
extern "C" {
    pub fn _wpopen(_Command: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_Filename: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Dest: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Dest: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Dest: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _wcstod_l(_Str: *const u16, _EndPtr: *mut *mut u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn __mingw_wcstod(_Str: *const u16, _EndPtr: *mut *mut u16) -> f64;
}
extern "C" {
    pub fn __mingw_wcstof(nptr: *const u16, endptr: *mut *mut u16) -> f32;
}
extern "C" {
    pub fn __mingw_wcstold(arg1: *const u16, arg2: *mut *mut u16) -> u128;
}
extern "C" {
    pub fn wcstold(arg1: *const u16, arg2: *mut *mut u16) -> u128;
}
extern "C" {
    pub fn wcstol(
        _Str: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _Str: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        _Str: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _Str: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wtof(_Str: *const u16) -> f64;
}
extern "C" {
    pub fn _wtof_l(_Str: *const u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_Str: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_Str: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_Str: *const u16) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_Str: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _i64tow(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ui64tow(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _wtoi64(_Str: *const u16) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_Str: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _Str: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _Str: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _Str: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _Str: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(_FullPath: *mut u16, _Path: *const u16, _SizeInWords: usize) -> *mut u16;
}
extern "C" {
    pub fn _wmakepath(
        _ResultPath: *mut u16,
        _Drive: *const u16,
        _Dir: *const u16,
        _Filename: *const u16,
        _Ext: *const u16,
    );
}
extern "C" {
    pub fn _wputenv(_EnvString: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsearchenv(_Filename: *const u16, _EnvVar: *const u16, _ResultPath: *mut u16);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const u16,
        _Drive: *mut u16,
        _Dir: *mut u16,
        _Filename: *mut u16,
        _Ext: *mut u16,
    );
}
extern "C" {
    pub fn _wcsdup(_Str: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscat(_Dest: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcschr(_Str: *const u16, _Ch: u16) -> *mut u16;
}
extern "C" {
    pub fn wcscmp(_Str1: *const u16, _Str2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Dest: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscspn(_Str: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcslen(_Str: *const u16) -> usize;
}
extern "C" {
    pub fn wcsnlen(_Src: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(_Dest: *mut u16, _Source: *const u16, _Count: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsncmp(_Str1: *const u16, _Str2: *const u16, _MaxCount: usize)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(_Dest: *mut u16, _Source: *const u16, _Count: usize) -> *mut u16;
}
extern "C" {
    pub fn _wcsncpy_l(
        _Dest: *mut u16,
        _Source: *const u16,
        _Count: usize,
        _Locale: _locale_t,
    ) -> *mut u16;
}
extern "C" {
    pub fn wcspbrk(_Str: *const u16, _Control: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcsrchr(_Str: *const u16, _Ch: u16) -> *mut u16;
}
extern "C" {
    pub fn wcsspn(_Str: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcsstr(_Str: *const u16, _SubStr: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcstok(_Str: *mut u16, _Delim: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wcserror(_ErrNum: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn __wcserror(_Str: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsicmp(_Str1: *const u16, _Str2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _Str1: *const u16,
        _Str2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _Str1: *const u16,
        _Str2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _Str1: *const u16,
        _Str2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset(_Str: *mut u16, _Val: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn _wcsrev(_Str: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsset(_Str: *mut u16, _Val: u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn wcsxfrm(_Dst: *mut u16, _Src: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Dst: *mut u16,
        _Src: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_Str1: *const u16, _Str2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _Str1: *const u16,
        _Str2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_Str1: *const u16, _Str2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _Str1: *const u16,
        _Str2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _Str1: *const u16,
        _Str2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _Str1: *const u16,
        _Str2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _Str1: *const u16,
        _Str2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _Str1: *const u16,
        _Str2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_Str: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicmp(_Str1: *const u16, _Str2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _Str1: *const u16,
        _Str2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_Str: *mut u16, _Val: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsrev(_Str: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsset(_Str: *mut u16, _Val: u16) -> *mut u16;
}
extern "C" {
    pub fn wcslwr(_Str: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsupr(_Str: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicoll(_Str1: *const u16, _Str2: *const u16) -> ::std::os::raw::c_int;
}
pub type mbstate_t = ::std::os::raw::c_int;
pub type _Wint_t = u16;
extern "C" {
    pub fn btowc(arg1: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn mbrlen(
        _Ch: *const ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbrtowc(
        _DstCh: *mut u16,
        _SrcCh: *const ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(
        _Dest: *mut u16,
        _PSrc: *mut *const ::std::os::raw::c_char,
        _Count: usize,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: u16,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsrtombs(
        _Dest: *mut ::std::os::raw::c_char,
        _PSource: *mut *const u16,
        _Count: usize,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wctob(_WCh: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemset(s: *mut u16, c: u16, n: usize) -> *mut u16;
}
extern "C" {
    pub fn wmemchr(s: *const u16, c: u16, n: usize) -> *mut u16;
}
extern "C" {
    pub fn wmemcmp(s1: *const u16, s2: *const u16, n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(s1: *mut u16, s2: *const u16, n: usize) -> *mut u16;
}
extern "C" {
    pub fn wmempcpy(_Dst: *mut u16, _Src: *const u16, _Size: usize) -> *mut u16;
}
extern "C" {
    pub fn wmemmove(s1: *mut u16, s2: *const u16, n: usize) -> *mut u16;
}
extern "C" {
    pub fn fwide(stream: *mut FILE, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstoll(
        nptr: *const u16,
        endptr: *mut *mut u16,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        nptr: *const u16,
        endptr: *mut *mut u16,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_str_wide_utf8(
        wptr: *const u16,
        mbptr: *mut *mut ::std::os::raw::c_char,
        buflen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_str_utf8_wide(
        mbptr: *const ::std::os::raw::c_char,
        wptr: *mut *mut u16,
        buflen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_str_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _waccess_s(_Filename: *const u16, _AccessMode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _wmktemp_s(_TemplateName: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _cgetws_s(_Buffer: *mut u16, _SizeInWords: usize, _SizeRead: *mut usize) -> errno_t;
}
extern "C" {
    pub fn _cwprintf_s(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwscanf_s(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwscanf_s_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf_s(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf_s_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf_s_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Str: *mut u16, _SizeInWords: usize) -> *mut u16;
}
extern "C" {
    pub fn fwprintf_s(_File: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf_s(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf_s(
        _File: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf_s(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf_s(
        _Dst: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf_s(
        _Dst: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf_s(
        _DstBuf: *mut u16,
        _DstSizeInWords: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf_s(
        _DstBuf: *mut u16,
        _DstSizeInWords: usize,
        _MaxCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_s_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_s_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_s_l(
        _File: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_s_l(
        _File: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_s_l(
        _DstBuf: *mut u16,
        _DstSize: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_s_l(
        _DstBuf: *mut u16,
        _DstSize: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf_s_l(
        _DstBuf: *mut u16,
        _DstSize: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf_s_l(
        _DstBuf: *mut u16,
        _DstSize: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwscanf_s_l(
        _File: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf_s(_File: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swscanf_s_l(
        _Src: *const u16,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf_s(_Src: *const u16, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf_s(
        _Src: *const u16,
        _MaxCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf_s_l(
        _Src: *const u16,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wscanf_s_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf_s(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfopen_s(_File: *mut *mut FILE, _Filename: *const u16, _Mode: *const u16) -> errno_t;
}
extern "C" {
    pub fn _wfreopen_s(
        _File: *mut *mut FILE,
        _Filename: *const u16,
        _Mode: *const u16,
        _OldFile: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam_s(_DstBuf: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(_Str: *mut u16, _Delim: *const u16, _Context: *mut *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcserror_s(
        _Buf: *mut u16,
        _SizeInWords: usize,
        _ErrNum: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror_s(_Buffer: *mut u16, _SizeInWords: usize, _ErrMsg: *const u16) -> errno_t;
}
extern "C" {
    pub fn _wcsnset_s(
        _Dst: *mut u16,
        _DstSizeInWords: usize,
        _Val: u16,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsset_s(_Str: *mut u16, _SizeInWords: usize, _Val: u16) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_s(_Str: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_Str: *mut u16, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_s(_Str: *mut u16, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_Str: *mut u16, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn wcscat_s(_Dst: *mut u16, _DstSize: rsize_t, _Src: *const u16) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(_Dst: *mut u16, _DstSize: rsize_t, _Src: *const u16) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Dst: *mut u16,
        _DstSizeInChars: usize,
        _Src: *const u16,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsncat_s_l(
        _Dst: *mut u16,
        _DstSizeInChars: usize,
        _Src: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Dst: *mut u16,
        _DstSizeInChars: usize,
        _Src: *const u16,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsncpy_s_l(
        _Dst: *mut u16,
        _DstSizeInChars: usize,
        _Src: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstok_s_l(
        _Str: *mut u16,
        _Delim: *const u16,
        _Context: *mut *mut u16,
        _Locale: _locale_t,
    ) -> *mut u16;
}
extern "C" {
    pub fn _wcsset_s_l(
        _Str: *mut u16,
        _SizeInChars: usize,
        _Val: ::std::os::raw::c_uint,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset_s_l(
        _Str: *mut u16,
        _SizeInChars: usize,
        _Val: ::std::os::raw::c_uint,
        _Count: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn mbsrtowcs_s(
        _Retval: *mut usize,
        _Dst: *mut u16,
        _SizeInWords: usize,
        _PSrc: *mut *const ::std::os::raw::c_char,
        _N: usize,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcrtomb_s(
        _Retval: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Ch: u16,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsrtombs_s(
        _Retval: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Src: *mut *const u16,
        _Size: usize,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wmemcpy_s(
        _dest: *mut u16,
        _numberOfElements: usize,
        _src: *const u16,
        _count: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wmemmove_s(
        _dest: *mut u16,
        _numberOfElements: usize,
        _src: *const u16,
        _count: usize,
    ) -> errno_t;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn __mingw_sscanf(
        _Src: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vsscanf(
        _Str: *const ::std::os::raw::c_char,
        Format: *const ::std::os::raw::c_char,
        argp: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_scanf(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vscanf(
        Format: *const ::std::os::raw::c_char,
        argp: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_fscanf(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vfscanf(
        fp: *mut FILE,
        Format: *const ::std::os::raw::c_char,
        argp: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vsnprintf(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_snprintf(
        s: *mut ::std::os::raw::c_char,
        n: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_sscanf(
        _Src: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_scanf(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_fscanf(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ms_vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _filbuf(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flsbuf(_Ch: ::std::os::raw::c_int, _File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fsopen(
        _Filename: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn clearerr(_File: *mut FILE);
}
extern "C" {
    pub fn fclose(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_File: *mut FILE, _Pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos64(_File: *mut FILE, _Pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buf: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _File: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _Filename: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Ch: ::std::os::raw::c_int, _File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(_Str: *const ::std::os::raw::c_char, _File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _DstBuf: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _Count: usize,
        _File: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        _Filename: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _File: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_File: *mut FILE, _Pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(_File: *mut FILE, _Pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _File: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_File: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _fseeki64(
        _File: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftelli64(_File: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fseeko64(
        stream: *mut FILE,
        offset: _off64_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        stream: *mut FILE,
        offset: _off_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(stream: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn ftello64(stream: *mut FILE) -> _off64_t;
}
extern "C" {
    pub fn fwrite(
        _Str: *const ::std::os::raw::c_void,
        _Size: usize,
        _Count: usize,
        _File: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _getw(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Ch: ::std::os::raw::c_int, _File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_Filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFilename: *const ::std::os::raw::c_char,
        _NewFilename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_Filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_Filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_File: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_File: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Max: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_output_format(_Format: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _get_output_format() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setvbuf(
        _File: *mut FILE,
        _Buf: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf(
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Ch: ::std::os::raw::c_int, _File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf(
        _Dest: *mut ::std::os::raw::c_char,
        _Count: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf(
        _Dest: *mut ::std::os::raw::c_char,
        _Count: usize,
        _Format: *const ::std::os::raw::c_char,
        _Args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_File: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_File: *mut FILE);
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _spawnv(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _spawnve(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *const ::std::os::raw::c_char,
        _Env: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _spawnvp(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _spawnvpe(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *const ::std::os::raw::c_char,
        _Env: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_s(_File: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _DstBuf: *mut ::std::os::raw::c_void,
        _DstSize: usize,
        _ElementSize: usize,
        _Count: usize,
        _File: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fprintf_s(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fscanf_s_l(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf_s(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf_s(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scanf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scanf_s_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf_s(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_c(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_c(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fscanf_l(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sscanf_l(
        _Src: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sscanf_s_l(
        _Src: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf_s(
        _Src: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf_s(
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf_l(
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf_s_l(
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf_s(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf_s(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fprintf_p(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printf_p(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_p(
        _Dst: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_p(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_p(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_p(
        _Dst: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf_p(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf_p(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printf_p_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_p_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fprintf_l(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fprintf_p_l(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_l(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_p_l(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_p_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        arg1: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_p_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf_p_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf_p_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printf_s_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_s_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fprintf_s_l(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_s_l(
        _File: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_s_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_s_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_s_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_s_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_c_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_c_l(
        _DstBuf: *mut ::std::os::raw::c_char,
        _MaxCount: usize,
        arg1: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen_s(
        _File: *mut *mut FILE,
        _Filename: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn freopen_s(
        _File: *mut *mut FILE,
        _Filename: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(arg1: *mut ::std::os::raw::c_char, arg2: rsize_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_s(arg1: *mut ::std::os::raw::c_char, arg2: rsize_t) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub _W_decimal_point: *mut u16,
    pub _W_thousands_sep: *mut u16,
    pub _W_int_curr_symbol: *mut u16,
    pub _W_currency_symbol: *mut u16,
    pub _W_mon_decimal_point: *mut u16,
    pub _W_mon_thousands_sep: *mut u16,
    pub _W_positive_sign: *mut u16,
    pub _W_negative_sign: *mut u16,
}
#[test]
fn bindgen_test_layout_lconv() {
    const UNINIT: ::std::mem::MaybeUninit<lconv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        152usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thousands_sep) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grouping) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_curr_symbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currency_symbol) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_decimal_point) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_thousands_sep) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_grouping) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positive_sign) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negative_sign) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_frac_digits) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frac_digits) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_cs_precedes) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_sep_by_space) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_cs_precedes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sep_by_space) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_sign_posn) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sign_posn) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._W_decimal_point) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(_W_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._W_thousands_sep) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(_W_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._W_int_curr_symbol) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(_W_int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._W_currency_symbol) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(_W_currency_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._W_mon_decimal_point) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(_W_mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._W_mon_thousands_sep) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(_W_mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._W_positive_sign) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(_W_positive_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._W_negative_sign) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(_W_negative_sign)
        )
    );
}
extern "C" {
    pub fn _configthreadlocale(_Flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlocale(
        _Category: ::std::os::raw::c_int,
        _Locale: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn _get_current_locale() -> _locale_t;
}
extern "C" {
    pub fn _create_locale(
        _Category: ::std::os::raw::c_int,
        _Locale: *const ::std::os::raw::c_char,
    ) -> _locale_t;
}
extern "C" {
    pub fn _free_locale(_Locale: _locale_t);
}
extern "C" {
    pub fn __get_current_locale() -> _locale_t;
}
extern "C" {
    pub fn __create_locale(
        _Category: ::std::os::raw::c_int,
        _Locale: *const ::std::os::raw::c_char,
    ) -> _locale_t;
}
extern "C" {
    pub fn __free_locale(_Locale: _locale_t);
}
extern "C" {
    pub fn ___lc_codepage_func() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub static __newclmap: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    pub static __newcumap: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    pub static mut __ptlocinfo: pthreadlocinfo;
}
extern "C" {
    pub static mut __ptmbcinfo: pthreadmbcinfo;
}
extern "C" {
    pub static mut __globallocalestatus: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __locale_changed: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __initiallocinfo: threadlocaleinfostruct;
}
extern "C" {
    pub static mut __initiallocalestructinfo: _locale_tstruct;
}
extern "C" {
    pub fn __updatetlocinfo() -> pthreadlocinfo;
}
extern "C" {
    pub fn __updatetmbcinfo() -> pthreadmbcinfo;
}
extern "C" {
    pub fn _isctype(
        _C: ::std::os::raw::c_int,
        _Type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isctype_l(
        _C: ::std::os::raw::c_int,
        _Type: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalpha_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _islower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isxdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isspace_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ispunct_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalnum_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isprint_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isgraph_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iscntrl_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsymf(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsym(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __imp___mb_cur_max: *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
pub type _pid_t = ::std::os::raw::c_longlong;
pub type pid_t = _pid_t;
pub type _mode_t = ::std::os::raw::c_ushort;
pub type mode_t = _mode_t;
pub type useconds_t = ::std::os::raw::c_uint;
pub type _sigset_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn __p__acmdln() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wcmdln() -> *mut *mut u16;
}
pub type _PVFV = ::std::option::Option<unsafe extern "C" fn()>;
pub type _PIFV = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type _PVFI = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _onexit_table_t {
    pub _first: *mut _PVFV,
    pub _last: *mut _PVFV,
    pub _end: *mut _PVFV,
}
#[test]
fn bindgen_test_layout__onexit_table_t() {
    const UNINIT: ::std::mem::MaybeUninit<_onexit_table_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_onexit_table_t>(),
        24usize,
        concat!("Size of: ", stringify!(_onexit_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_onexit_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_onexit_table_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_onexit_table_t),
            "::",
            stringify!(_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_onexit_table_t),
            "::",
            stringify!(_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_onexit_table_t),
            "::",
            stringify!(_end)
        )
    );
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn _initialize_onexit_table(arg1: *mut _onexit_table_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _register_onexit_function(
        arg1: *mut _onexit_table_t,
        arg2: _onexit_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _execute_onexit_table(arg1: *mut _onexit_table_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _crt_atexit(func: _PVFV) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _crt_at_quick_exit(func: _PVFV) -> ::std::os::raw::c_int;
}
pub type _beginthread_proc_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type _beginthreadex_proc_type = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
extern "C" {
    pub fn _beginthread(
        _StartAddress: _beginthread_proc_type,
        _StackSize: ::std::os::raw::c_uint,
        _ArgList: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    pub fn _endthread() -> !;
}
extern "C" {
    pub fn _beginthreadex(
        _Security: *mut ::std::os::raw::c_void,
        _StackSize: ::std::os::raw::c_uint,
        _StartAddress: _beginthreadex_proc_type,
        _ArgList: *mut ::std::os::raw::c_void,
        _InitFlag: ::std::os::raw::c_uint,
        _ThrdAddr: *mut ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn _endthreadex(_Retval: ::std::os::raw::c_uint) -> !;
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
pub type _tls_callback_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn _register_thread_local_exe_atexit_callback(callback: _tls_callback_type);
}
extern "C" {
    pub fn _cexit();
}
extern "C" {
    pub fn _c_exit();
}
extern "C" {
    pub fn _getpid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwait(
        _TermStat: *mut ::std::os::raw::c_int,
        _ProcHandle: isize,
        _Action: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn _execl(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _execle(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _execlp(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _execlpe(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _execv(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _execve(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *const ::std::os::raw::c_char,
        _Env: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _execvp(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _execvpe(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *const ::std::os::raw::c_char,
        _Env: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _spawnl(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _spawnle(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _spawnlp(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _spawnlpe(
        _Mode: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _loaddll(_Filename: *mut ::std::os::raw::c_char) -> isize;
}
extern "C" {
    pub fn _unloaddll(_Handle: isize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getdllprocaddr(
        _Handle: isize,
        _ProcedureName: *mut ::std::os::raw::c_char,
        _Ordinal: isize,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            _Handle: isize,
            _ProcedureName: *mut ::std::os::raw::c_char,
            _Ordinal: isize,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn getpid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cwait(
        _TermStat: *mut ::std::os::raw::c_int,
        _ProcHandle: isize,
        _Action: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn execl(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlpe(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spawnl(
        arg1: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn spawnle(
        arg1: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn spawnlp(
        arg1: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn spawnlpe(
        arg1: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn execv(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *mut ::std::os::raw::c_char,
        _Env: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvpe(
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *mut ::std::os::raw::c_char,
        _Env: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spawnv(
        arg1: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *mut ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn spawnve(
        arg1: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *mut ::std::os::raw::c_char,
        _Env: *const *mut ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn spawnvp(
        arg1: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *mut ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn spawnvpe(
        arg1: ::std::os::raw::c_int,
        _Filename: *const ::std::os::raw::c_char,
        _ArgList: *const *mut ::std::os::raw::c_char,
        _Env: *const *mut ::std::os::raw::c_char,
    ) -> isize;
}
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type __p_sig_fn_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __pxcptinfoptrs() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn signal(_SigNum: ::std::os::raw::c_int, _Func: __p_sig_fn_t) -> __p_sig_fn_t;
}
extern "C" {
    pub fn raise(_SigNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_timechange_handler_np(
        dummy: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_delay_np(interval: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_num_processors_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_num_processors_np(n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type pthread_once_t = ::std::os::raw::c_long;
pub type pthread_mutexattr_t = ::std::os::raw::c_uint;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_barrierattr_t = *mut ::std::os::raw::c_void;
pub type pthread_condattr_t = ::std::os::raw::c_int;
pub type pthread_rwlockattr_t = ::std::os::raw::c_int;
pub type pthread_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup {
    pub func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
    pub next: *mut _pthread_cleanup,
}
#[test]
fn bindgen_test_layout__pthread_cleanup() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup>(),
        24usize,
        concat!("Size of: ", stringify!(_pthread_cleanup))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(pol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(pol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        pid: pid_t,
        pol: ::std::os::raw::c_int,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub p_state: ::std::os::raw::c_uint,
    pub stack: *mut ::std::os::raw::c_void,
    pub s_size: usize,
    pub param: sched_param,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(p_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(s_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(param)
        )
    );
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        attr: *mut pthread_attr_t,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        attr: *const pthread_attr_t,
        param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        thread: pthread_t,
        pol: *mut ::std::os::raw::c_int,
        param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        thread: pthread_t,
        pol: ::std::os::raw::c_int,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        attr: *mut pthread_attr_t,
        pol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        attr: *const pthread_attr_t,
        pol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type pthread_spinlock_t = isize;
pub type pthread_mutex_t = isize;
pub type pthread_cond_t = isize;
pub type pthread_rwlock_t = isize;
pub type pthread_barrier_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub static mut _pthread_key_dest:
        *mut ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
}
extern "C" {
    pub fn pthread_key_create(
        key: *mut pthread_key_t,
        dest: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        key: pthread_key_t,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_once(
        o: *mut pthread_once_t,
        func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_equal(t1: pthread_t, t2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_tls_init();
}
extern "C" {
    pub fn _pthread_cleanup_dest(t: pthread_t);
}
extern "C" {
    pub fn pthread_get_concurrency(val: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_concurrency(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(res: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _pthread_invoke_cancel();
}
extern "C" {
    pub fn pthread_cancel(t: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(t: pthread_t, sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _pthread_get_state(
        attr: *const pthread_attr_t,
        flag: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _pthread_set_state(
        attr: *mut pthread_attr_t,
        flag: ::std::os::raw::c_uint,
        val: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        state: ::std::os::raw::c_int,
        oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        type_: ::std::os::raw::c_int,
        oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_wrapper(args: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        th: *mut pthread_t,
        attr: *const pthread_attr_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_join(
        t: pthread_t,
        res: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(t: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(
        thread: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        thread: pthread_t,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        rwlock_: *mut pthread_rwlock_t,
        attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(l: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        rwlock: *mut pthread_rwlock_t,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(l: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        l: *mut pthread_rwlock_t,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(l: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(l: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(l: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(l: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        cv: *mut pthread_cond_t,
        a: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(cv: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(cv: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(cv: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        cv: *mut pthread_cond_t,
        external_mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        cv: *mut pthread_cond_t,
        external_mutex: *mut pthread_mutex_t,
        t: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        cv: *mut pthread_cond_t,
        external_mutex: *mut pthread_mutex_t,
        t: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(m: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        m: *mut pthread_mutex_t,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(m: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(m: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        m: *mut pthread_mutex_t,
        a: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(m: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(b: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        b: *mut pthread_barrier_t,
        attr: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(b: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        l: *mut pthread_spinlock_t,
        pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(l: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(l: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(l: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(l: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        a: *mut pthread_attr_t,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        a: *const pthread_attr_t,
        flag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        a: *mut pthread_attr_t,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        a: *const pthread_attr_t,
        flag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        a: *mut pthread_attr_t,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        a: *const pthread_attr_t,
        flag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        attr: *const pthread_attr_t,
        stack: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        attr: *mut pthread_attr_t,
        stack: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        attr: *const pthread_attr_t,
        stack: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        attr: *mut pthread_attr_t,
        stack: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        attr: *const pthread_attr_t,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        attr: *mut pthread_attr_t,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(a: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(a: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        a: *const pthread_mutexattr_t,
        type_: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        a: *mut pthread_mutexattr_t,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        a: *const pthread_mutexattr_t,
        type_: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        a: *mut pthread_mutexattr_t,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        a: *const pthread_mutexattr_t,
        type_: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        a: *mut pthread_mutexattr_t,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        a: *const pthread_mutexattr_t,
        prio: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        a: *mut pthread_mutexattr_t,
        prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(new_level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(a: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(a: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        a: *const pthread_condattr_t,
        s: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        a: *mut pthread_condattr_t,
        s: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        attr: *const pthread_condattr_t,
        clock_id: *mut clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        attr: *mut pthread_condattr_t,
        clock_id: clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __pthread_clock_nanosleep(
        clock_id: clockid_t,
        flags: ::std::os::raw::c_int,
        rqtp: *const timespec,
        rmtp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(
        attr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(
        attr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        attr: *mut *mut ::std::os::raw::c_void,
        s: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        attr: *mut *mut ::std::os::raw::c_void,
        s: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getclean() -> *mut *mut _pthread_cleanup;
}
extern "C" {
    pub fn pthread_gethandle(t: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_getevent() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _pthread_rel_time_in_ms(ts: *const timespec) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _pthread_time_in_ms() -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _pthread_time_in_ms_from_timespec(ts: *const timespec) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _pthread_tryjoin(
        t: pthread_t,
        res: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(a: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        a: *mut pthread_rwlockattr_t,
        s: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(a: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        a: *mut pthread_rwlockattr_t,
        s: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __gthread_t = pthread_t;
pub type __gthread_key_t = pthread_key_t;
pub type __gthread_once_t = pthread_once_t;
pub type __gthread_mutex_t = pthread_mutex_t;
pub type __gthread_recursive_mutex_t = pthread_mutex_t;
pub type __gthread_cond_t = pthread_cond_t;
pub type __gthread_time_t = timespec;
pub type _Atomic_word = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: u128,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        16usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        16usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const u16,
        arg2: *const u16,
        arg3: *const u16,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub static mut _sys_errlist: [*mut ::std::os::raw::c_char; 1usize];
}
extern "C" {
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut u16) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub static mut __imp___argc: *mut ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __imp___argv: *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __imp___wargv: *mut *mut *mut u16;
}
extern "C" {
    pub static mut __imp__environ: *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __imp__wenviron: *mut *mut *mut u16;
}
extern "C" {
    pub static mut __imp__pgmptr: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __imp__wpgmptr: *mut *mut u16;
}
extern "C" {
    pub static mut __imp__osplatform: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __imp__osver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __imp__winver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __imp__winmajor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __imp__winminor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _get_osplatform(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_osver(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winver(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winmajor(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winminor(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn atoi(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoi_l(
        _Str: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atol_l(
        _Str: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn _byteswap_ushort(_Short: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Long: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Int64: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_Str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_Str: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_Str: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _Str: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut u16,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut u16,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut u16,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut u16,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mkstemp(template_name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn __strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn __mingw_strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn __mingw_strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn __mingw_strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn _strtod_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const u16,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn calloc(_NumOfElements: usize, _SizeOfElements: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _NewSize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fullpath(
        _FullPath: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _SizeInBytes: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt(
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _Str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _Str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _Str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lrotl(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _lrotr(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _makepath(
        _Path: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn _rotl64(
        _Val: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr64(
        Value: ::std::os::raw::c_ulonglong,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Val: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotl(
        _Val: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _EnvVar: *const ::std::os::raw::c_char,
        _ResultPath: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Val: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Val: ::std::os::raw::c_ulong,
        _Dstbuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _dupenv_s(
        _PBuffer: *mut *mut ::std::os::raw::c_char,
        _PBufferSizeInBytes: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _ReturnSize: *mut usize,
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa_s(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa_s(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa_s(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa_s(
        _Val: ::std::os::raw::c_ulong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: u16,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const u16,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const u16,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDights: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath_s(
        _PathResult: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _EnvVar: *const ::std::os::raw::c_char,
        _ResultPath: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveSize: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirSize: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameSize: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtSize: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__heapinfo() {
    const UNINIT: ::std::mem::MaybeUninit<_heapinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_heapinfo>(),
        24usize,
        concat!("Size of: ", stringify!(_heapinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_heapinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_heapinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pentry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_pentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._useflag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_useflag)
        )
    );
}
pub type _HEAPINFO = _heapinfo;
extern "C" {
    pub static mut _amblksiz: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __mingw_aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_aligned_free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __mingw_aligned_offset_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_aligned_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_malloc_crt_max_wait(_NewValue: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _expand(
        _Memory: *mut ::std::os::raw::c_void,
        _NewSize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize(_Memory: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _get_sbh_threshold() -> usize;
}
extern "C" {
    pub fn _set_sbh_threshold(_NewValue: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_amblksiz(_Value: usize) -> errno_t;
}
extern "C" {
    pub fn _get_amblksiz(_Value: *mut usize) -> errno_t;
}
extern "C" {
    pub fn _heapadd(_Memory: *mut ::std::os::raw::c_void, _Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapset(_Fill: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapused(_Used: *mut usize, _Commit: *mut usize) -> usize;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_8 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_12 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_13 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_14 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_15 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_16 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_18 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_19 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_20 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_21 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_22 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_23 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_24 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_27 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_28 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_29 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_32 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_33 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_34 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_35 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_36 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_37 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_38 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_39 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_40 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_41 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_42 {
    pub _address: u8,
}
pub type rep = ::std::os::raw::c_longlong;
pub type iterator = std__Bit_iterator;
pub type size_type = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_43 {
    pub _address: u8,
}
